{"version":3,"sources":["webpack:///./node_modules/mpd-parser/dist/mpd-parser.es.js","webpack:///./node_modules/m3u8-parser/dist/m3u8-parser.es.js"],"names":["global","__webpack_require__","d","__webpack_exports__","parse","parseUTCTiming","global_window__WEBPACK_IMPORTED_MODULE_0__","global_window__WEBPACK_IMPORTED_MODULE_0___default","n","isObject","obj","merge","_len","arguments","length","objects","Array","_key","reduce","result","source","Object","keys","forEach","key","isArray","concat","values","o","map","k","range","start","end","i","push","flatten","lists","x","y","from","list","findIndexes","l","a","e","mergeDiscontiguousPlaylists","playlists","mergedPlaylists","acc","playlist","_acc$name$segments","name","attributes","id","lang","segments","discontinuity","apply","contentProtection","discontinuityStarts","formatAudioPlaylist","_ref","_attributes","NAME","BANDWIDTH","bandwidth","CODECS","codecs","uri","endList","type","timeline","periodIndex","resolvedUri","targetDuration","duration","mediaSequence","number","formatVttPlaylist","_ref2","_attributes2","baseUrl","sourceDuration","organizeAudioPlaylists","role","value","language","label","autoselect","default","organizeVttPlaylists","formatVideoPlaylist","_ref3","_attributes3","AUDIO","SUBTITLES","RESOLUTION","width","height","toM3u8","dashPlaylists","_mediaGroups","_dashPlaylists$0$attr","_dashPlaylists$0$attr2","minimumUpdatePeriod","videoOnly","_ref4","mimeType","contentType","audioOnly","_ref5","vttOnly","_ref6","videoPlaylists","filter","audioPlaylists","vttPlaylists","master","allowCache","mediaGroups","VIDEO","audio","subs","window","self","createCommonjsModule","fn","module","exports","urlToolkit","root","URL_REGEX","FIRST_SEGMENT_REGEX","SLASH_DOT_REGEX","SLASH_DOT_DOT_REGEX","URLToolkit","buildAbsoluteURL","baseURL","relativeURL","opts","trim","alwaysNormalize","basePartsForNormalise","parseURL","Error","path","normalizePath","buildURLFromParts","relativeParts","scheme","baseParts","netLoc","pathParts","exec","builtParts","params","query","fragment","baseURLPath","newPath","substring","lastIndexOf","url","parts","split","reverse","join","replace","resolveUrl","relativeUrl","test","location","href","urlTypeToSegment","_ref$baseUrl","_ref$source","_ref$range","init","ranges","startRange","parseInt","endRange","byterange","offset","getLiveRValue","time","NOW","clientOffset","availabilityStartTime","_attributes$timescale","timescale","_attributes$start","_attributes$minimumUp","now","periodStartWC","periodEndWC","periodDuration","Math","ceil","parseByTimeline","segmentTimeline","_attributes$type","_attributes$minimumUp2","_attributes$media","media","_attributes$timescale2","_attributes$startNumb","startNumber","sIndex","S","repeat","r","segmentTime","t","count","nextS","indexOf","segmentRange","static","dynamic","_attributes$timeShift","timeShiftBufferDepth","Infinity","segmentCount","availableStart","floor","availableEnd","max","min","toSegments","index","_attributes$timescale3","parseByDuration","_attributes$timescale4","_segmentRange$type","identifierPattern","identifierReplacement","match","identifier","format","constructTemplateUrl","parseTemplateInfo","segmentsFromTemplate","templateValues","RepresentationID","Bandwidth","_attributes$initializ","initialization","sourceURL","mapSegment","segment","Number","Time","errors","INVALID_NUMBER_OF_PERIOD","DASH_EMPTY_MANIFEST","DASH_INVALID_XML","NO_BASE_URL","MISSING_SEGMENT_INFORMATION","SEGMENT_TIME_UNSPECIFIED","UNSUPPORTED_UTC_TIMING_SCHEME","SegmentURLToSegmentObject","segmentUrl","initSegment","mediaRange","segmentsFromList","_attributes$segmentUr","segmentUrls","segmentTimeInfo","segmentUrlMap","segmentUrlObject","segmentsFromBase","_attributes$indexRang","indexRange","generateSegments","segmentAttributes","segmentsFn","segmentInfo","template","base","_segmentAttributes","_segmentAttributes$ti","toPlaylists","representations","findChildren","element","childNodes","tagName","getContent","textContent","parseDuration","str","SECONDS_IN_YEAR","SECONDS_IN_MONTH","SECONDS_IN_DAY","SECONDS_IN_HOUR","SECONDS_IN_MIN","durationRegex","_match$slice","slice","year","month","day","hour","minute","second","parseFloat","parseDate","dateRegex","Date","parsers","mediaPresentationDuration","parsedValue","isNaN","DEFAULT","parseAttributes","el","parseFn","decodeB64ToUint8Array","b64Text","decodedString","atob","array","Uint8Array","charCodeAt","keySystemsMap","urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b","urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed","urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95","urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb","buildBaseUrls","referenceUrls","baseUrlElements","reference","baseUrlElement","getSegmentInformation","adaptationSet","segmentTemplate","segmentList","s","tag","segmentBase","segmentTimelineParentNode","segmentInitializationParentNode","segmentInitialization","inheritBaseUrls","adaptationSetAttributes","adaptationSetBaseUrls","adaptationSetSegmentInfo","representation","repBaseUrlElements","repBaseUrls","representationSegmentInfo","generateKeySystemInformation","contentProtectionNodes","node","keySystem","schemeIdUri","psshNode","pssh","psshBuffer","toRepresentations","periodAttributes","periodBaseUrls","periodSegmentInfo","roleAttributes","attrs","toAdaptationSets","mpdAttributes","mpdBaseUrls","period","periodAtt","parsedPeriodId","adaptationSets","inheritAttributes","mpd","options","_options","_options$manifestUri","manifestUri","_options$NOW","_options$clientOffset","periods","stringToMpdXml","manifestString","parser","DOMParser","xml","parseFromString","documentElement","getElementsByTagName","parseUTCTimingScheme","UTCTimingNode","method","_extends","assign","target","prototype","hasOwnProperty","call","this","_inheritsLoose","subClass","superClass","create","constructor","__proto__","_assertThisInitialized","ReferenceError","Parser","Stream","listeners","_proto","on","listener","off","splice","trigger","args","callbacks","dispose","pipe","destination","data","LineStream","_Stream","_this","buffer","nextNewline","attributeSeparator","keyvalue","RegExp","attr","ParseStream","customParsers","tagMappers","line","event","_this2","newLines","mapper","mappedLine","newLine","tagType","title","version","playlistType","allowed","URI","BYTERANGE","_attributes$BYTERANGE","resolution","dateTimeString","dateTimeObject","IV","toLowerCase","Uint32Array","PRECISE","text","addParser","_this3","expression","customType","dataParser","addTagMapper","mapFn","lineStream","parseStream","currentMap","uris","currentUri","noop","defaultMediaGroups","CLOSED-CAPTIONS","currentTimeline","manifest","entry","mediaGroup","rendition","allow-cache","message","endlist","inf","discontinuitySequence","METHOD","iv","media-sequence","isFinite","discontinuity-sequence","playlist-type","stream-inf","TYPE","mediaGroupType","AUTOSELECT","LANGUAGE","instreamId","CHARACTERISTICS","characteristics","FORCED","forced","program-date-time","targetduration","totalduration","totalDuration","timeOffset","precise","cue-out","cueOut","cue-out-cont","cueOutCont","cue-in","cueIn","comment","custom","chunk"],"mappings":"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","file":"js/chunk-vendors~7cb01e1c.0510bd37.js","sourcesContent":["/*! @name mpd-parser @version 0.7.0 @license Apache-2.0 */\nimport window$1 from 'global/window';\n\nvar version = \"0.7.0\";\n\nvar isObject = function isObject(obj) {\n  return !!obj && typeof obj === 'object';\n};\n\nvar merge = function merge() {\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  return objects.reduce(function (result, source) {\n    Object.keys(source).forEach(function (key) {\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\nvar values = function values(o) {\n  return Object.keys(o).map(function (k) {\n    return o[k];\n  });\n};\n\nvar range = function range(start, end) {\n  var result = [];\n\n  for (var i = start; i < end; i++) {\n    result.push(i);\n  }\n\n  return result;\n};\nvar flatten = function flatten(lists) {\n  return lists.reduce(function (x, y) {\n    return x.concat(y);\n  }, []);\n};\nvar from = function from(list) {\n  if (!list.length) {\n    return [];\n  }\n\n  var result = [];\n\n  for (var i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n\n  return result;\n};\nvar findIndexes = function findIndexes(l, key) {\n  return l.reduce(function (a, e, i) {\n    if (e[key]) {\n      a.push(i);\n    }\n\n    return a;\n  }, []);\n};\n\nvar mergeDiscontiguousPlaylists = function mergeDiscontiguousPlaylists(playlists) {\n  var mergedPlaylists = values(playlists.reduce(function (acc, playlist) {\n    // assuming playlist IDs are the same across periods\n    // TODO: handle multiperiod where representation sets are not the same\n    // across periods\n    var name = playlist.attributes.id + (playlist.attributes.lang || ''); // Periods after first\n\n    if (acc[name]) {\n      var _acc$name$segments;\n\n      // first segment of subsequent periods signal a discontinuity\n      playlist.segments[0].discontinuity = true;\n\n      (_acc$name$segments = acc[name].segments).push.apply(_acc$name$segments, playlist.segments); // bubble up contentProtection, this assumes all DRM content\n      // has the same contentProtection\n\n\n      if (playlist.attributes.contentProtection) {\n        acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n      }\n    } else {\n      // first Period\n      acc[name] = playlist;\n    }\n\n    return acc;\n  }, {}));\n  return mergedPlaylists.map(function (playlist) {\n    playlist.discontinuityStarts = findIndexes(playlist.segments, 'discontinuity');\n    return playlist;\n  });\n};\n\nvar formatAudioPlaylist = function formatAudioPlaylist(_ref) {\n  var _attributes;\n\n  var attributes = _ref.attributes,\n      segments = _ref.segments;\n  var playlist = {\n    attributes: (_attributes = {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs\n    }, _attributes['PROGRAM-ID'] = 1, _attributes),\n    uri: '',\n    endList: (attributes.type || 'static') === 'static',\n    timeline: attributes.periodIndex,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    segments: segments,\n    mediaSequence: segments.length ? segments[0].number : 1\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  return playlist;\n};\nvar formatVttPlaylist = function formatVttPlaylist(_ref2) {\n  var _attributes2;\n\n  var attributes = _ref2.attributes,\n      segments = _ref2.segments;\n\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodIndex,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }]; // targetDuration should be the same duration as the only segment\n\n    attributes.duration = attributes.sourceDuration;\n  }\n\n  return {\n    attributes: (_attributes2 = {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth\n    }, _attributes2['PROGRAM-ID'] = 1, _attributes2),\n    uri: '',\n    endList: (attributes.type || 'static') === 'static',\n    timeline: attributes.periodIndex,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    segments: segments,\n    mediaSequence: segments.length ? segments[0].number : 1\n  };\n};\nvar organizeAudioPlaylists = function organizeAudioPlaylists(playlists) {\n  return playlists.reduce(function (a, playlist) {\n    var role = playlist.attributes.role && playlist.attributes.role.value || 'main';\n    var language = playlist.attributes.lang || '';\n    var label = 'main';\n\n    if (language) {\n      label = playlist.attributes.lang + \" (\" + role + \")\";\n    } // skip if we already have the highest quality audio for a language\n\n\n    if (a[label] && a[label].playlists[0].attributes.BANDWIDTH > playlist.attributes.bandwidth) {\n      return a;\n    }\n\n    a[label] = {\n      language: language,\n      autoselect: true,\n      default: role === 'main',\n      playlists: [formatAudioPlaylist(playlist)],\n      uri: ''\n    };\n    return a;\n  }, {});\n};\nvar organizeVttPlaylists = function organizeVttPlaylists(playlists) {\n  return playlists.reduce(function (a, playlist) {\n    var label = playlist.attributes.lang || 'text'; // skip if we already have subtitles\n\n    if (a[label]) {\n      return a;\n    }\n\n    a[label] = {\n      language: label,\n      default: false,\n      autoselect: false,\n      playlists: [formatVttPlaylist(playlist)],\n      uri: ''\n    };\n    return a;\n  }, {});\n};\nvar formatVideoPlaylist = function formatVideoPlaylist(_ref3) {\n  var _attributes3;\n\n  var attributes = _ref3.attributes,\n      segments = _ref3.segments;\n  var playlist = {\n    attributes: (_attributes3 = {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth\n    }, _attributes3['PROGRAM-ID'] = 1, _attributes3),\n    uri: '',\n    endList: (attributes.type || 'static') === 'static',\n    timeline: attributes.periodIndex,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    segments: segments,\n    mediaSequence: segments.length ? segments[0].number : 1\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  return playlist;\n};\nvar toM3u8 = function toM3u8(dashPlaylists) {\n  var _mediaGroups;\n\n  if (!dashPlaylists.length) {\n    return {};\n  } // grab all master attributes\n\n\n  var _dashPlaylists$0$attr = dashPlaylists[0].attributes,\n      duration = _dashPlaylists$0$attr.sourceDuration,\n      _dashPlaylists$0$attr2 = _dashPlaylists$0$attr.minimumUpdatePeriod,\n      minimumUpdatePeriod = _dashPlaylists$0$attr2 === void 0 ? 0 : _dashPlaylists$0$attr2;\n\n  var videoOnly = function videoOnly(_ref4) {\n    var attributes = _ref4.attributes;\n    return attributes.mimeType === 'video/mp4' || attributes.contentType === 'video';\n  };\n\n  var audioOnly = function audioOnly(_ref5) {\n    var attributes = _ref5.attributes;\n    return attributes.mimeType === 'audio/mp4' || attributes.contentType === 'audio';\n  };\n\n  var vttOnly = function vttOnly(_ref6) {\n    var attributes = _ref6.attributes;\n    return attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n  };\n\n  var videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n  var audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n  var vttPlaylists = dashPlaylists.filter(vttOnly);\n  var master = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: (_mediaGroups = {\n      AUDIO: {},\n      VIDEO: {}\n    }, _mediaGroups['CLOSED-CAPTIONS'] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),\n    uri: '',\n    duration: duration,\n    playlists: videoPlaylists,\n    minimumUpdatePeriod: minimumUpdatePeriod * 1000\n  };\n\n  if (audioPlaylists.length) {\n    master.mediaGroups.AUDIO.audio = organizeAudioPlaylists(audioPlaylists);\n  }\n\n  if (vttPlaylists.length) {\n    master.mediaGroups.SUBTITLES.subs = organizeVttPlaylists(vttPlaylists);\n  }\n\n  return master;\n};\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar urlToolkit = createCommonjsModule(function (module, exports) {\n// see https://tools.ietf.org/html/rfc1808\n\n/* jshint ignore:start */\n(function(root) { \n/* jshint ignore:end */\n\n  var URL_REGEX = /^((?:[a-zA-Z0-9+\\-.]+:)?)(\\/\\/[^\\/?#]*)?((?:[^\\/\\?#]*\\/)*.*?)??(;.*?)?(\\?.*?)?(#.*?)?$/;\n  var FIRST_SEGMENT_REGEX = /^([^\\/?#]*)(.*)$/;\n  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/).*?(?=\\/)/g;\n\n  var URLToolkit = { // jshint ignore:line\n    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n    // E.g\n    // With opts.alwaysNormalize = false (default, spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n    // With opts.alwaysNormalize = true (not spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n    buildAbsoluteURL: function(baseURL, relativeURL, opts) {\n      opts = opts || {};\n      // remove any remaining space and CRLF\n      baseURL = baseURL.trim();\n      relativeURL = relativeURL.trim();\n      if (!relativeURL) {\n        // 2a) If the embedded URL is entirely empty, it inherits the\n        // entire base URL (i.e., is set equal to the base URL)\n        // and we are done.\n        if (!opts.alwaysNormalize) {\n          return baseURL;\n        }\n        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n        if (!basePartsForNormalise) {\n          throw new Error('Error trying to parse base URL.');\n        }\n        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\n        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n      }\n      var relativeParts = URLToolkit.parseURL(relativeURL);\n      if (!relativeParts) {\n        throw new Error('Error trying to parse relative URL.');\n      }\n      if (relativeParts.scheme) {\n        // 2b) If the embedded URL starts with a scheme name, it is\n        // interpreted as an absolute URL and we are done.\n        if (!opts.alwaysNormalize) {\n          return relativeURL;\n        }\n        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n        return URLToolkit.buildURLFromParts(relativeParts);\n      }\n      var baseParts = URLToolkit.parseURL(baseURL);\n      if (!baseParts) {\n        throw new Error('Error trying to parse base URL.');\n      }\n      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n        baseParts.netLoc = pathParts[1];\n        baseParts.path = pathParts[2];\n      }\n      if (baseParts.netLoc && !baseParts.path) {\n        baseParts.path = '/';\n      }\n      var builtParts = {\n        // 2c) Otherwise, the embedded URL inherits the scheme of\n        // the base URL.\n        scheme: baseParts.scheme,\n        netLoc: relativeParts.netLoc,\n        path: null,\n        params: relativeParts.params,\n        query: relativeParts.query,\n        fragment: relativeParts.fragment\n      };\n      if (!relativeParts.netLoc) {\n        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n        // (if any) of the base URL.\n        builtParts.netLoc = baseParts.netLoc;\n        // 4) If the embedded URL path is preceded by a slash \"/\", the\n        // path is not relative and we skip to Step 7.\n        if (relativeParts.path[0] !== '/') {\n          if (!relativeParts.path) {\n            // 5) If the embedded URL path is empty (and not preceded by a\n            // slash), then the embedded URL inherits the base URL path\n            builtParts.path = baseParts.path;\n            // 5a) if the embedded URL's <params> is non-empty, we skip to\n            // step 7; otherwise, it inherits the <params> of the base\n            // URL (if any) and\n            if (!relativeParts.params) {\n              builtParts.params = baseParts.params;\n              // 5b) if the embedded URL's <query> is non-empty, we skip to\n              // step 7; otherwise, it inherits the <query> of the base\n              // URL (if any) and we skip to step 7.\n              if (!relativeParts.query) {\n                builtParts.query = baseParts.query;\n              }\n            }\n          } else {\n            // 6) The last segment of the base URL's path (anything\n            // following the rightmost slash \"/\", or the entire path if no\n            // slash is present) is removed and the embedded URL's path is\n            // appended in its place.\n            var baseURLPath = baseParts.path;\n            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;\n            builtParts.path = URLToolkit.normalizePath(newPath);\n          }\n        }\n      }\n      if (builtParts.path === null) {\n        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\n      }\n      return URLToolkit.buildURLFromParts(builtParts);\n    },\n    parseURL: function(url) {\n      var parts = URL_REGEX.exec(url);\n      if (!parts) {\n        return null;\n      }\n      return {\n        scheme: parts[1] || '',\n        netLoc: parts[2] || '',\n        path: parts[3] || '',\n        params: parts[4] || '',\n        query: parts[5] || '',\n        fragment: parts[6] || ''\n      };\n    },\n    normalizePath: function(path) {\n      // The following operations are\n      // then applied, in order, to the new path:\n      // 6a) All occurrences of \"./\", where \".\" is a complete path\n      // segment, are removed.\n      // 6b) If the path ends with \".\" as a complete path segment,\n      // that \".\" is removed.\n      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n      // complete path segment not equal to \"..\", are removed.\n      // Removal of these path segments is performed iteratively,\n      // removing the leftmost matching pattern on each iteration,\n      // until no matching pattern remains.\n      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n      // complete path segment not equal to \"..\", that\n      // \"<segment>/..\" is removed.\n      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line\n      return path.split('').reverse().join('');\n    },\n    buildURLFromParts: function(parts) {\n      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\n    }\n  };\n\n/* jshint ignore:start */\n  module.exports = URLToolkit;\n})(commonjsGlobal);\n/* jshint ignore:end */\n});\n\nvar resolveUrl = function resolveUrl(baseUrl, relativeUrl) {\n  // return early if we don't need to resolve\n  if (/^[a-z]+:/i.test(relativeUrl)) {\n    return relativeUrl;\n  } // if the base URL is relative then combine with the current location\n\n\n  if (!/\\/\\//i.test(baseUrl)) {\n    baseUrl = urlToolkit.buildAbsoluteURL(window$1.location.href, baseUrl);\n  }\n\n  return urlToolkit.buildAbsoluteURL(baseUrl, relativeUrl);\n};\n\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls, follows\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\n\nvar urlTypeToSegment = function urlTypeToSegment(_ref) {\n  var _ref$baseUrl = _ref.baseUrl,\n      baseUrl = _ref$baseUrl === void 0 ? '' : _ref$baseUrl,\n      _ref$source = _ref.source,\n      source = _ref$source === void 0 ? '' : _ref$source,\n      _ref$range = _ref.range,\n      range = _ref$range === void 0 ? '' : _ref$range;\n  var init = {\n    uri: source,\n    resolvedUri: resolveUrl(baseUrl || '', source)\n  };\n\n  if (range) {\n    var ranges = range.split('-');\n    var startRange = parseInt(ranges[0], 10);\n    var endRange = parseInt(ranges[1], 10);\n    init.byterange = {\n      length: endRange - startRange,\n      offset: startRange\n    };\n  }\n\n  return init;\n};\n\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\nvar getLiveRValue = function getLiveRValue(attributes, time, duration) {\n  var NOW = attributes.NOW,\n      clientOffset = attributes.clientOffset,\n      availabilityStartTime = attributes.availabilityStartTime,\n      _attributes$timescale = attributes.timescale,\n      timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n      _attributes$start = attributes.start,\n      start = _attributes$start === void 0 ? 0 : _attributes$start,\n      _attributes$minimumUp = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp;\n  var now = (NOW + clientOffset) / 1000;\n  var periodStartWC = availabilityStartTime + start;\n  var periodEndWC = now + minimumUpdatePeriod;\n  var periodDuration = periodEndWC - periodStartWC;\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nvar parseByTimeline = function parseByTimeline(attributes, segmentTimeline) {\n  var _attributes$type = attributes.type,\n      type = _attributes$type === void 0 ? 'static' : _attributes$type,\n      _attributes$minimumUp2 = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp2 === void 0 ? 0 : _attributes$minimumUp2,\n      _attributes$media = attributes.media,\n      media = _attributes$media === void 0 ? '' : _attributes$media,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$timescale2 = attributes.timescale,\n      timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\n      _attributes$startNumb = attributes.startNumber,\n      startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb,\n      timeline = attributes.periodIndex;\n  var segments = [];\n  var time = -1;\n\n  for (var sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    var S = segmentTimeline[sIndex];\n    var duration = S.d;\n    var repeat = S.r || 0;\n    var segmentTime = S.t || 0;\n\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n      time = segmentTime;\n    }\n\n    var count = void 0;\n\n    if (repeat < 0) {\n      var nextS = sIndex + 1;\n\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n\n    var end = startNumber + segments.length + count;\n    var number = startNumber + segments.length;\n\n    while (number < end) {\n      segments.push({\n        number: number,\n        duration: duration / timescale,\n        time: time,\n        timeline: timeline\n      });\n      time += duration;\n      number++;\n    }\n  }\n\n  return segments;\n};\n\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\n\nvar segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  static: function _static(attributes) {\n    var duration = attributes.duration,\n        _attributes$timescale = attributes.timescale,\n        timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n        sourceDuration = attributes.sourceDuration;\n    return {\n      start: 0,\n      end: Math.ceil(sourceDuration / (duration / timescale))\n    };\n  },\n\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic: function dynamic(attributes) {\n    var NOW = attributes.NOW,\n        clientOffset = attributes.clientOffset,\n        availabilityStartTime = attributes.availabilityStartTime,\n        _attributes$timescale2 = attributes.timescale,\n        timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\n        duration = attributes.duration,\n        _attributes$start = attributes.start,\n        start = _attributes$start === void 0 ? 0 : _attributes$start,\n        _attributes$minimumUp = attributes.minimumUpdatePeriod,\n        minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp,\n        _attributes$timeShift = attributes.timeShiftBufferDepth,\n        timeShiftBufferDepth = _attributes$timeShift === void 0 ? Infinity : _attributes$timeShift;\n    var now = (NOW + clientOffset) / 1000;\n    var periodStartWC = availabilityStartTime + start;\n    var periodEndWC = now + minimumUpdatePeriod;\n    var periodDuration = periodEndWC - periodStartWC;\n    var segmentCount = Math.ceil(periodDuration * timescale / duration);\n    var availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    var availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n    return {\n      start: Math.max(0, availableStart),\n      end: Math.min(segmentCount, availableEnd)\n    };\n  }\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\n\nvar toSegments = function toSegments(attributes) {\n  return function (number, index) {\n    var duration = attributes.duration,\n        _attributes$timescale3 = attributes.timescale,\n        timescale = _attributes$timescale3 === void 0 ? 1 : _attributes$timescale3,\n        periodIndex = attributes.periodIndex,\n        _attributes$startNumb = attributes.startNumber,\n        startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb;\n    return {\n      number: startNumber + number,\n      duration: duration / timescale,\n      timeline: periodIndex,\n      time: index * duration\n    };\n  };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nvar parseByDuration = function parseByDuration(attributes) {\n  var _attributes$type = attributes.type,\n      type = _attributes$type === void 0 ? 'static' : _attributes$type,\n      duration = attributes.duration,\n      _attributes$timescale4 = attributes.timescale,\n      timescale = _attributes$timescale4 === void 0 ? 1 : _attributes$timescale4,\n      sourceDuration = attributes.sourceDuration;\n\n  var _segmentRange$type = segmentRange[type](attributes),\n      start = _segmentRange$type.start,\n      end = _segmentRange$type.end;\n\n  var segments = range(start, end).map(toSegments(attributes));\n\n  if (type === 'static') {\n    var index = segments.length - 1; // final segment may be less than full segment duration\n\n    segments[index].duration = sourceDuration - duration / timescale * index;\n  }\n\n  return segments;\n};\n\nvar identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\n\nvar identifierReplacement = function identifierReplacement(values) {\n  return function (match, identifier, format, width) {\n    if (match === '$$') {\n      // escape sequence\n      return '$';\n    }\n\n    if (typeof values[identifier] === 'undefined') {\n      return match;\n    }\n\n    var value = '' + values[identifier];\n\n    if (identifier === 'RepresentationID') {\n      // Format tag shall not be present with RepresentationID\n      return value;\n    }\n\n    if (!format) {\n      width = 1;\n    } else {\n      width = parseInt(width, 10);\n    }\n\n    if (value.length >= width) {\n      return value;\n    }\n\n    return \"\" + new Array(width - value.length + 1).join('0') + value;\n  };\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\n\nvar constructTemplateUrl = function constructTemplateUrl(url, values) {\n  return url.replace(identifierPattern, identifierReplacement(values));\n};\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nvar parseTemplateInfo = function parseTemplateInfo(attributes, segmentTimeline) {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodIndex\n    }];\n  }\n\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n\n  return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\n\nvar segmentsFromTemplate = function segmentsFromTemplate(attributes, segmentTimeline) {\n  var templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n  var _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {\n    sourceURL: '',\n    range: ''\n  } : _attributes$initializ;\n  var mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n  var segments = parseTemplateInfo(attributes, segmentTimeline);\n  return segments.map(function (segment) {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n    var uri = constructTemplateUrl(attributes.media || '', templateValues);\n    return {\n      uri: uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: resolveUrl(attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number\n    };\n  });\n};\n\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\n\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\n\nvar SegmentURLToSegmentObject = function SegmentURLToSegmentObject(attributes, segmentUrl) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ;\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  var segment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n  segment.map = initSegment;\n  return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\n\n\nvar segmentsFromList = function segmentsFromList(attributes, segmentTimeline) {\n  var duration = attributes.duration,\n      _attributes$segmentUr = attributes.segmentUrls,\n      segmentUrls = _attributes$segmentUr === void 0 ? [] : _attributes$segmentUr; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n\n  var segmentUrlMap = segmentUrls.map(function (segmentUrlObject) {\n    return SegmentURLToSegmentObject(attributes, segmentUrlObject);\n  });\n  var segmentTimeInfo;\n\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n\n  var segments = segmentTimeInfo.map(function (segmentTime, index) {\n    if (segmentUrlMap[index]) {\n      var segment = segmentUrlMap[index];\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      return segment;\n    } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n\n  }).filter(function (segment) {\n    return segment;\n  });\n  return segments;\n};\n\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\n\nvar segmentsFromBase = function segmentsFromBase(attributes) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$timescale = attributes.timescale,\n      timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n      _attributes$indexRang = attributes.indexRange,\n      indexRange = _attributes$indexRang === void 0 ? '' : _attributes$indexRang,\n      duration = attributes.duration; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  var segment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: baseUrl,\n    range: indexRange\n  });\n  segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n\n  if (duration) {\n    var segmentTimeInfo = parseByDuration(attributes);\n\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration / timescale;\n    segment.timeline = 0;\n  } // This is used for mediaSequence\n\n\n  segment.number = 0;\n  return [segment];\n};\n\nvar generateSegments = function generateSegments(_ref) {\n  var attributes = _ref.attributes,\n      segmentInfo = _ref.segmentInfo;\n  var segmentAttributes;\n  var segmentsFn;\n\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n\n  if (!segmentsFn) {\n    return {\n      attributes: attributes\n    };\n  }\n\n  var segments = segmentsFn(segmentAttributes, segmentInfo.timeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n\n  if (segmentAttributes.duration) {\n    var _segmentAttributes = segmentAttributes,\n        duration = _segmentAttributes.duration,\n        _segmentAttributes$ti = _segmentAttributes.timescale,\n        timescale = _segmentAttributes$ti === void 0 ? 1 : _segmentAttributes$ti;\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce(function (max, segment) {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n\n  return {\n    attributes: segmentAttributes,\n    segments: segments\n  };\n};\nvar toPlaylists = function toPlaylists(representations) {\n  return representations.map(generateSegments);\n};\n\nvar findChildren = function findChildren(element, name) {\n  return from(element.childNodes).filter(function (_ref) {\n    var tagName = _ref.tagName;\n    return tagName === name;\n  });\n};\nvar getContent = function getContent(element) {\n  return element.textContent.trim();\n};\n\nvar parseDuration = function parseDuration(str) {\n  var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  var SECONDS_IN_DAY = 24 * 60 * 60;\n  var SECONDS_IN_HOUR = 60 * 60;\n  var SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n  var durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  var match = durationRegex.exec(str);\n\n  if (!match) {\n    return 0;\n  }\n\n  var _match$slice = match.slice(1),\n      year = _match$slice[0],\n      month = _match$slice[1],\n      day = _match$slice[2],\n      hour = _match$slice[3],\n      minute = _match$slice[4],\n      second = _match$slice[5];\n\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\nvar parseDate = function parseDate(str) {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  var dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n\n  return Date.parse(str);\n};\n\nvar parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration: function mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime: function availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod: function minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth: function timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start: function start(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width: function width(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height: function height(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth: function bandwidth(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber: function startNumber(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The aprsed timescale\n   */\n  timescale: function timescale(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration: function duration(value) {\n    var parsedValue = parseInt(value, 10);\n\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n\n    return parsedValue;\n  },\n\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d: function d(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t: function t(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r: function r(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT: function DEFAULT(value) {\n    return value;\n  }\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\n\nvar parseAttributes = function parseAttributes(el) {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n\n  return from(el.attributes).reduce(function (a, e) {\n    var parseFn = parsers[e.name] || parsers.DEFAULT;\n    a[e.name] = parseFn(e.value);\n    return a;\n  }, {});\n};\n\nfunction decodeB64ToUint8Array(b64Text) {\n  var decodedString = window$1.atob(b64Text);\n  var array = new Uint8Array(decodedString.length);\n\n  for (var i = 0; i < decodedString.length; i++) {\n    array[i] = decodedString.charCodeAt(i);\n  }\n\n  return array;\n}\n\nvar keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {string[]} referenceUrls\n *        List of reference urls to resolve to\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {string[]}\n *         List of resolved urls\n */\n\nvar buildBaseUrls = function buildBaseUrls(referenceUrls, baseUrlElements) {\n  if (!baseUrlElements.length) {\n    return referenceUrls;\n  }\n\n  return flatten(referenceUrls.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      return resolveUrl(reference, getContent(baseUrlElement));\n    });\n  }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} timeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\n\nvar getSegmentInformation = function getSegmentInformation(adaptationSet) {\n  var segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  var segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  var segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(function (s) {\n    return merge({\n      tag: 'SegmentURL'\n    }, parseAttributes(s));\n  });\n  var segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  var segmentTimelineParentNode = segmentList || segmentTemplate;\n  var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n\n  var template = segmentTemplate && parseAttributes(segmentTemplate);\n\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = {\n      sourceURL: template.initialization\n    };\n  }\n\n  var segmentInfo = {\n    template: template,\n    timeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(function (s) {\n      return parseAttributes(s);\n    }),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls: segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n  Object.keys(segmentInfo).forEach(function (key) {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n  return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {string[]} adaptationSetBaseUrls\n *        Contains list of resolved base urls inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\n\nvar inheritBaseUrls = function inheritBaseUrls(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {\n  return function (representation) {\n    var repBaseUrlElements = findChildren(representation, 'BaseURL');\n    var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n    var attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n    var representationSegmentInfo = getSegmentInformation(representation);\n    return repBaseUrls.map(function (baseUrl) {\n      return {\n        segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n        attributes: merge(attributes, {\n          baseUrl: baseUrl\n        })\n      };\n    });\n  };\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\n\nvar generateKeySystemInformation = function generateKeySystemInformation(contentProtectionNodes) {\n  return contentProtectionNodes.reduce(function (acc, node) {\n    var attributes = parseAttributes(node);\n    var keySystem = keySystemsMap[attributes.schemeIdUri];\n\n    if (keySystem) {\n      acc[keySystem] = {\n        attributes: attributes\n      };\n      var psshNode = findChildren(node, 'cenc:pssh')[0];\n\n      if (psshNode) {\n        var pssh = getContent(psshNode);\n        var psshBuffer = pssh && decodeB64ToUint8Array(pssh);\n        acc[keySystem].pssh = psshBuffer;\n      }\n    }\n\n    return acc;\n  }, {});\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {string[]} periodBaseUrls\n *        Contains list of resolved base urls inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\n\n\nvar toRepresentations = function toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo) {\n  return function (adaptationSet) {\n    var adaptationSetAttributes = parseAttributes(adaptationSet);\n    var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n    var role = findChildren(adaptationSet, 'Role')[0];\n    var roleAttributes = {\n      role: parseAttributes(role)\n    };\n    var attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n    var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n\n    if (Object.keys(contentProtection).length) {\n      attrs = merge(attrs, {\n        contentProtection: contentProtection\n      });\n    }\n\n    var segmentInfo = getSegmentInformation(adaptationSet);\n    var representations = findChildren(adaptationSet, 'Representation');\n    var adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n    return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n  };\n};\n/**\n * Maps an Period node to a list of Representation inforamtion objects for all\n * AdaptationSet nodes contained within the Period\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {Node} period\n *        Period node from the mpd\n * @param {number} periodIndex\n *        Index of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n * @param {string[]} mpdBaseUrls\n *        Contains list of resolved base urls inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\n\nvar toAdaptationSets = function toAdaptationSets(mpdAttributes, mpdBaseUrls) {\n  return function (period, index) {\n    var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period, 'BaseURL'));\n    var periodAtt = parseAttributes(period);\n    var parsedPeriodId = parseInt(periodAtt.id, 10); // fallback to mapping index if Period@id is not a number\n\n    var periodIndex = window$1.isNaN(parsedPeriodId) ? index : parsedPeriodId;\n    var periodAttributes = merge(mpdAttributes, {\n      periodIndex: periodIndex\n    });\n    var adaptationSets = findChildren(period, 'AdaptationSet');\n    var periodSegmentInfo = getSegmentInformation(period);\n    return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n  };\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\n\nvar inheritAttributes = function inheritAttributes(mpd, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$manifestUri = _options.manifestUri,\n      manifestUri = _options$manifestUri === void 0 ? '' : _options$manifestUri,\n      _options$NOW = _options.NOW,\n      NOW = _options$NOW === void 0 ? Date.now() : _options$NOW,\n      _options$clientOffset = _options.clientOffset,\n      clientOffset = _options$clientOffset === void 0 ? 0 : _options$clientOffset;\n  var periods = findChildren(mpd, 'Period');\n\n  if (!periods.length) {\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n\n  var mpdAttributes = parseAttributes(mpd);\n  var mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, 'BaseURL'));\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n  return flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)));\n};\n\nvar stringToMpdXml = function stringToMpdXml(manifestString) {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n\n  var parser = new window$1.DOMParser();\n  var xml = parser.parseFromString(manifestString, 'application/xml');\n  var mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n\n  return mpd;\n};\n\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\nvar parseUTCTimingScheme = function parseUTCTimingScheme(mpd) {\n  var UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n\n  if (!UTCTimingNode) {\n    return null;\n  }\n\n  var attributes = parseAttributes(UTCTimingNode);\n\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n\n  return attributes;\n};\n\nvar VERSION = version;\nvar parse = function parse(manifestString, options) {\n  return toM3u8(toPlaylists(inheritAttributes(stringToMpdXml(manifestString), options)));\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\nvar parseUTCTiming = function parseUTCTiming(manifestString) {\n  return parseUTCTimingScheme(stringToMpdXml(manifestString));\n};\n\nexport { VERSION, parse, parseUTCTiming };\n","/*! @name m3u8-parser @version 4.3.0 @license Apache-2.0 */\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\n/**\n * @file stream.js\n */\n\n/**\n * A lightweight readable stream implementation that handles event dispatching.\n *\n * @class Stream\n */\nvar Stream =\n/*#__PURE__*/\nfunction () {\n  function Stream() {\n    this.listeners = {};\n  }\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  var _proto = Stream.prototype;\n\n  _proto.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  };\n  /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {boolean} if we could turn it off or not\n   */\n\n\n  _proto.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener);\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  };\n  /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {string} type the event name\n   */\n\n\n  _proto.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n    var i;\n    var length;\n    var args;\n\n    if (!callbacks) {\n      return;\n    } // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n\n\n    if (arguments.length === 2) {\n      length = callbacks.length;\n\n      for (i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      args = Array.prototype.slice.call(arguments, 1);\n      length = callbacks.length;\n\n      for (i = 0; i < length; ++i) {\n        callbacks[i].apply(this, args);\n      }\n    }\n  };\n  /**\n   * Destroys the stream and cleans up.\n   */\n\n\n  _proto.dispose = function dispose() {\n    this.listeners = {};\n  };\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n\n\n  _proto.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nvar LineStream =\n/*#__PURE__*/\nfunction (_Stream) {\n  _inheritsLoose(LineStream, _Stream);\n\n  function LineStream() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.buffer = '';\n    return _this;\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n\n  var _proto = LineStream.prototype;\n\n  _proto.push = function push(data) {\n    var nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  };\n\n  return LineStream;\n}(Stream);\n\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\nvar attributeSeparator = function attributeSeparator() {\n  var key = '[^=]*';\n  var value = '\"[^\"]*\"|[^,]*';\n  var keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\n\nvar parseAttributes = function parseAttributes(attributes) {\n  // split the string using attributes as the separator\n  var attrs = attributes.split(attributeSeparator());\n  var result = {};\n  var i = attrs.length;\n  var attr;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\n\nvar ParseStream =\n/*#__PURE__*/\nfunction (_Stream) {\n  _inheritsLoose(ParseStream, _Stream);\n\n  function ParseStream() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.customParsers = [];\n    _this.tagMappers = [];\n    return _this;\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n\n  var _proto = ParseStream.prototype;\n\n  _proto.push = function push(line) {\n    var _this2 = this;\n\n    var match;\n    var event; // strip whitespace\n\n    line = line.trim();\n\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n\n    var newLines = this.tagMappers.reduce(function (acc, mapper) {\n      var mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(function (newLine) {\n      for (var i = 0; i < _this2.customParsers.length; i++) {\n        if (_this2.customParsers[i].call(_this2, newLine)) {\n          return;\n        }\n      } // Comments\n\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        _this2.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n\n        return;\n      }\n\n      match = /^#EXTINF:?([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n\n        if (match[2]) {\n          event.title = match[2];\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#ZEN-TOTAL-DURATION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'totalduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-BYTERANGE:?([0-9.]*)?@?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'byterange'\n        };\n\n        if (match[1]) {\n          event.length = parseInt(match[1], 10);\n        }\n\n        if (match[2]) {\n          event.offset = parseInt(match[2], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          var attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n\n          if (attributes.BYTERANGE) {\n            var _attributes$BYTERANGE = attributes.BYTERANGE.split('@'),\n                length = _attributes$BYTERANGE[0],\n                offset = _attributes$BYTERANGE[1];\n\n            event.byterange = {};\n\n            if (length) {\n              event.byterange.length = parseInt(length, 10);\n            }\n\n            if (offset) {\n              event.byterange.offset = parseInt(offset, 10);\n            }\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            var split = event.attributes.RESOLUTION.split('x');\n            var resolution = {};\n\n            if (split[0]) {\n              resolution.width = parseInt(split[0], 10);\n            }\n\n            if (split[1]) {\n              resolution.height = parseInt(split[1], 10);\n            }\n\n            event.attributes.RESOLUTION = resolution;\n          }\n\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n\n        return;\n      }\n\n      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-START:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      } // unknown tag type\n\n\n      _this2.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  };\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  _proto.addParser = function addParser(_ref) {\n    var _this3 = this;\n\n    var expression = _ref.expression,\n        customType = _ref.customType,\n        dataParser = _ref.dataParser,\n        segment = _ref.segment;\n\n    if (typeof dataParser !== 'function') {\n      dataParser = function dataParser(line) {\n        return line;\n      };\n    }\n\n    this.customParsers.push(function (line) {\n      var match = expression.exec(line);\n\n      if (match) {\n        _this3.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType: customType,\n          segment: segment\n        });\n\n        return true;\n      }\n    });\n  };\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  _proto.addTagMapper = function addTagMapper(_ref2) {\n    var expression = _ref2.expression,\n        map = _ref2.map;\n\n    var mapFn = function mapFn(line) {\n      if (expression.test(line)) {\n        return map(line);\n      }\n\n      return line;\n    };\n\n    this.tagMappers.push(mapFn);\n  };\n\n  return ParseStream;\n}(Stream);\n\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @extends Stream\n */\n\nvar Parser =\n/*#__PURE__*/\nfunction (_Stream) {\n  _inheritsLoose(Parser, _Stream);\n\n  function Parser() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.lineStream = new LineStream();\n    _this.parseStream = new ParseStream();\n\n    _this.lineStream.pipe(_this.parseStream);\n    /* eslint-disable consistent-this */\n\n\n    var self = _assertThisInitialized(_assertThisInitialized(_this));\n    /* eslint-enable consistent-this */\n\n\n    var uris = [];\n    var currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    var currentMap; // if specified, the active decryption key\n\n    var _key;\n\n    var noop = function noop() {};\n\n    var defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // group segments into numbered timelines delineated by discontinuities\n\n    var currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    _this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      segments: []\n    }; // update the manifest with the m3u8 entry from the parse stream\n\n    _this.parseStream.on('data', function (entry) {\n      var mediaGroup;\n      var rendition;\n      ({\n        tag: function tag() {\n          // switch based on the tag type\n          (({\n            'allow-cache': function allowCache() {\n              this.manifest.allowCache = entry.allowed;\n\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n            byterange: function byterange() {\n              var byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  this.trigger('info', {\n                    message: 'defaulting offset to zero'\n                  });\n                  entry.offset = 0;\n                }\n              }\n\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n            },\n            endlist: function endlist() {\n              this.manifest.endList = true;\n            },\n            inf: function inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n            key: function key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n\n              if (entry.attributes.METHOD === 'NONE') {\n                _key = null;\n                return;\n              }\n\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              }\n\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n\n              _key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                _key.iv = entry.attributes.IV;\n              }\n            },\n            'media-sequence': function mediaSequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.mediaSequence = entry.number;\n            },\n            'discontinuity-sequence': function discontinuitySequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n            'playlist-type': function playlistType() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n\n              this.manifest.playlistType = entry.playlistType;\n            },\n            map: function map() {\n              currentMap = {};\n\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n            },\n            'stream-inf': function streamInf() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n\n              _extends(currentUri.attributes, entry.attributes);\n            },\n            media: function media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n\n              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n            discontinuity: function discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n            'program-date-time': function programDateTime() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n            },\n            targetduration: function targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.targetDuration = entry.duration;\n            },\n            totalduration: function totalduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid total duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.totalDuration = entry.duration;\n            },\n            start: function start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n            'cue-out': function cueOut() {\n              currentUri.cueOut = entry.data;\n            },\n            'cue-out-cont': function cueOutCont() {\n              currentUri.cueOutCont = entry.data;\n            },\n            'cue-in': function cueIn() {\n              currentUri.cueIn = entry.data;\n            }\n          })[entry.tagType] || noop).call(self);\n        },\n        uri: function uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n\n          if (_key) {\n            currentUri.key = _key;\n          }\n\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // prepare for the next URI\n\n\n          currentUri = {};\n        },\n        comment: function comment() {// comments are not important for playback\n        },\n        custom: function custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n      })[entry.type].call(self);\n    });\n\n    return _this;\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.push = function push(chunk) {\n    this.lineStream.push(chunk);\n  };\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n\n\n  _proto.end = function end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n  };\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.type         the type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  _proto.addParser = function addParser(options) {\n    this.parseStream.addParser(options);\n  };\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  _proto.addTagMapper = function addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  };\n\n  return Parser;\n}(Stream);\n\n/**\n * @file m3u8/index.js\n *\n * Utilities for parsing M3U8 files. If the entire manifest is available,\n * `Parser` will create an object representation with enough detail for managing\n * playback. `ParseStream` and `LineStream` are lower-level parsing primitives\n * that do not assume the entirety of the manifest is ready and expose a\n * ReadableStream-like interface.\n */\n\nexport { LineStream, ParseStream, Parser };\n"],"sourceRoot":""}