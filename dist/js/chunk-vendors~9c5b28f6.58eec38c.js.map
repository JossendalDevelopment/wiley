{"version":3,"sources":["webpack:///./node_modules/mux.js/lib/m2ts/m2ts.js","webpack:///./node_modules/mux.js/lib/mp4/audio-frame-utils.js","webpack:///./node_modules/mux.js/lib/mp4/mp4-generator.js","webpack:///./node_modules/mux.js/lib/m2ts/timestamp-rollover-stream.js","webpack:///./node_modules/mux.js/lib/mp4/probe.js","webpack:///./node_modules/mux.js/lib/mp4/index.js","webpack:///./node_modules/mux.js/lib/mp4/frame-utils.js","webpack:///./node_modules/mux.js/lib/mp4/transmuxer.js","webpack:///./node_modules/mux.js/lib/utils/exp-golomb.js","webpack:///./node_modules/mux.js/lib/utils/clock.js","webpack:///./node_modules/mux.js/lib/m2ts/probe.js","webpack:///./node_modules/mux.js/lib/utils/stream.js","webpack:///./node_modules/mux.js/lib/m2ts/caption-stream.js","webpack:///./node_modules/parseqs/index.js","webpack:///./node_modules/mux.js/lib/codecs/adts.js","webpack:///./node_modules/parseuri/index.js","webpack:///./node_modules/mux.js/lib/m2ts/metadata-stream.js","webpack:///./node_modules/mux.js/lib/codecs/h264.js","webpack:///./node_modules/parse-headers/parse-headers.js","webpack:///./node_modules/mux.js/lib/data/silence.js","webpack:///./node_modules/mux.js/lib/utils/bin.js","webpack:///./node_modules/mux.js/lib/tools/mp4-inspector.js","webpack:///./node_modules/mux.js/lib/aac/index.js","webpack:///./node_modules/mux.js/lib/mp4/caption-parser.js","webpack:///./node_modules/mux.js/lib/m2ts/stream-types.js","webpack:///./node_modules/object-keys/implementation.js","webpack:///./node_modules/object-keys/isArguments.js","webpack:///./node_modules/object-keys/index.js","webpack:///./node_modules/mux.js/lib/tools/ts-inspector.js","webpack:///./node_modules/mux.js/lib/tools/caption-packet-parser.js","webpack:///./node_modules/mux.js/lib/mp4/track-decode-info.js","webpack:///./node_modules/mux.js/lib/aac/utils.js"],"names":["TransportPacketStream","TransportParseStream","ElementaryStream","Stream","__webpack_require__","CaptionStream","StreamTypes","TimestampRolloverStream","m2tsStreamTypes","MP2T_PACKET_LENGTH","SYNC_BYTE","buffer","Uint8Array","bytesInBuffer","prototype","init","call","this","push","bytes","everything","startIndex","endIndex","byteLength","set","subarray","trigger","flush","parsePsi","parsePat","parsePmt","self","packetsWaitingForPmt","programMapTable","undefined","payload","psi","offset","payloadUnitStartIndicator","type","pat","section_number","last_section_number","pmtPid","pmt","sectionLength","tableEnd","programInfoLength","video","audio","timed-metadata","streamType","pid","H264_STREAM_TYPE","ADTS_STREAM_TYPE","METADATA_STREAM_TYPE","packet","result","length","processPes_","apply","shift","data","STREAM_TYPES","h264","adts","size","timedMetadata","parsePes","pes","ptsDtsFlags","packetLength","dataAlignmentIndicator","pts","dts","flushStream","stream","forceFlush","fragment","packetData","event","i","packetFlushable","trackId","tracks","timelineStartInfo","baseMediaDecodeTime","id","codec","m2ts","PAT_PID","Cea608Stream","MetadataStream","hasOwnProperty","module","exports","coneOfSilence","clock","ONE_SECOND_IN_TS","sumFrameByteLengths","array","currentObj","sum","prefixWithSilence","track","frames","audioAppendStartTs","videoBaseMediaDecodeTime","baseMediaDecodeTimeTs","silentFrame","frameDuration","audioGapDuration","audioFillFrameCount","audioFillDuration","audioTsToVideoTs","samplerate","Math","ceil","max","floor","splice","videoTsToAudioTs","trimAdtsFramesByEarliestDts","adtsFrames","earliestAllowedDts","minSegmentDts","Infinity","filter","currentFrame","min","minSegmentPts","generateSampleTable","samples","duration","concatenateFrameData","dataOffset","box","dinf","esds","ftyp","mdat","mfhd","minf","moof","moov","mvex","mvhd","trak","tkhd","mdia","mdhd","hdlr","sdtp","stbl","stsd","traf","trex","trun","types","MAJOR_BRAND","MINOR_VERSION","AVC1_BRAND","VIDEO_HDLR","AUDIO_HDLR","HDLR_TYPES","VMHD","SMHD","DREF","STCO","STSC","STSZ","STTS","UINT32_MAX","pow","avc1","avcC","btrt","dref","mp4a","smhd","stco","stsc","stsz","stts","styp","tfdt","tfhd","vmhd","charCodeAt","view","arguments","DataView","byteOffset","setUint32","audioobjecttype","samplingfrequencyindex","channelcount","sequenceNumber","trackFragments","concat","boxes","flags","dependsOn","isDependedOn","videoSample","audioSample","sps","pps","sequenceParameterSets","pictureParameterSets","Array","slice","width","height","profileIdc","profileCompatibility","levelIdc","samplesize","trackFragmentHeader","trackFragmentDecodeTime","trackFragmentRun","sampleDependencyTable","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","audioTrun","videoTrun","trunHeader","durationPresent","sizePresent","flagsPresent","compositionTimeOffset","sample","isLeading","hasRedundancy","paddingValue","isNonSyncSample","degradationPriority","initSegment","fileType","movie","MAX_TS","RO_THRESH","handleRollover","value","reference","direction","abs","lastDTS","referenceDTS","type_","discontinuity","findBox","parseType","timescale","startTime","getVideoTrackIds","toUnsigned","path","end","subresults","results","String","fromCharCode","traks","reduce","version","index","trafs","baseTimes","map","scale","baseTime","isFinite","videoTrackIds","forEach","hdlrs","tkhds","handlerType","getUint8","getUint32","generator","probe","Transmuxer","AudioSegmentStream","VideoSegmentStream","CaptionParser","groupNalsIntoFrames","nalUnits","currentNal","nalUnitType","keyFrame","groupFramesIntoGops","currentGop","gops","nalCount","extendFirstKeyFrame","createDefaultSample","sampleForFrame","frame","baseDataOffset","h","concatenateNalData","j","nalsByteLength","numberOfNals","totalByteLength","CoalesceStream","mp4","frameUtils","audioFrameUtils","trackDecodeInfo","AdtsStream","H264Stream","AacStream","isLikelyAacData","AUDIO_PROPERTIES","VIDEO_PROPERTIES","arrayEquals","a","b","generateVideoSegmentTimingInfo","startDts","startPts","endDts","endPts","prependedContentDuration","ptsOffsetFromDts","decodeDuration","presentationDuration","start","options","collectDtsInfo","prop","setEarliestDts","earliestDts","setVideoBaseMediaDecodeTime","setAudioAppendStart","timestamp","calculateTrackBaseMediaDecodeTime","keepOriginalTimestamps","clearDtsInfo","config","gopsToAlignWith","minPTS","gopCache_","nalUnit","gopForFusion","firstGop","lastGop","resetStream_","getGopForFusion_","unshift","alignedGops","alignGopsAtEnd","alignGopsAtEnd_","alignGopsAtStart_","gop","pop","dtsDistance","nearestGopObj","currentGopObj","halfSecond","allowableOverlap","nearestDistance","alignIndex","gopIndex","align","alignEndIndex","matchFound","trimIndex","metadata","total","alignGopsWith","newGopsToAlignWith","metadataStream","numberOfTracks","remux","remuxTracks","pendingTracks","videoTrack","pendingBoxes","pendingCaptions","pendingMetadata","pendingBytes","emittedTracks","output","text","audioTrack","flushSource","caption","id3","captions","captionStreams","info","timelineStartPts","endTime","cueTime","dispatchType","hasFlushed","transmuxPipeline_","setupAacPipeline","pipeline","aacStream","audioTimestampRolloverStream","timedMetadataTimestampRolloverStream","adtsStream","coalesceStream","headOfPipeline","pipe","on","setTimestamp","timeStamp","audioSegmentStream","bind","setupTsPipeline","packetStream","parseStream","elementaryStream","videoTimestampRolloverStream","h264Stream","captionStream","videoSegmentStream","setBaseMediaDecodeTime","reset","isAac","resetCaptions","ExpGolomb","workingData","workingBytesAvailable","workingWord","workingBitsAvailable","bitsAvailable","loadWord","position","workingBytes","availableBytes","Error","skipBits","count","skipBytes","readBits","bits","valu","skipLeadingZeros","leadingZeroCount","skipUnsignedExpGolomb","skipExpGolomb","readUnsignedExpGolomb","clz","readExpGolomb","readBoolean","readUnsignedByte","secondsToVideoTs","secondsToAudioTs","videoTsToSeconds","audioTsToSeconds","seconds","sampleRate","parsePid","parsePayloadUnitStartIndicator","parseAdaptionField","pusi","payloadOffset","parsePesType","parsePesTime","parseNalUnitType","videoPacketContainsKeyFrame","nalType","frameBuffer","frameI","frameSyncPoint","foundKeyFrame","listeners","listener","off","indexOf","callbacks","args","dispose","destination","cea708Parser","captionPackets_","ccStreams_","cc","sei","userData","newCaptionPackets","parseSei","escapedRBSP","payloadType","USER_DATA_REGISTERED_ITU_T_T35","parseUserData","latestDts_","ignoreNextEqualDts_","numSameDts_","parseCaptionPackets","elem","idx","presortIndex","sort","dispatchCea608Packet","activeCea608Channel_","ccStream","setsChannel1Active","setsChannel2Active","ccData","CHARACTER_TRANSLATION","42","92","94","95","96","123","124","125","126","127","304","305","306","307","308","309","310","311","312","313","314","315","316","317","318","319","544","545","546","547","548","549","550","551","552","553","554","555","556","557","558","559","560","561","562","563","564","565","566","567","568","569","570","571","572","573","574","575","800","801","802","803","804","805","806","807","808","809","810","811","812","813","814","815","816","817","818","819","820","821","822","823","824","825","826","827","828","829","830","831","getCharFromCode","code","BOTTOM_ROW","ROWS","createDisplayBuffer","field","dataChannel","field_","dataChannel_","name_","setConstants","swap","char0","char1","lastControlCode_","PADDING_","RESUME_CAPTION_LOADING_","mode_","END_OF_CAPTION_","clearFormatting","flushDisplayed","displayed_","nonDisplayed_","startPts_","ROLL_UP_2_ROWS_","rollUpRows_","setRollUp","ROLL_UP_3_ROWS_","ROLL_UP_4_ROWS_","CARRIAGE_RETURN_","shiftRowsUp_","BACKSPACE_","row_","ERASE_DISPLAYED_MEMORY_","ERASE_NON_DISPLAYED_MEMORY_","RESUME_DIRECT_CAPTIONING_","isSpecialCharacter","column_","isExtCharacter","isMidRowCode","addFormatting","isOffsetControlCode","isPAC","row","formatting_","isColorPAC","isNormalChar","content","trim","e","console","error","join","replace","topRow_","BASE_","EXT_","CONTROL_","OFFSET_","char","newBaseRow","format","reverse","popOn","baseRow","rollUp","paintOn","encode","obj","str","encodeURIComponent","decode","qs","qry","pairs","split","l","pair","decodeURIComponent","ADTS_SAMPLING_FREQUENCIES","frameLength","protectionSkipBytes","frameEnd","oldBuffer","sampleCount","adtsFrameDuration","frameNum","re","parts","src","substring","m","exec","uri","source","host","authority","ipv6uri","percentEncode","toString","parseUtf8","parseIso88591","unescape","parseSyncSafeInteger","tagParsers","TXXX","tag","description","WXXX","url","PRIV","owner","privateData","settings","debug","descriptor","tagSize","bufferSize","chunk","frameStart","frameSize","frameHeader","log","key","d","NalByteStream","PROFILES_WITH_OPTIONAL_SPS_DATA","syncPoint","swapBuffer","100","110","122","244","44","83","86","118","128","138","139","134","currentPts","currentDts","discardEmulationPreventionBytes","readSequenceParameterSet","skipScalingList","nalByteStream","expGolombDecoder","deltaScale","lastScale","nextScale","newLength","newData","emulationPreventionBytesPositions","sourceIndex","chromaFormatIdc","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","scalingListCount","sarRatio","aspectRatioIdc","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","sarScale","isArray","arg","Object","headers","toLowerCase","highPrefix","lowPrefix","zeroFill","makeTable","metaTable","keys","arr","part","96000","88200","64000","48000","44100","32000","24000","16000","12000","11025","8000","inspectMp4","textifyMp4","parseMp4Date","Date","parseSampleFlags","nalParse","avcStream","avcView","parse","dataReferenceIndex","getUint16","horizresolution","vertresolution","frameCount","depth","numOfPictureParameterSets","nalSize","configurationVersion","avcProfileIndication","avcLevelIndication","lengthSizeMinusOne","numOfSequenceParameterSets","bufferSizeDB","maxBitrate","avgBitrate","esId","streamPriority","decoderConfig","objectProfileIndication","decoderConfigDescriptor","audioObjectType","samplingFrequencyIndex","channelConfiguration","majorBrand","minorVersion","compatibleBrands","dataReferences","name","escape","nals","language","creationTime","modificationTime","streamDescriptor","rate","volume","matrix","Uint32Array","nextTrackId","pdin","initialDelay","sidx","references","referenceId","earliestPresentationTime","firstOffset","referenceCount","referenceType","referencedSize","subsegmentDuration","startsWithSap","sapType","sapDeltaTime","balance","chunkOffsets","entryCount","sampleToChunks","firstChunk","samplesPerChunk","sampleDescriptionIndex","sampleDescriptions","sampleSize","entries","timeToSamples","sampleDelta","baseDataOffsetPresent","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","durationIsEmpty","defaultBaseIsMoof","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","baseDataOffsetIsMoof","layer","alternateGroup","defaultSampleDescriptionIndex","sampleDependsOn","sampleIsDependedOn","sampleHasRedundancy","samplePaddingValue","sampleIsDifferenceSample","sampleDegradationPriority","dataOffsetPresent","firstSampleFlagsPresent","sampleDurationPresent","sampleSizePresent","sampleFlagsPresent","sampleCompositionTimeOffsetPresent","getInt32","url ","graphicsmode","opcolor","Uint16Array","ab","ArrayBuffer","v","z","inspectedMp4","indent","prefix","byte","match","line","JSON","stringify","inspect","textify","parseTfdt","parseHdlr","parseTfhd","parseTrun","parseSidx","aacUtils","bytesLeft","tempLength","byteIndex","parseAdtsSize","parseId3TagSize","mapToSample","approximateOffset","findSeiNals","seiNal","lastMatchedSample","matchingSample","parseSamples","truns","allSamples","trackRun","parseCaptionNals","segment","videoTrackId","mdats","captionNals","mdatTrafPairs","matchingTraf","seiNals","headerInfo","parseEmbeddedCaptions","segmentCache","parsedCaptions","isInitialized","isNewInit","timescales","parsedData","cachedSegment","pushNals","nal","clearParsedCaptions","resetCaptionStream","clearAllCaptions","keysShim","has","toStr","isArgs","isEnumerable","propertyIsEnumerable","hasDontEnumBug","hasProtoEnumBug","dontEnums","equalsConstructorPrototype","o","ctor","constructor","excludedKeys","$applicationCache","$console","$external","$frame","$frameElement","$frames","$innerHeight","$innerWidth","$onmozfullscreenchange","$onmozfullscreenerror","$outerHeight","$outerWidth","$pageXOffset","$pageYOffset","$parent","$scrollLeft","$scrollTop","$scrollX","$scrollY","$self","$webkitIndexedDB","$webkitStorageInfo","$window","hasAutomationEqualityBug","window","k","equalsConstructorPrototypeIfNotBuggy","object","isObject","isFunction","isArguments","isString","theKeys","TypeError","skipProto","skipConstructor","callee","origKeys","originalKeys","shim","keysWorksWithArguments","ts","aac","PES_TIMESCALE","parsePsi_","table","parseAudioPes_","pesType","parsed","endLoop","parseVideoPes_","firstKeyFrame","adjustTimestamp_","segmentInfo","baseTimestamp","audioBaseTimestamp","dtsTime","ptsTime","videoBaseTimestamp","inspectAac_","audioCount","parseAacTimestamp","parseSampleRate","audioTimescale","inspectTs_","isAacData","RBSP_TRAILING_BITS","payloadSize","maxSegmentPts","maxSegmentDts","header","returnSize","footerPresent","lowThree","middle","highTwo"],"mappings":"0HAWA,IAQAA,EAAAC,EAAAC,EARAC,EAAaC,EAAQ,QACrBC,EAAkBD,EAAQ,QAC1BE,EAAgBF,EAAQ,QACxBG,EAA4BH,EAAQ,QAA6BG,wBAEjEC,EAAsBJ,EAAQ,QAO9BK,EAAA,IACAC,EAAA,GAMAV,EAAA,WACA,IACAW,EAAA,IAAAC,WAAAH,GACAI,EAAA,EAEAb,EAAAc,UAAAC,KAAAC,KAAAC,MAOAA,KAAAC,KAAA,SAAAC,GACA,IAGAC,EAFAC,EAAA,EACAC,EAAAb,EAKAI,GACAO,EAAA,IAAAR,WAAAO,EAAAI,WAAAV,GACAO,EAAAI,IAAAb,EAAAc,SAAA,EAAAZ,IACAO,EAAAI,IAAAL,EAAAN,GACAA,EAAA,GAEAO,EAAAD,EAIA,MAAAG,EAAAF,EAAAG,WAEAH,EAAAC,KAAAX,GAAAU,EAAAE,KAAAZ,GAWAW,IACAC,MATAL,KAAAS,QAAA,OAAAN,EAAAK,SAAAJ,EAAAC,IACAD,GAAAZ,EACAa,GAAAb,GAaAY,EAAAD,EAAAG,aACAZ,EAAAa,IAAAJ,EAAAK,SAAAJ,GAAA,GACAR,EAAAO,EAAAG,WAAAF,IAOAJ,KAAAU,MAAA,WAIAd,IAAAJ,GAAAE,EAAA,KAAAD,IACAO,KAAAS,QAAA,OAAAf,GACAE,EAAA,GAEAI,KAAAS,QAAA,UAGA1B,EAAAc,UAAA,IAAAX,EAMAF,EAAA,WACA,IAAA2B,EAAAC,EAAAC,EAAAC,EACA9B,EAAAa,UAAAC,KAAAC,KAAAC,MACAc,EAAAd,KAEAA,KAAAe,qBAAA,GACAf,KAAAgB,qBAAAC,EAEAN,EAAA,SAAAO,EAAAC,GACA,IAAAC,EAAA,EAQAD,EAAAE,4BACAD,GAAAF,EAAAE,GAAA,GAGA,QAAAD,EAAAG,KACAV,EAAAM,EAAAV,SAAAY,GAAAD,GAEAN,EAAAK,EAAAV,SAAAY,GAAAD,IAIAP,EAAA,SAAAM,EAAAK,GACAA,EAAAC,eAAAN,EAAA,GACAK,EAAAE,oBAAAP,EAAA,GAGAJ,EAAAY,QAAA,GAAAR,EAAA,QAAAA,EAAA,IACAK,EAAAG,OAAAZ,EAAAY,QAWAb,EAAA,SAAAK,EAAAS,GACA,IAAAC,EAAAC,EAAAC,EAAAV,EAOA,KAAAF,EAAA,IAKAJ,EAAAE,gBAAA,CACAe,MAAA,KACAC,MAAA,KACAC,iBAAA,IAIAL,GAAA,GAAAV,EAAA,OAAAA,EAAA,GACAW,EAAA,EAAAD,EAAA,EAIAE,GAAA,GAAAZ,EAAA,QAAAA,EAAA,IAGAE,EAAA,GAAAU,EACA,MAAAV,EAAAS,EAAA,CACA,IAAAK,EAAAhB,EAAAE,GACAe,GAAA,GAAAjB,EAAAE,EAAA,OAAAF,EAAAE,EAAA,GAKAc,IAAA7C,EAAA+C,kBACA,OAAAtB,EAAAE,gBAAAe,MACAjB,EAAAE,gBAAAe,MAAAI,EACOD,IAAA7C,EAAAgD,kBACP,OAAAvB,EAAAE,gBAAAgB,MACAlB,EAAAE,gBAAAgB,MAAAG,EACOD,IAAA7C,EAAAiD,uBAEPxB,EAAAE,gBAAA,kBAAAmB,GAAAD,GAKAd,GAAA,OAAAF,EAAAE,EAAA,OAAAF,EAAAE,EAAA,IAIAO,EAAAX,gBAAAF,EAAAE,kBAMAhB,KAAAC,KAAA,SAAAsC,GACA,IACAC,EAAA,GACApB,EAAA,EAmBA,GAjBAoB,EAAAnB,6BAAA,GAAAkB,EAAA,IAGAC,EAAAL,IAAA,GAAAI,EAAA,GACAC,EAAAL,MAAA,EACAK,EAAAL,KAAAI,EAAA,IAOA,GAAAA,EAAA,YACAnB,GAAAmB,EAAAnB,GAAA,GAIA,IAAAoB,EAAAL,IACAK,EAAAlB,KAAA,MACAX,EAAA4B,EAAA/B,SAAAY,GAAAoB,GACAxC,KAAAS,QAAA,OAAA+B,QACK,GAAAA,EAAAL,MAAAnC,KAAA0B,OAAA,CACLc,EAAAlB,KAAA,MACAX,EAAA4B,EAAA/B,SAAAY,GAAAoB,GACAxC,KAAAS,QAAA,OAAA+B,GAGA,MAAAxC,KAAAe,qBAAA0B,OACAzC,KAAA0C,YAAAC,MAAA3C,UAAAe,qBAAA6B,mBAEK3B,IAAAjB,KAAAgB,gBAGLhB,KAAAe,qBAAAd,KAAA,CAAAsC,EAAAnB,EAAAoB,IAEAxC,KAAA0C,YAAAH,EAAAnB,EAAAoB,IAIAxC,KAAA0C,YAAA,SAAAH,EAAAnB,EAAAoB,GAEAA,EAAAL,MAAAnC,KAAAgB,gBAAAe,MACAS,EAAAN,WAAA7C,EAAA+C,iBACKI,EAAAL,MAAAnC,KAAAgB,gBAAAgB,MACLQ,EAAAN,WAAA7C,EAAAgD,iBAIAG,EAAAN,WAAAlC,KAAAgB,gBAAA,kBAAAwB,EAAAL,KAGAK,EAAAlB,KAAA,MACAkB,EAAAK,KAAAN,EAAA/B,SAAAY,GAEApB,KAAAS,QAAA,OAAA+B,KAIAxD,EAAAa,UAAA,IAAAX,EACAF,EAAA8D,aAAA,CACAC,KAAA,GACAC,KAAA,IAWA/D,EAAA,WACA,IACA6B,EAAAd,KAEA+B,EAAA,CACAc,KAAA,GACAI,KAAA,GAEAjB,EAAA,CACAa,KAAA,GACAI,KAAA,GAEAC,EAAA,CACAL,KAAA,GACAI,KAAA,GAEAE,EAAA,SAAAjC,EAAAkC,GACA,IAAAC,EAGAD,EAAAE,aAAA,GAAApC,EAAA,MAAAA,EAAA,IAGAkC,EAAAG,uBAAA,OAAArC,EAAA,IAIAmC,EAAAnC,EAAA,GAUA,IAAAmC,IAIAD,EAAAI,KAAA,GAAAtC,EAAA,SACA,IAAAA,EAAA,UACA,IAAAA,EAAA,UACA,IAAAA,EAAA,SACA,IAAAA,EAAA,SACAkC,EAAAI,KAAA,EACAJ,EAAAI,MAAA,EAAAtC,EAAA,SACAkC,EAAAK,IAAAL,EAAAI,IACA,GAAAH,IACAD,EAAAK,KAAA,GAAAvC,EAAA,UACA,IAAAA,EAAA,UACA,IAAAA,EAAA,UACA,IAAAA,EAAA,SACA,IAAAA,EAAA,SACAkC,EAAAK,KAAA,EACAL,EAAAK,MAAA,EAAAvC,EAAA,WAMAkC,EAAAP,KAAA3B,EAAAV,SAAA,EAAAU,EAAA,KAKAwC,EAAA,SAAAC,EAAArC,EAAAsC,GACA,IAQAC,EAPAC,EAAA,IAAAnE,WAAAgE,EAAAV,MACAc,EAAA,CACAzC,QAEA0C,EAAA,EACA5C,EAAA,EACA6C,GAAA,EAKA,GAAAN,EAAAd,KAAAJ,UAAAkB,EAAAV,KAAA,IAMA,IAHAc,EAAAG,QAAAP,EAAAd,KAAA,GAAAV,IAGA6B,EAAA,EAAiBA,EAAAL,EAAAd,KAAAJ,OAAwBuB,IACzCH,EAAAF,EAAAd,KAAAmB,GAEAF,EAAAvD,IAAAsD,EAAAhB,KAAAzB,GACAA,GAAAyC,EAAAhB,KAAAvC,WAIA6C,EAAAW,EAAAC,GAIAE,EAAA,UAAA3C,GAAAyC,EAAAT,cAAAK,EAAAV,MAGAW,GAAAK,KACAN,EAAAV,KAAA,EACAU,EAAAd,KAAAJ,OAAA,GAKAwB,GACAnD,EAAAL,QAAA,OAAAsD,KAIA9E,EAAAY,UAAAC,KAAAC,KAAAC,MAMAA,KAAAC,KAAA,SAAA4C,IACA,CACAtB,IAAA,aAIA6B,IAAA,WACA,IAAAO,EAAAzB,EAEA,OAAAW,EAAAX,YACA,KAAA7C,EAAA+C,iBACA,KAAA7C,EAAA6C,iBACAuB,EAAA5B,EACAG,EAAA,QACA,MACA,KAAA7C,EAAAgD,iBACAsB,EAAA3B,EACAE,EAAA,QACA,MACA,KAAA7C,EAAAiD,qBACAqB,EAAAT,EACAhB,EAAA,iBACA,MACA,QAEA,OAKAW,EAAAxB,2BACAqC,EAAAC,EAAAzB,GAAA,GAKAyB,EAAAd,KAAA5C,KAAA4C,GACAc,EAAAV,MAAAJ,OAAAvC,YAEAqB,IAAA,WACA,IACAoC,EAAA,CACAzC,KAAA,WACA6C,OAAA,IAEAnD,EAAA6B,EAAA7B,gBAGA,OAAAA,EAAAe,OACAgC,EAAAI,OAAAlE,KAAA,CACAmE,kBAAA,CACAC,oBAAA,GAEAC,IAAAtD,EAAAe,MACAwC,MAAA,MACAjD,KAAA,UAGA,OAAAN,EAAAgB,OACA+B,EAAAI,OAAAlE,KAAA,CACAmE,kBAAA,CACAC,oBAAA,GAEAC,IAAAtD,EAAAgB,MACAuC,MAAA,OACAjD,KAAA,UAIAR,EAAAL,QAAA,OAAAsD,MAEKlB,EAAAvB,SAYLtB,KAAAU,MAAA,WAGAgD,EAAA3B,EAAA,SACA2B,EAAA1B,EAAA,SACA0B,EAAAR,EAAA,kBACAlD,KAAAS,QAAA,UAGAxB,EAAAY,UAAA,IAAAX,EAEA,IAAAsF,EAAA,CACAC,QAAA,EACAjF,qBACAT,wBACAC,uBACAC,mBACAK,0BACAF,8BACAsF,aAAAtF,EAAAsF,aACAC,eAAkBxF,EAAQ,SAG1B,QAAAmC,KAAAjC,EACAA,EAAAuF,eAAAtD,KACAkD,EAAAlD,GAAAjC,EAAAiC,IAIAuD,EAAAC,QAAAN,0BCtgBA,IAAAO,EAAoB5F,EAAQ,QAC5B6F,EAAY7F,EAAQ,QAEpB8F,EAAA,IAKAC,EAAA,SAAAC,GACA,IACAnB,EACAoB,EACAC,EAAA,EAGA,IAAArB,EAAA,EAAaA,EAAAmB,EAAA1C,OAAkBuB,IAC/BoB,EAAAD,EAAAnB,GACAqB,GAAAD,EAAAvC,KAAAvC,WAGA,OAAA+E,GAKAC,EAAA,SACAC,EACAC,EACAC,EACAC,GAEA,IACAC,EAKAC,EACA5B,EALA6B,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EAIA,GAAAR,EAAA/C,SAIAkD,EACAX,EAAAiB,iBAAAV,EAAAlB,oBAAAkB,EAAAW,YAEAL,EAAAM,KAAAC,KAAAnB,GAAAM,EAAAW,WAAA,OAEAT,GAAAC,IAEAI,EACAH,EAAAQ,KAAAE,IAAAZ,EAAAC,GAEAK,EAAAI,KAAAG,MAAAR,EAAAD,GACAG,EAAAD,EAAAF,KAKAE,EAAA,GAAAC,EAAAf,EAAA,KAYA,IARAW,EAAAb,EAAAQ,EAAAW,YAEAN,IAGAA,EAAAJ,EAAA,GAAA3C,MAGAmB,EAAA,EAAaA,EAAA+B,EAAyB/B,IACtCwB,EAAAe,OAAAvC,EAAA,GACAnB,KAAA+C,IAIAL,EAAAlB,qBACA8B,KAAAG,MAAAtB,EAAAwB,iBAAAR,EAAAT,EAAAW,eAOAO,EAAA,SAAAC,EAAAnB,EAAAoB,GACA,OAAApB,EAAAqB,eAAAD,EACAD,GAIAnB,EAAAqB,cAAAC,IAEAH,EAAAI,OAAA,SAAAC,GAEA,OAAAA,EAAAtD,KAAAkD,IACApB,EAAAqB,cAAAT,KAAAa,IAAAzB,EAAAqB,cAAAG,EAAAtD,KACA8B,EAAA0B,cAAA1B,EAAAqB,eACA,OAQAM,EAAA,SAAA1B,GACA,IACAxB,EACA+C,EACAI,EAAA,GAEA,IAAAnD,EAAA,EAAaA,EAAAwB,EAAA/C,OAAmBuB,IAChC+C,EAAAvB,EAAAxB,GACAmD,EAAAlH,KAAA,CACAgD,KAAA8D,EAAAlE,KAAAvC,WACA8G,SAAA,OAGA,OAAAD,GAIAE,EAAA,SAAA7B,GACA,IACAxB,EACA+C,EACAO,EAAA,EACAzE,EAAA,IAAAlD,WAAAuF,EAAAM,IAEA,IAAAxB,EAAA,EAAaA,EAAAwB,EAAA/C,OAAmBuB,IAChC+C,EAAAvB,EAAAxB,GAEAnB,EAAAtC,IAAAwG,EAAAlE,KAAAyE,GACAA,GAAAP,EAAAlE,KAAAvC,WAEA,OAAAuC,GAGAgC,EAAAC,QAAA,CACAQ,oBACAmB,8BACAS,sBACAG,6DCrIA,IAEAE,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EACAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EACAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EACAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EALAC,EAAAxD,KAAAyD,IAAA,SAQA,WACA,IAAA5F,EAyCA,GAxCA6E,EAAA,CACAgB,KAAA,GACAC,KAAA,GACAC,KAAA,GACAvC,KAAA,GACAwC,KAAA,GACAvC,KAAA,GACAC,KAAA,GACAY,KAAA,GACAX,KAAA,GACAU,KAAA,GACAD,KAAA,GACAR,KAAA,GACAC,KAAA,GACAC,KAAA,GACAC,KAAA,GACAkC,KAAA,GACAjC,KAAA,GACAC,KAAA,GACAM,KAAA,GACA2B,KAAA,GACA1B,KAAA,GACA2B,KAAA,GACAC,KAAA,GACA3B,KAAA,GACA4B,KAAA,GACAC,KAAA,GACAC,KAAA,GACAC,KAAA,GACAC,KAAA,GACA/B,KAAA,GACAR,KAAA,GACAU,KAAA,GACAD,KAAA,GACAR,KAAA,GACAuC,KAAA,IAKA,qBAAA/K,WAAA,CAIA,IAAAqE,KAAA6E,EACAA,EAAAjE,eAAAZ,KACA6E,EAAA7E,GAAA,CACAA,EAAA2G,WAAA,GACA3G,EAAA2G,WAAA,GACA3G,EAAA2G,WAAA,GACA3G,EAAA2G,WAAA,KAKA7B,EAAA,IAAAnJ,WAAA,CACA,IAAAgL,WAAA,GACA,IAAAA,WAAA,GACA,IAAAA,WAAA,GACA,IAAAA,WAAA,KAEA3B,EAAA,IAAArJ,WAAA,CACA,IAAAgL,WAAA,GACA,IAAAA,WAAA,GACA,IAAAA,WAAA,GACA,IAAAA,WAAA,KAEA5B,EAAA,IAAApJ,WAAA,WACAsJ,EAAA,IAAAtJ,WAAA,CACA,EACA,MACA,QACA,gBACA,QACA,QACA,QACA,eACA,cACA,oBAEAuJ,EAAA,IAAAvJ,WAAA,CACA,EACA,MACA,QACA,gBACA,QACA,QACA,QACA,eACA,cACA,oBAEAwJ,EAAA,CACApH,MAAAkH,EACAjH,MAAAkH,GAEAI,EAAA,IAAA3J,WAAA,CACA,EACA,MACA,QACA,SACA,eACA,EACA,QAEA0J,EAAA,IAAA1J,WAAA,CACA,EACA,MACA,IACA,MAEA4J,EAAA,IAAA5J,WAAA,CACA,EACA,MACA,UAEA6J,EAAAD,EACAE,EAAA,IAAA9J,WAAA,CACA,EACA,MACA,QACA,UAEA+J,EAAAH,EACAH,EAAA,IAAAzJ,WAAA,CACA,EACA,MACA,IACA,IACA,IACA,QApIA,GAwIA4H,EAAA,SAAAjG,GACA,IAGA0C,EACAxB,EACAoI,EAJA1J,EAAA,GACA+B,EAAA,EAKA,IAAAe,EAAA,EAAaA,EAAA6G,UAAApI,OAAsBuB,IACnC9C,EAAAjB,KAAA4K,UAAA7G,IAGAA,EAAA9C,EAAAuB,OAGA,MAAAuB,IACAf,GAAA/B,EAAA8C,GAAA1D,WAQA,IANAkC,EAAA,IAAA7C,WAAAsD,EAAA,GACA2H,EAAA,IAAAE,SAAAtI,EAAA9C,OAAA8C,EAAAuI,WAAAvI,EAAAlC,YACAsK,EAAAI,UAAA,EAAAxI,EAAAlC,YACAkC,EAAAjC,IAAAe,EAAA,GAGA0C,EAAA,EAAAf,EAAA,EAAuBe,EAAA9C,EAAAuB,OAAoBuB,IAC3CxB,EAAAjC,IAAAW,EAAA8C,GAAAf,GACAA,GAAA/B,EAAA8C,GAAA1D,WAEA,OAAAkC,GAGAgF,EAAA,WACA,OAAAD,EAAAsB,EAAArB,KAAAD,EAAAsB,EAAAmB,KAAAV,KAGA7B,EAAA,SAAAlC,GACA,OAAAgC,EAAAsB,EAAApB,KAAA,IAAA9H,WAAA,CACA,EACA,MAGA,EACA,GACA,IACA,EAGA,EACA,GACA,GACA,GACA,MACA,YACA,YAGA,EACA,EAGA4F,EAAA0F,iBAAA,EAAA1F,EAAA2F,yBAAA,EACA3F,EAAA2F,wBAAA,EAAA3F,EAAA4F,cAAA,EACA,UAIAzD,EAAA,WACA,OAAAH,EAAAsB,EAAAnB,KAAAoB,EAAAC,EAAAD,EAAAE,IAGAV,EAAA,SAAAhH,GACA,OAAAiG,EAAAsB,EAAAP,KAAAa,EAAA7H,KAEAqG,EAAA,SAAA9E,GACA,OAAA0E,EAAAsB,EAAAlB,KAAA9E,IAEAwF,EAAA,SAAA9C,GACA,IAAA/C,EAAA,IAAA7C,WAAA,CACA,EACA,MACA,QACA,QACA,WAEA4F,EAAA6B,WAAA,OACA7B,EAAA6B,WAAA,OACA7B,EAAA6B,WAAA,MACA,IAAA7B,EAAA6B,SACA,OACA,MAaA,OAPA7B,EAAAW,aACA1D,EAAA,IAAA+C,EAAAW,aAAA,OACA1D,EAAA,IAAA+C,EAAAW,aAAA,OACA1D,EAAA,IAAA+C,EAAAW,aAAA,MACA1D,EAAA,QAAA+C,EAAA,YAGAgC,EAAAsB,EAAAR,KAAA7F,IAEA4F,EAAA,SAAA7C,GACA,OAAAgC,EAAAsB,EAAAT,KAAAC,EAAA9C,GAAA+C,EAAA/C,EAAAjE,MAAAuG,EAAAtC,KAEAqC,EAAA,SAAAwD,GACA,OAAA7D,EAAAsB,EAAAjB,KAAA,IAAAjI,WAAA,CACA,EACA,OACA,WAAAyL,IAAA,IACA,SAAAA,IAAA,IACA,MAAAA,IAAA,EACA,IAAAA,MAGAvD,EAAA,SAAAtC,GACA,OAAAgC,EAAAsB,EAAAhB,KACA,UAAAtC,EAAAjE,KAAAiG,EAAAsB,EAAA6B,KAAAtB,GAAA7B,EAAAsB,EAAAqB,KAAAb,GACA7B,IACAgB,EAAAjD,KAEAuC,EAAA,SAAAsD,EAAAjH,GACA,IACAkH,EAAA,GACArH,EAAAG,EAAA1B,OAEA,MAAAuB,IACAqH,EAAArH,GAAA0E,EAAAvE,EAAAH,IAEA,OAAAuD,EAAA5E,MAAA,MACAkG,EAAAf,KACAF,EAAAwD,IACAE,OAAAD,KAOAtD,EAAA,SAAA5D,GACA,IACAH,EAAAG,EAAA1B,OACA8I,EAAA,GAEA,MAAAvH,IACAuH,EAAAvH,GAAAkE,EAAA/D,EAAAH,IAGA,OAAAuD,EAAA5E,MAAA,MAAAkG,EAAAd,KAAAE,EAAA,aAAAqD,OAAAC,GAAAD,OAAAtD,EAAA7D,MAEA6D,EAAA,SAAA7D,GACA,IACAH,EAAAG,EAAA1B,OACA8I,EAAA,GAEA,MAAAvH,IACAuH,EAAAvH,GAAA2E,EAAAxE,EAAAH,IAEA,OAAAuD,EAAA5E,MAAA,MAAAkG,EAAAb,MAAAsD,OAAAC,KAEAtD,EAAA,SAAAb,GACA,IACAlH,EAAA,IAAAP,WAAA,CACA,EACA,MACA,QACA,QACA,YACA,WAAAyH,IAAA,IACA,SAAAA,IAAA,IACA,MAAAA,IAAA,EACA,IAAAA,EACA,QACA,IACA,IACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,kBAEA,OAAAG,EAAAsB,EAAAZ,KAAA/H,IAGAqI,EAAA,SAAAhD,GACA,IAGAiG,EACAxH,EAHAmD,EAAA5B,EAAA4B,SAAA,GACAjH,EAAA,IAAAP,WAAA,EAAAwH,EAAA1E,QAOA,IAAAuB,EAAA,EAAaA,EAAAmD,EAAA1E,OAAoBuB,IACjCwH,EAAArE,EAAAnD,GAAAwH,MAEAtL,EAAA8D,EAAA,GAAAwH,EAAAC,WAAA,EACAD,EAAAE,cAAA,EACAF,EAAA,cAGA,OAAAjE,EAAAsB,EAAAN,KACArI,IAGAsI,EAAA,SAAAjD,GACA,OAAAgC,EAAAsB,EAAAL,KACAC,EAAAlD,GACAgC,EAAAsB,EAAAyB,KAAAZ,GACAnC,EAAAsB,EAAAuB,KAAAZ,GACAjC,EAAAsB,EAAAwB,KAAAZ,GACAlC,EAAAsB,EAAAsB,KAAAZ,KAGA,WACA,IAAAoC,EAAAC,EAEAnD,EAAA,SAAAlD,GAEA,OAAAgC,EAAAsB,EAAAJ,KAAA,IAAA9I,WAAA,CACA,EACA,MACA,UACA,UAAA4F,EAAAjE,KAAAqK,EAAApG,GAAAqG,EAAArG,KAGAoG,EAAA,SAAApG,GACA,IAKAvB,EAJA6H,EAAAtG,EAAAsG,KAAA,GACAC,EAAAvG,EAAAuG,KAAA,GACAC,EAAA,GACAC,EAAA,GAIA,IAAAhI,EAAA,EAAeA,EAAA6H,EAAApJ,OAAgBuB,IAC/B+H,EAAA9L,MAAA,MAAA4L,EAAA7H,GAAA1D,cAAA,GACAyL,EAAA9L,KAAA,IAAA4L,EAAA7H,GAAA1D,YACAyL,IAAAT,OAAAW,MAAApM,UAAAqM,MAAAnM,KAAA8L,EAAA7H,KAIA,IAAAA,EAAA,EAAeA,EAAA8H,EAAArJ,OAAgBuB,IAC/BgI,EAAA/L,MAAA,MAAA6L,EAAA9H,GAAA1D,cAAA,GACA0L,EAAA/L,KAAA,IAAA6L,EAAA9H,GAAA1D,YACA0L,IAAAV,OAAAW,MAAApM,UAAAqM,MAAAnM,KAAA+L,EAAA9H,KAGA,OAAAuD,EAAAsB,EAAAgB,KAAA,IAAAlK,WAAA,CACA,MACA,MACA,IACA,IACA,IACA,QACA,QACA,SACA,MAAA4F,EAAA4G,QAAA,EACA,IAAA5G,EAAA4G,OACA,MAAA5G,EAAA6G,SAAA,EACA,IAAA7G,EAAA6G,OACA,SACA,SACA,QACA,IACA,GACA,gBACA,eACA,eACA,cACA,cACA,QACA,QACA,MACA,KACA,QACA7E,EAAAsB,EAAAiB,KAAA,IAAAnK,WAAA,CACA,EACA4F,EAAA8G,WACA9G,EAAA+G,qBACA/G,EAAAgH,SACA,KACAjB,OAAA,CACAO,EAAApJ,SACA6I,OAAAS,GAAAT,OAAA,CACAQ,EAAArJ,SACA6I,OAAAU,KACAzE,EAAAsB,EAAAkB,KAAA,IAAApK,WAAA,CACA,aACA,aACA,kBAKAiM,EAAA,SAAArG,GACA,OAAAgC,EAAAsB,EAAAoB,KAAA,IAAAtK,WAAA,CAGA,MACA,MACA,IAGA,QACA,SACA,MAAA4F,EAAA4F,eAAA,EACA,IAAA5F,EAAA4F,cAEA,MAAA5F,EAAAiH,aAAA,EACA,IAAAjH,EAAAiH,WACA,IACA,KAEA,MAAAjH,EAAAW,aAAA,EACA,IAAAX,EAAAW,WACA,MAGAuB,EAAAlC,KAzGA,GA6GA4C,EAAA,SAAA5C,GACA,IAAA/C,EAAA,IAAA7C,WAAA,CACA,EACA,MACA,QACA,SACA,WAAA4F,EAAAjB,KAAA,IACA,SAAAiB,EAAAjB,KAAA,IACA,MAAAiB,EAAAjB,KAAA,EACA,IAAAiB,EAAAjB,GACA,SACA,WAAAiB,EAAA6B,WAAA,IACA,SAAA7B,EAAA6B,WAAA,IACA,MAAA7B,EAAA6B,WAAA,EACA,IAAA7B,EAAA6B,SACA,QACA,QACA,IACA,IACA,IACA,IACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,UACA,MAAA7B,EAAA4G,QAAA,EACA,IAAA5G,EAAA4G,MACA,KACA,MAAA5G,EAAA6G,SAAA,EACA,IAAA7G,EAAA6G,OACA,MAGA,OAAA7E,EAAAsB,EAAAV,KAAA3F,IAOAkG,EAAA,SAAAnD,GACA,IAAAkH,EAAAC,EAAAC,EACAC,EAAAtF,EACAuF,EAAAC,EA2CA,OAzCAL,EAAAlF,EAAAsB,EAAA4B,KAAA,IAAA9K,WAAA,CACA,EACA,QACA,WAAA4F,EAAAjB,KAAA,IACA,SAAAiB,EAAAjB,KAAA,IACA,MAAAiB,EAAAjB,KAAA,EACA,IAAAiB,EAAAjB,GACA,QACA,QACA,QACA,WAGAuI,EAAA1G,KAAAG,MAAAf,EAAAlB,qBAAAsF,EAAA,IACAmD,EAAA3G,KAAAG,MAAAf,EAAAlB,qBAAAsF,EAAA,IAEA+C,EAAAnF,EAAAsB,EAAA2B,KAAA,IAAA7K,WAAA,CACA,EACA,MAEAkN,IAAA,OACAA,IAAA,OACAA,IAAA,MACA,IAAAA,EACAC,IAAA,OACAA,IAAA,OACAA,IAAA,MACA,IAAAA,KAMAxF,EAAA,GAQA,UAAA/B,EAAAjE,MACAqL,EAAA/D,EAAArD,EAAA+B,GACAC,EAAAsB,EAAAH,KACA+D,EACAC,EACAC,KAMAC,EAAArE,EAAAhD,GACAoH,EAAA/D,EAAArD,EACAqH,EAAAnK,OAAA6E,GACAC,EAAAsB,EAAAH,KACA+D,EACAC,EACAC,EACAC,KAQA1E,EAAA,SAAA3C,GAEA,OADAA,EAAA6B,SAAA7B,EAAA6B,UAAA,WACAG,EAAAsB,EAAAX,KACAC,EAAA5C,GACA6C,EAAA7C,KAGAoD,EAAA,SAAApD,GACA,IAAA/C,EAAA,IAAA7C,WAAA,CACA,EACA,OACA,WAAA4F,EAAAjB,KAAA,IACA,SAAAiB,EAAAjB,KAAA,IACA,MAAAiB,EAAAjB,KAAA,EACA,IAAAiB,EAAAjB,GACA,QACA,QACA,QACA,UAUA,MAJA,UAAAiB,EAAAjE,OACAkB,IAAAC,OAAA,MAGA8E,EAAAsB,EAAAF,KAAAnG,IAGA,WACA,IAAAuK,EAAAC,EAAAC,EAMAA,EAAA,SAAA9F,EAAA/F,GACA,IAAA8L,EAAA,EAAAC,EAAA,EACAC,EAAA,EAAAC,EAAA,EAkBA,OAfAlG,EAAA1E,cACAxB,IAAAkG,EAAA,GAAAC,WACA8F,EAAA,QAEAjM,IAAAkG,EAAA,GAAAlE,OACAkK,EAAA,QAEAlM,IAAAkG,EAAA,GAAAqE,QACA4B,EAAA,QAEAnM,IAAAkG,EAAA,GAAAkG,wBACAA,EAAA,IAIA,CACA,EACA,EACAH,EAAAC,EAAAC,EAAAC,EACA,GACA,WAAAlG,EAAA1E,UAAA,IACA,SAAA0E,EAAA1E,UAAA,IACA,MAAA0E,EAAA1E,UAAA,EACA,IAAA0E,EAAA1E,QACA,WAAArB,KAAA,IACA,SAAAA,KAAA,IACA,MAAAA,KAAA,EACA,IAAAA,IAIA4L,EAAA,SAAAzH,EAAAnE,GACA,IAAAlB,EAAAiH,EAAAmG,EAAAtJ,EAOA,IALAmD,EAAA5B,EAAA4B,SAAA,GACA/F,GAAA,MAAA+F,EAAA1E,OAEAvC,EAAA+M,EAAA9F,EAAA/F,GAEA4C,EAAA,EAAeA,EAAAmD,EAAA1E,OAAoBuB,IACnCsJ,EAAAnG,EAAAnD,GACA9D,IAAAoL,OAAA,EACA,WAAAgC,EAAAlG,YAAA,IACA,SAAAkG,EAAAlG,YAAA,IACA,MAAAkG,EAAAlG,YAAA,EACA,IAAAkG,EAAAlG,UACA,WAAAkG,EAAArK,QAAA,IACA,SAAAqK,EAAArK,QAAA,IACA,MAAAqK,EAAArK,QAAA,EACA,IAAAqK,EAAArK,KACAqK,EAAA9B,MAAA+B,WAAA,EAAAD,EAAA9B,MAAAC,UACA6B,EAAA9B,MAAAE,cAAA,EACA4B,EAAA9B,MAAAgC,eAAA,EACAF,EAAA9B,MAAAiC,cAAA,EACAH,EAAA9B,MAAAkC,gBACA,MAAAJ,EAAA9B,MAAAmC,oBACA,GAAAL,EAAA9B,MAAAmC,qBACA,WAAAL,EAAAD,yBAAA,IACA,SAAAC,EAAAD,yBAAA,IACA,MAAAC,EAAAD,yBAAA,EACA,IAAAC,EAAAD,wBAGA,OAAA9F,EAAAsB,EAAAD,KAAA,IAAAjJ,WAAAO,KAGA6M,EAAA,SAAAxH,EAAAnE,GACA,IAAAlB,EAAAiH,EAAAmG,EAAAtJ,EAOA,IALAmD,EAAA5B,EAAA4B,SAAA,GACA/F,GAAA,KAAA+F,EAAA1E,OAEAvC,EAAA+M,EAAA9F,EAAA/F,GAEA4C,EAAA,EAAeA,EAAAmD,EAAA1E,OAAoBuB,IACnCsJ,EAAAnG,EAAAnD,GACA9D,IAAAoL,OAAA,EACA,WAAAgC,EAAAlG,YAAA,IACA,SAAAkG,EAAAlG,YAAA,IACA,MAAAkG,EAAAlG,YAAA,EACA,IAAAkG,EAAAlG,UACA,WAAAkG,EAAArK,QAAA,IACA,SAAAqK,EAAArK,QAAA,IACA,MAAAqK,EAAArK,QAAA,EACA,IAAAqK,EAAArK,OAGA,OAAAsE,EAAAsB,EAAAD,KAAA,IAAAjJ,WAAAO,KAGA0I,EAAA,SAAArD,EAAAnE,GACA,gBAAAmE,EAAAjE,KACAyL,EAAAxH,EAAAnE,GAGA4L,EAAAzH,EAAAnE,IA3GA,GA+GAyD,EAAAC,QAAA,CACA4C,OACAC,OACAG,OACAC,OACA6F,YAAA,SAAAzJ,GACA,IAGA3B,EAFAqL,EAAAnG,IACAoG,EAAA/F,EAAA5D,GAMA,OAHA3B,EAAA,IAAA7C,WAAAkO,EAAAvN,WAAAwN,EAAAxN,YACAkC,EAAAjC,IAAAsN,GACArL,EAAAjC,IAAAuN,EAAAD,EAAAvN,YACAkC,yCClvBA,IAAAtD,EAAaC,EAAQ,QAErB4O,EAAA,WAEAC,EAAA,WAEAC,EAAA,SAAAC,EAAAC,GACA,IAAAC,EAAA,EAEAF,EAAAC,IAQAC,GAAA,GAKA,MAAAjI,KAAAkI,IAAAF,EAAAD,GAAAF,EACAE,GAAAE,EAAAL,EAGA,OAAAG,GAGA5O,EAAA,SAAAgC,GACA,IAAAgN,EAAAC,EAEAjP,EAAAO,UAAAC,KAAAC,KAAAC,MAEAA,KAAAwO,MAAAlN,EAEAtB,KAAAC,KAAA,SAAA4C,GACAA,EAAAvB,OAAAtB,KAAAwO,aAIAvN,IAAAsN,IACAA,EAAA1L,EAAAY,KAGAZ,EAAAY,IAAAwK,EAAApL,EAAAY,IAAA8K,GACA1L,EAAAW,IAAAyK,EAAApL,EAAAW,IAAA+K,GAEAD,EAAAzL,EAAAY,IAEAzD,KAAAS,QAAA,OAAAoC,KAGA7C,KAAAU,MAAA,WACA6N,EAAAD,EACAtO,KAAAS,QAAA,SAGAT,KAAAyO,cAAA,WACAF,OAAA,EACAD,OAAA,IAKAhP,EAAAO,UAAA,IAAAX,EAEA2F,EAAAC,QAAA,CACAxF,0BACA2O,qDCxEA,IACAS,EAAAC,EAAAC,EAAAC,EAAAC,EADAC,EAAiB5P,EAAQ,QAAc4P,WAIvCL,EAAA,SAAA7L,EAAAmM,GACA,IACAhL,EAAAf,EAAA3B,EAAA2N,EAAAC,EADAC,EAAA,GAGA,IAAAH,EAAAvM,OAEA,YAGA,IAAAuB,EAAA,EAAaA,EAAAnB,EAAAvC,YACb2C,EAAA8L,EAAAlM,EAAAmB,IAAA,GACAnB,EAAAmB,EAAA,OACAnB,EAAAmB,EAAA,MACAnB,EAAAmB,EAAA,IAEA1C,EAAAqN,EAAA9L,EAAArC,SAAAwD,EAAA,EAAAA,EAAA,IAEAiL,EAAAhM,EAAA,EAAAe,EAAAf,EAAAJ,EAAAvC,WAEAgB,IAAA0N,EAAA,KACA,IAAAA,EAAAvM,OAGA0M,EAAAlP,KAAA4C,EAAArC,SAAAwD,EAAA,EAAAiL,KAGAC,EAAAR,EAAA7L,EAAArC,SAAAwD,EAAA,EAAAiL,GAAAD,EAAA9C,MAAA,IACAgD,EAAAzM,SACA0M,IAAA7D,OAAA4D,MAIAlL,EAAAiL,EAIA,OAAAE,GAQAR,EAAA,SAAAjP,GACA,IAAA8C,EAAA,GAKA,OAJAA,GAAA4M,OAAAC,aAAA3P,EAAA,IACA8C,GAAA4M,OAAAC,aAAA3P,EAAA,IACA8C,GAAA4M,OAAAC,aAAA3P,EAAA,IACA8C,GAAA4M,OAAAC,aAAA3P,EAAA,IACA8C,GAqBAoM,EAAA,SAAA9O,GACA,IACA0C,EAAA,GACA8M,EAAAZ,EAAA5O,EAAA,iBAGA,OAAAwP,EAAAC,OAAA,SAAA/M,EAAA0F,GACA,IAAAC,EAAAqH,EAAAC,EAAAnL,EAAA+D,EAGA,OADAF,EAAAuG,EAAAxG,EAAA,aACAC,GAGAqH,EAAArH,EAAA,GACAsH,EAAA,IAAAD,EAAA,MACAlL,EAAAyK,EAAA5G,EAAAsH,IAAA,GACAtH,EAAAsH,EAAA,OACAtH,EAAAsH,EAAA,MACAtH,EAAAsH,EAAA,IAEApH,EAAAqG,EAAAxG,EAAA,oBACAG,GAGAmH,EAAAnH,EAAA,GACAoH,EAAA,IAAAD,EAAA,MACAhN,EAAA8B,GAAAyK,EAAA1G,EAAAoH,IAAA,GACApH,EAAAoH,EAAA,OACApH,EAAAoH,EAAA,MACApH,EAAAoH,EAAA,IACAjN,GARA,MAXA,MAoBGA,IAmBHqM,EAAA,SAAAD,EAAA/K,GACA,IAAA6L,EAAAC,EAAAnN,EA6CA,OA1CAkN,EAAAhB,EAAA7K,EAAA,iBAGA8L,EAAA,GAAArE,OAAA3I,MAAA,GAAA+M,EAAAE,IAAA,SAAAlH,GACA,OAAAgG,EAAAhG,EAAA,UAAAkH,IAAA,SAAAnF,GACA,IAAAnG,EAAAuL,EAAAC,EA+BA,OA5BAxL,EAAAyK,EAAAtE,EAAA,OACAA,EAAA,OACAA,EAAA,MACAA,EAAA,IAEAoF,EAAAjB,EAAAtK,IAAA,IAGAwL,EAAApB,EAAAhG,EAAA,UAAAkH,IAAA,SAAApF,GACA,IAAAgF,EAAAhN,EAcA,OAZAgN,EAAAhF,EAAA,GACAhI,EAAAuM,EAAAvE,EAAA,OACAA,EAAA,OACAA,EAAA,MACAA,EAAA,IACA,IAAAgF,IACAhN,GAAA2D,KAAAyD,IAAA,MACApH,GAAAuM,EAAAvE,EAAA,OACAA,EAAA,OACAA,EAAA,OACAA,EAAA,MAEAhI,IACO,GACPsN,KAAAjJ,IAGAiJ,EAAAD,OAKArN,EAAA2D,KAAAa,IAAArE,MAAA,KAAAgN,GACAI,SAAAvN,KAAA,GAcAsM,EAAA,SAAAhP,GACA,IAAAwP,EAAAZ,EAAA5O,EAAA,iBACAkQ,EAAA,GAuBA,OArBAV,EAAAW,QAAA,SAAA/H,GACA,IAAAgI,EAAAxB,EAAAxG,EAAA,iBACAiI,EAAAzB,EAAAxG,EAAA,UAEAgI,EAAAD,QAAA,SAAA3H,EAAAmH,GACA,IAEA7E,EACA4E,EACAtL,EAJAkM,EAAAzB,EAAArG,EAAA9H,SAAA,OACA2H,EAAAgI,EAAAV,GAKA,SAAAW,IACAxF,EAAA,IAAAE,SAAA3C,EAAAzI,OAAAyI,EAAA4C,WAAA5C,EAAA7H,YACAkP,EAAA5E,EAAAyF,SAAA,GACAnM,EAAA,IAAAsL,EAAA5E,EAAA0F,UAAA,IAAA1F,EAAA0F,UAAA,IAEAN,EAAA/P,KAAAiE,QAKA8L,GAGAnL,EAAAC,QAAA,CACA4J,UACAC,YACAC,YACAC,YACAmB,cAAAlB,2BCpOAjK,EAAAC,QAAA,CACAyL,UAAapR,EAAQ,QACrBqR,MAASrR,EAAQ,QACjBsR,WAActR,EAAQ,QAAcsR,WACpCC,mBAAsBvR,EAAQ,QAAcuR,mBAC5CC,mBAAsBxR,EAAQ,QAAcwR,mBAC5CC,cAAiBzR,EAAQ,+BCFzB,IAAA0R,EAAA,SAAAC,GACA,IACA9M,EACA+M,EACAhK,EAAA,GACAvB,EAAA,GAIA,IAFAuB,EAAAzG,WAAA,EAEA0D,EAAA,EAAaA,EAAA8M,EAAArO,OAAqBuB,IAClC+M,EAAAD,EAAA9M,GAGA,+BAAA+M,EAAAC,aAGAjK,EAAAtE,SACAsE,EAAAK,SAAA2J,EAAAtN,IAAAsD,EAAAtD,IACA+B,EAAAvF,KAAA8G,IAEAA,EAAA,CAAAgK,GACAhK,EAAAzG,WAAAyQ,EAAAlO,KAAAvC,WACAyG,EAAAvD,IAAAuN,EAAAvN,IACAuD,EAAAtD,IAAAsN,EAAAtN,MAGA,8CAAAsN,EAAAC,cACAjK,EAAAkK,UAAA,GAEAlK,EAAAK,SAAA2J,EAAAtN,IAAAsD,EAAAtD,IACAsD,EAAAzG,YAAAyQ,EAAAlO,KAAAvC,WACAyG,EAAA9G,KAAA8Q,IAcA,OARAvL,EAAA/C,UACAsE,EAAAK,UACAL,EAAAK,UAAA,KACAL,EAAAK,SAAA5B,IAAA/C,OAAA,GAAA2E,UAIA5B,EAAAvF,KAAA8G,GACAvB,GAOA0L,EAAA,SAAA1L,GACA,IACAxB,EACA+C,EACAoK,EAAA,GACAC,EAAA,GAiBA,IAbAD,EAAA7Q,WAAA,EACA6Q,EAAAE,SAAA,EACAF,EAAA/J,SAAA,EACA+J,EAAA3N,IAAAgC,EAAA,GAAAhC,IACA2N,EAAA1N,IAAA+B,EAAA,GAAA/B,IAGA2N,EAAA9Q,WAAA,EACA8Q,EAAAC,SAAA,EACAD,EAAAhK,SAAA,EACAgK,EAAA5N,IAAAgC,EAAA,GAAAhC,IACA4N,EAAA3N,IAAA+B,EAAA,GAAA/B,IAEAO,EAAA,EAAaA,EAAAwB,EAAA/C,OAAmBuB,IAChC+C,EAAAvB,EAAAxB,GAEA+C,EAAAkK,UAGAE,EAAA1O,SACA2O,EAAAnR,KAAAkR,GACAC,EAAA9Q,YAAA6Q,EAAA7Q,WACA8Q,EAAAC,UAAAF,EAAAE,SACAD,EAAAhK,UAAA+J,EAAA/J,UAGA+J,EAAA,CAAApK,GACAoK,EAAAE,SAAAtK,EAAAtE,OACA0O,EAAA7Q,WAAAyG,EAAAzG,WACA6Q,EAAA3N,IAAAuD,EAAAvD,IACA2N,EAAA1N,IAAAsD,EAAAtD,IACA0N,EAAA/J,SAAAL,EAAAK,WAEA+J,EAAA/J,UAAAL,EAAAK,SACA+J,EAAAE,UAAAtK,EAAAtE,OACA0O,EAAA7Q,YAAAyG,EAAAzG,WACA6Q,EAAAlR,KAAA8G,IAaA,OATAqK,EAAA3O,QAAA0O,EAAA/J,UAAA,IACA+J,EAAA/J,SAAAgK,IAAA3O,OAAA,GAAA2E,UAEAgK,EAAA9Q,YAAA6Q,EAAA7Q,WACA8Q,EAAAC,UAAAF,EAAAE,SACAD,EAAAhK,UAAA+J,EAAA/J,SAGAgK,EAAAnR,KAAAkR,GACAC,GAYAE,EAAA,SAAAF,GACA,IAAAD,EAiBA,OAfAC,EAAA,MAAAH,UAAAG,EAAA3O,OAAA,IAEA0O,EAAAC,EAAAxO,QAEAwO,EAAA9Q,YAAA6Q,EAAA7Q,WACA8Q,EAAAC,UAAAF,EAAAE,SAKAD,EAAA,MAAA3N,IAAA0N,EAAA1N,IACA2N,EAAA,MAAA5N,IAAA2N,EAAA3N,IACA4N,EAAA,MAAAhK,UAAA+J,EAAA/J,UAGAgK,GAOAG,EAAA,WACA,OACAtO,KAAA,EACAuI,MAAA,CACA+B,UAAA,EACA9B,UAAA,EACAC,aAAA,EACA8B,cAAA,EACAG,oBAAA,EACAD,gBAAA,KAaA8D,EAAA,SAAAC,EAAAnK,GACA,IAAAgG,EAAAiE,IAaA,OAXAjE,EAAAhG,aACAgG,EAAAD,sBAAAoE,EAAAjO,IAAAiO,EAAAhO,IACA6J,EAAAlG,SAAAqK,EAAArK,SACAkG,EAAArK,KAAA,EAAAwO,EAAAhP,OACA6K,EAAArK,MAAAwO,EAAAnR,WAEAmR,EAAAR,WACA3D,EAAA9B,MAAAC,UAAA,EACA6B,EAAA9B,MAAAkC,gBAAA,GAGAJ,GAIApG,EAAA,SAAAkK,EAAAM,GACA,IACAC,EAAA3N,EACAsJ,EACA6D,EACApK,EACAO,EAAAoK,GAAA,EACAvK,EAAA,GAEA,IAAAwK,EAAA,EAAaA,EAAAP,EAAA3O,OAAiBkP,IAG9B,IAFAR,EAAAC,EAAAO,GAEA3N,EAAA,EAAeA,EAAAmN,EAAA1O,OAAuBuB,IACtC+C,EAAAoK,EAAAnN,GAEAsJ,EAAAkE,EAAAzK,EAAAO,GAEAA,GAAAgG,EAAArK,KAEAkE,EAAAlH,KAAAqN,GAGA,OAAAnG,GAIAyK,EAAA,SAAAR,GACA,IACAO,EAAA3N,EAAA6N,EACAV,EACApK,EACAgK,EACAzJ,EAAA,EACAwK,EAAAV,EAAA9Q,WACAyR,EAAAX,EAAAC,SACAW,EAAAF,EAAA,EAAAC,EACAlP,EAAA,IAAAlD,WAAAqS,GACApH,EAAA,IAAAE,SAAAjI,EAAAnD,QAGA,IAAAiS,EAAA,EAAaA,EAAAP,EAAA3O,OAAiBkP,IAI9B,IAHAR,EAAAC,EAAAO,GAGA3N,EAAA,EAAeA,EAAAmN,EAAA1O,OAAuBuB,IAItC,IAHA+C,EAAAoK,EAAAnN,GAGA6N,EAAA,EAAiBA,EAAA9K,EAAAtE,OAAyBoP,IAC1Cd,EAAAhK,EAAA8K,GAEAjH,EAAAI,UAAA1D,EAAAyJ,EAAAlO,KAAAvC,YACAgH,GAAA,EACAzE,EAAAtC,IAAAwQ,EAAAlO,KAAAyE,GACAA,GAAAyJ,EAAAlO,KAAAvC,WAIA,OAAAuC,GAGAgC,EAAAC,QAAA,CACA+L,sBACAK,sBACAI,sBACApK,sBACA0K,2DCrPA,IA6BAjB,EAAAD,EAAAD,EAAAwB,EA7BA/S,EAAaC,EAAQ,QACrB+S,EAAU/S,EAAQ,QAClBgT,EAAiBhT,EAAQ,QACzBiT,EAAsBjT,EAAQ,QAC9BkT,EAAsBlT,EAAQ,QAC9BqF,EAAWrF,EAAQ,QACnBmT,EAAiBnT,EAAQ,QACzBoT,EAAiBpT,EAAQ,QAAgBoT,WACzCC,EAAgBrT,EAAQ,QACxBsT,EAAsBtT,EAAQ,QAAcsT,gBAG5CC,EAAA,CACA,kBACA,eACA,aACA,yBACA,cAGAC,EAAA,CACA,QACA,SACA,aACA,WACA,wBASAC,EAAA,SAAAC,EAAAC,GACA,IACA9O,EAEA,GAAA6O,EAAApQ,SAAAqQ,EAAArQ,OACA,SAIA,IAAAuB,EAAA,EAAaA,EAAA6O,EAAApQ,OAAcuB,IAC3B,GAAA6O,EAAA7O,KAAA8O,EAAA9O,GACA,SAIA,UAGA+O,EAAA,SACA1O,EACA2O,EACAC,EACAC,EACAC,EACAC,GAEA,IACAC,EAAAJ,EAAAD,EACAM,EAAAJ,EAAAF,EACAO,EAAAJ,EAAAF,EAMA,OACAO,MAAA,CACA/P,IAAAY,EACAb,IAAAa,EAAAgP,GAEApE,IAAA,CACAxL,IAAAY,EAAAiP,EACA9P,IAAAa,EAAAkP,GAEAH,2BACA/O,wBAaAqM,EAAA,SAAAnL,EAAAkO,GACA,IACA/M,EAAA,GACA0E,EAAA,EACAzE,EAAA,EACAlB,EAAA,EACAC,EAAAmB,IAEA4M,KAAA,GAEA/C,EAAA7Q,UAAAC,KAAAC,KAAAC,MAEAA,KAAAC,KAAA,SAAA4C,GACAwP,EAAAqB,eAAAnO,EAAA1C,GAEA0C,GACAmN,EAAAzC,QAAA,SAAA0D,GACApO,EAAAoO,GAAA9Q,EAAA8Q,KAKAjN,EAAAzG,KAAA4C,IAGA7C,KAAA4T,eAAA,SAAAC,GACAlN,EAAAkN,EAAAtO,EAAAnB,kBAAAC,qBAGArE,KAAA8T,4BAAA,SAAAzP,GACAqB,EAAArB,GAGArE,KAAA+T,oBAAA,SAAAC,GACAvO,EAAAuO,GAGAhU,KAAAU,MAAA,WACA,IACA8E,EACAsC,EACAH,EACA4D,EAGA,IAAA7E,EAAAjE,QAKA+C,EAAA4M,EAAA3L,4BACAC,EAAAnB,EAAAoB,GACApB,EAAAlB,oBAAAgO,EAAA4B,kCACA1O,EAAAkO,EAAAS,wBAEA9B,EAAA9M,kBACAC,EAAAC,EAAAC,EAAAC,GAIAH,EAAA4B,QAAAiL,EAAAlL,oBAAA1B,GAGAmC,EAAAuK,EAAAvK,KAAAyK,EAAA/K,qBAAA7B,IAEAkB,EAAA,GAEAoB,EAAAoK,EAAApK,KAAAsD,EAAA,CAAA7F,IACAgG,EAAA,IAAA5L,WAAAmI,EAAAxH,WAAAqH,EAAArH,YAGA8K,IAEAG,EAAAhL,IAAAuH,GACAyD,EAAAhL,IAAAoH,EAAAG,EAAAxH,YAEA+R,EAAA8B,aAAA5O,GAEAvF,KAAAS,QAAA,QAA0B8E,QAAAgG,UAC1BvL,KAAAS,QAAA,8BAjCAT,KAAAS,QAAA,+BAqCAiQ,EAAA7Q,UAAA,IAAAX,EAaAyR,EAAA,SAAApL,EAAAkO,GACA,IAIAW,EACAtI,EAJAV,EAAA,EACA0F,EAAA,GACAuD,EAAA,GAIAZ,KAAA,GAEA9C,EAAA9Q,UAAAC,KAAAC,KAAAC,aAEAuF,EAAA+O,OAEAtU,KAAAuU,UAAA,GAUAvU,KAAAC,KAAA,SAAAuU,GACAnC,EAAAqB,eAAAnO,EAAAiP,GAGA,2BAAAA,EAAAxD,aAAAoD,IACAA,EAAAI,EAAAJ,OACA7O,EAAAsG,IAAA,CAAA2I,EAAA3R,MAEA8P,EAAA1C,QAAA,SAAA0D,GACApO,EAAAoO,GAAAS,EAAAT,IACO3T,OAGP,2BAAAwU,EAAAxD,aACAlF,IACAA,EAAA0I,EAAA3R,KACA0C,EAAAuG,IAAA,CAAA0I,EAAA3R,OAIAiO,EAAA7Q,KAAAuU,IAOAxU,KAAAU,MAAA,WACA,IACA8E,EACAiP,EACArD,EACAtJ,EACAH,EACA4D,EAEAmJ,EACAC,EAFAvB,EAAA,EAMA,MAAAtC,EAAArO,OAAA,CACA,kCAAAqO,EAAA,GAAAE,YACA,MAEAF,EAAAlO,QAIA,OAAAkO,EAAArO,OAGA,OAFAzC,KAAA4U,oBACA5U,KAAAS,QAAA,6BAoDA,GA7CA+E,EAAA2M,EAAAtB,oBAAAC,GACAM,EAAAe,EAAAjB,oBAAA1L,GAoBA4L,EAAA,MAAAH,WAEAwD,EAAAzU,KAAA6U,iBAAA/D,EAAA,GAAAvL,GAEAkP,GAGArB,EAAAqB,EAAArN,SAEAgK,EAAA0D,QAAAL,GAGArD,EAAA9Q,YAAAmU,EAAAnU,WACA8Q,EAAAC,UAAAoD,EAAApD,SACAD,EAAA5N,IAAAiR,EAAAjR,IACA4N,EAAA3N,IAAAgR,EAAAhR,IACA2N,EAAAhK,UAAAqN,EAAArN,UAGAgK,EAAAe,EAAAb,oBAAAF,IAKAiD,EAAA5R,OAAA,CACA,IAAAsS,EAQA,GALAA,EADAtB,EAAAuB,eACAhV,KAAAiV,gBAAA7D,GAEApR,KAAAkV,kBAAA9D,IAGA2D,EAiBA,OAfA/U,KAAAuU,UAAAO,QAAA,CACAK,IAAA/D,EAAAgE,MACAtJ,IAAAvG,EAAAuG,IACAD,IAAAtG,EAAAsG,MAIA7L,KAAAuU,UAAA9R,OAAA0D,KAAAa,IAAA,EAAAhH,KAAAuU,UAAA9R,QAGAqO,EAAA,GAGA9Q,KAAA4U,oBACA5U,KAAAS,QAAA,6BAMA4R,EAAA8B,aAAA5O,GAEA6L,EAAA2D,EAGA1C,EAAAqB,eAAAnO,EAAA6L,GAIA7L,EAAA4B,QAAAgL,EAAAjL,oBAAAkK,GAGAzJ,EAAAuK,EAAAvK,KAAAwK,EAAAP,mBAAAR,IAEA7L,EAAAlB,oBAAAgO,EAAA4B,kCACA1O,EAAAkO,EAAAS,wBAEAlU,KAAAS,QAAA,oBAAA2Q,EAAAxB,IAAA,SAAAuF,GACA,OACA3R,IAAA2R,EAAA3R,IACAC,IAAA0R,EAAA1R,IACAnD,WAAA6U,EAAA7U,eAIAoU,EAAAtD,EAAA,GACAuD,EAAAvD,IAAA3O,OAAA,GAEAzC,KAAAS,QACA,oBACAsS,EACAxN,EAAAlB,oBACAqQ,EAAAjR,IACAiR,EAAAlR,IACAmR,EAAAlR,IAAAkR,EAAAvN,SACAuN,EAAAnR,IAAAmR,EAAAvN,SACAgM,IAGApT,KAAAuU,UAAAO,QAAA,CACAK,IAAA/D,EAAAgE,MACAtJ,IAAAvG,EAAAuG,IACAD,IAAAtG,EAAAsG,MAIA7L,KAAAuU,UAAA9R,OAAA0D,KAAAa,IAAA,EAAAhH,KAAAuU,UAAA9R,QAGAqO,EAAA,GAEA9Q,KAAAS,QAAA,sBAAA8E,EAAAlB,qBACArE,KAAAS,QAAA,oBAAA8E,EAAAnB,mBAEA0D,EAAAoK,EAAApK,KAAAsD,EAAA,CAAA7F,IAIAgG,EAAA,IAAA5L,WAAAmI,EAAAxH,WAAAqH,EAAArH,YAGA8K,IAEAG,EAAAhL,IAAAuH,GACAyD,EAAAhL,IAAAoH,EAAAG,EAAAxH,YAEAN,KAAAS,QAAA,QAA0B8E,QAAAgG,UAE1BvL,KAAA4U,eAGA5U,KAAAS,QAAA,8BAGAT,KAAA4U,aAAA,WACAvC,EAAA8B,aAAA5O,GAIA6O,OAAAnT,EACA6K,OAAA7K,GAKAjB,KAAA6U,iBAAA,SAAAL,GACA,IAIAa,EACAC,EACAnE,EACAoE,EACAvR,EAPAwR,EAAA,KACAC,EAAA,IACAC,EAAA7O,IAQA,IAAA7C,EAAA,EAAeA,EAAAhE,KAAAuU,UAAA9R,OAA2BuB,IAC1CuR,EAAAvV,KAAAuU,UAAAvQ,GACAmN,EAAAoE,EAAAJ,IAGA5P,EAAAuG,KAAA8G,EAAArN,EAAAuG,IAAA,GAAAyJ,EAAAzJ,IAAA,KACAvG,EAAAsG,KAAA+G,EAAArN,EAAAsG,IAAA,GAAA0J,EAAA1J,IAAA,MAKAsF,EAAA1N,IAAA8B,EAAAnB,kBAAAX,MAKA4R,EAAAb,EAAA/Q,IAAA0N,EAAA1N,IAAA0N,EAAA/J,SAIAiO,IAAAI,GACAJ,GAAAG,KAIAF,GACAI,EAAAL,KACAC,EAAAC,EACAG,EAAAL,KAKA,OAAAC,EACAA,EAAAH,IAEA,MAKAnV,KAAAkV,kBAAA,SAAA9D,GACA,IAAAuE,EAAAC,EAAAC,EAAAV,EAAA7U,EAAA+Q,EAAAjK,EAAA2N,EAEAzU,EAAA8Q,EAAA9Q,WACA+Q,EAAAD,EAAAC,SACAjK,EAAAgK,EAAAhK,SACAuO,EAAAC,EAAA,EAEA,MAAAD,EAAAtB,EAAA5R,QAAAmT,EAAAxE,EAAA3O,OAAA,CAIA,GAHAoT,EAAAxB,EAAAsB,GACAR,EAAA/D,EAAAwE,GAEAC,EAAArS,MAAA2R,EAAA3R,IACA,MAGA2R,EAAA3R,IAAAqS,EAAArS,IAGAmS,KAMAC,IACAtV,GAAA6U,EAAA7U,WACA+Q,GAAA8D,EAAA9D,SACAjK,GAAA+N,EAAA/N,UAGA,WAAAwO,EAEAxE,EAGAwE,IAAAxE,EAAA3O,OAEA,MAGAsS,EAAA3D,EAAAlF,MAAA0J,GACAb,EAAAzU,aACAyU,EAAA3N,WACA2N,EAAA1D,WACA0D,EAAAvR,IAAAuR,EAAA,GAAAvR,IACAuR,EAAAtR,IAAAsR,EAAA,GAAAtR,IAEAsR,IAKA/U,KAAAiV,gBAAA,SAAA7D,GACA,IAAAuE,EAAAC,EAAAC,EAAAV,EAAAW,EAAAC,EAmCAC,EAjCAL,EAAAtB,EAAA5R,OAAA,EACAmT,EAAAxE,EAAA3O,OAAA,EACAqT,EAAA,KACAC,GAAA,EAEA,MAAAJ,GAAA,GAAAC,GAAA,GAIA,GAHAC,EAAAxB,EAAAsB,GACAR,EAAA/D,EAAAwE,GAEAC,EAAArS,MAAA2R,EAAA3R,IAAA,CACAuS,GAAA,EACA,MAGAF,EAAArS,IAAA2R,EAAA3R,IACAmS,KAIAA,IAAAtB,EAAA5R,OAAA,IAIAqT,EAAAF,GAGAA,KAGA,IAAAG,GAAA,OAAAD,EACA,YAWA,GALAE,EADAD,EACAH,EAEAE,EAGA,IAAAE,EACA,OAAA5E,EAGA,IAAA2D,EAAA3D,EAAAlF,MAAA8J,GACAC,EAAAlB,EAAAxF,OAAA,SAAA2G,EAAAf,GAIA,OAHAe,EAAA5V,YAAA6U,EAAA7U,WACA4V,EAAA9O,UAAA+N,EAAA/N,SACA8O,EAAA7E,UAAA8D,EAAA9D,SACA6E,GACK,CAAG5V,WAAA,EAAA8G,SAAA,EAAAiK,SAAA,IAQR,OANA0D,EAAAzU,WAAA2V,EAAA3V,WACAyU,EAAA3N,SAAA6O,EAAA7O,SACA2N,EAAA1D,SAAA4E,EAAA5E,SACA0D,EAAAvR,IAAAuR,EAAA,GAAAvR,IACAuR,EAAAtR,IAAAsR,EAAA,GAAAtR,IAEAsR,GAGA/U,KAAAmW,cAAA,SAAAC,GACA/B,EAAA+B,IAIAzF,EAAA9Q,UAAA,IAAAX,EAUA+S,EAAA,SAAAwB,EAAA4C,GAIArW,KAAAsW,eAAA,EACAtW,KAAAqW,iBAEA5C,KAAA,GAEA,qBAAAA,EAAA8C,MACAvW,KAAAwW,cAAA/C,EAAA8C,MAEAvW,KAAAwW,aAAA,EAGA,mBAAA/C,EAAAS,yBACAlU,KAAAkU,uBAAAT,EAAAS,wBAGAlU,KAAAyW,cAAA,GACAzW,KAAA0W,WAAA,KACA1W,KAAA2W,aAAA,GACA3W,KAAA4W,gBAAA,GACA5W,KAAA6W,gBAAA,GACA7W,KAAA8W,aAAA,EACA9W,KAAA+W,cAAA,EAEA9E,EAAApS,UAAAC,KAAAC,KAAAC,MAGAA,KAAAC,KAAA,SAAA+W,GAGA,OAAAA,EAAAC,KACAjX,KAAA4W,gBAAA3W,KAAA+W,GAGAA,EAAAxR,OACAxF,KAAA6W,gBAAA5W,KAAA+W,IAMAhX,KAAAyW,cAAAxW,KAAA+W,EAAAzR,OACAvF,KAAA2W,aAAA1W,KAAA+W,EAAAzL,OACAvL,KAAA8W,cAAAE,EAAAzL,MAAAjL,WAEA,UAAA0W,EAAAzR,MAAAjE,OACAtB,KAAA0W,WAAAM,EAAAzR,YAEA,UAAAyR,EAAAzR,MAAAjE,OACAtB,KAAAkX,WAAAF,EAAAzR,WAKA0M,EAAApS,UAAA,IAAAX,EACA+S,EAAApS,UAAAa,MAAA,SAAAyW,GACA,IAQAC,EACAC,EACAzJ,EAEA5J,EAXA5C,EAAA,EACA2C,EAAA,CACAuT,SAAA,GACAC,eAAA,GACAtB,SAAA,GACAuB,KAAA,IAKAC,EAAA,EAGA,GAAAzX,KAAAyW,cAAAhU,OAAAzC,KAAAsW,eAAA,CACA,0BAAAa,GACA,uBAAAA,EAIA,OACK,GAAAnX,KAAAwW,YAGL,OACK,OAAAxW,KAAAyW,cAAAhU,OAaL,OANAzC,KAAA+W,qBAEA/W,KAAA+W,eAAA/W,KAAAsW,iBACAtW,KAAAS,QAAA,QACAT,KAAA+W,cAAA,IAuCA,IAjCA/W,KAAA0W,YACAe,EAAAzX,KAAA0W,WAAAtS,kBAAAZ,IACAmP,EAAA1C,QAAA,SAAA0D,GACA5P,EAAAyT,KAAA7D,GAAA3T,KAAA0W,WAAA/C,IACK3T,OACFA,KAAAkX,aACHO,EAAAzX,KAAAkX,WAAA9S,kBAAAZ,IACAkP,EAAAzC,QAAA,SAAA0D,GACA5P,EAAAyT,KAAA7D,GAAA3T,KAAAkX,WAAAvD,IACK3T,OAGL,IAAAA,KAAAyW,cAAAhU,OACAsB,EAAAzC,KAAAtB,KAAAyW,cAAA,GAAAnV,KAEAyC,EAAAzC,KAAA,WAGAtB,KAAA+W,eAAA/W,KAAAyW,cAAAhU,OAEAmL,EAAAsE,EAAAtE,YAAA5N,KAAAyW,eAGA1S,EAAA6J,YAAA,IAAAjO,WAAAiO,EAAAtN,YAIAyD,EAAA6J,YAAArN,IAAAqN,GAGA7J,EAAAlB,KAAA,IAAAlD,WAAAK,KAAA8W,cAGA9S,EAAA,EAAaA,EAAAhE,KAAA2W,aAAAlU,OAA8BuB,IAC3CD,EAAAlB,KAAAtC,IAAAP,KAAA2W,aAAA3S,GAAA5C,GACAA,GAAApB,KAAA2W,aAAA3S,GAAA1D,WAKA,IAAA0D,EAAA,EAAaA,EAAAhE,KAAA4W,gBAAAnU,OAAiCuB,IAC9CoT,EAAApX,KAAA4W,gBAAA5S,GAEAoT,EAAAvI,UAAAuI,EAAAnE,SACAjT,KAAAkU,yBACAkD,EAAAvI,WAAA4I,GAEAL,EAAAvI,WAAA,IAEAuI,EAAAM,QAAAN,EAAAjE,OACAnT,KAAAkU,yBACAkD,EAAAM,SAAAD,GAEAL,EAAAM,SAAA,IAEA3T,EAAAwT,eAAAH,EAAAzT,SAAA,EACAI,EAAAuT,SAAArX,KAAAmX,GAKA,IAAApT,EAAA,EAAaA,EAAAhE,KAAA6W,gBAAApU,OAAiCuB,IAC9CqT,EAAArX,KAAA6W,gBAAA7S,GAEAqT,EAAAM,QAAAN,EAAA7T,IACAxD,KAAAkU,yBACAmD,EAAAM,SAAAF,GAEAJ,EAAAM,SAAA,IAEA5T,EAAAkS,SAAAhW,KAAAoX,GAKAtT,EAAAkS,SAAA2B,aAAA5X,KAAAqW,eAAAuB,aAGA5X,KAAAyW,cAAAhU,OAAA,EACAzC,KAAA0W,WAAA,KACA1W,KAAA2W,aAAAlU,OAAA,EACAzC,KAAA4W,gBAAAnU,OAAA,EACAzC,KAAA8W,aAAA,EACA9W,KAAA6W,gBAAApU,OAAA,EAGAzC,KAAAS,QAAA,OAAAsD,GAGA/D,KAAA+W,eAAA/W,KAAAsW,iBACAtW,KAAAS,QAAA,QACAT,KAAA+W,cAAA,IASAtG,EAAA,SAAAgD,GACA,IAGAiD,EACAQ,EAHApW,EAAAd,KACA6X,GAAA,EAIApH,EAAA5Q,UAAAC,KAAAC,KAAAC,MAEAyT,KAAA,GACAzT,KAAAqE,oBAAAoP,EAAApP,qBAAA,EACArE,KAAA8X,kBAAA,GAEA9X,KAAA+X,iBAAA,WACA,IAAAC,EAAA,GACAhY,KAAA8X,kBAAAE,EAEAA,EAAA1W,KAAA,MACA0W,EAAA3B,eAAA,IAAA7R,EAAAG,eAGAqT,EAAAC,UAAA,IAAAzF,EACAwF,EAAAE,6BAAA,IAAA1T,EAAAlF,wBAAA,SACA0Y,EAAAG,qCAAA,IAAA3T,EAAAlF,wBAAA,kBACA0Y,EAAAI,WAAA,IAAA9F,EACA0F,EAAAK,eAAA,IAAApG,EAAAwB,EAAAuE,EAAA3B,gBACA2B,EAAAM,eAAAN,EAAAC,UAEAD,EAAAC,UACAM,KAAAP,EAAAE,8BACAK,KAAAP,EAAAI,YACAJ,EAAAC,UACAM,KAAAP,EAAAG,sCACAI,KAAAP,EAAA3B,gBACAkC,KAAAP,EAAAK,gBAEAL,EAAA3B,eAAAmC,GAAA,qBAAA/G,GACAuG,EAAAC,UAAAQ,aAAAhH,EAAAiH,aAGAV,EAAAC,UAAAO,GAAA,gBAAA3V,GACA,mBAAAA,EAAAvB,MAAA0W,EAAAW,qBACAzB,KAAA,CACA9S,kBAAA,CACAC,oBAAAvD,EAAAuD,qBAEAE,MAAA,OACAjD,KAAA,SAGA0W,EAAAK,eAAA/B,iBACA0B,EAAAW,mBAAA,IAAAjI,EAAAwG,EAAAzD,GAEAuE,EAAAI,WACAG,KAAAP,EAAAW,oBACAJ,KAAAP,EAAAK,mBAKAL,EAAAK,eAAAG,GAAA,OAAAxY,KAAAS,QAAAmY,KAAA5Y,KAAA,SAEAgY,EAAAK,eAAAG,GAAA,OAAAxY,KAAAS,QAAAmY,KAAA5Y,KAAA,UAGAA,KAAA6Y,gBAAA,WACA,IAAAb,EAAA,GACAhY,KAAA8X,kBAAAE,EAEAA,EAAA1W,KAAA,KACA0W,EAAA3B,eAAA,IAAA7R,EAAAG,eAGAqT,EAAAc,aAAA,IAAAtU,EAAAzF,sBACAiZ,EAAAe,YAAA,IAAAvU,EAAAxF,qBACAgZ,EAAAgB,iBAAA,IAAAxU,EAAAvF,iBACA+Y,EAAAiB,6BAAA,IAAAzU,EAAAlF,wBAAA,SACA0Y,EAAAE,6BAAA,IAAA1T,EAAAlF,wBAAA,SACA0Y,EAAAG,qCAAA,IAAA3T,EAAAlF,wBAAA,kBACA0Y,EAAAI,WAAA,IAAA9F,EACA0F,EAAAkB,WAAA,IAAA3G,EACAyF,EAAAmB,cAAA,IAAA3U,EAAApF,cACA4Y,EAAAK,eAAA,IAAApG,EAAAwB,EAAAuE,EAAA3B,gBACA2B,EAAAM,eAAAN,EAAAc,aAGAd,EAAAc,aACAP,KAAAP,EAAAe,aACAR,KAAAP,EAAAgB,kBAIAhB,EAAAgB,iBACAT,KAAAP,EAAAiB,8BACAV,KAAAP,EAAAkB,YACAlB,EAAAgB,iBACAT,KAAAP,EAAAE,8BACAK,KAAAP,EAAAI,YAEAJ,EAAAgB,iBACAT,KAAAP,EAAAG,sCACAI,KAAAP,EAAA3B,gBACAkC,KAAAP,EAAAK,gBAGAL,EAAAkB,WAAAX,KAAAP,EAAAmB,eACAZ,KAAAP,EAAAK,gBAEAL,EAAAgB,iBAAAR,GAAA,gBAAA3V,GACA,IAAAmB,EAEA,gBAAAnB,EAAAvB,KAAA,CACA0C,EAAAnB,EAAAsB,OAAA1B,OAGA,MAAAuB,IACA0S,GAAA,UAAA7T,EAAAsB,OAAAH,GAAA1C,KAGW4V,GAAA,UAAArU,EAAAsB,OAAAH,GAAA1C,OACX4V,EAAArU,EAAAsB,OAAAH,GACAkT,EAAA9S,kBAAAC,oBAAAvD,EAAAuD,sBAJAqS,EAAA7T,EAAAsB,OAAAH,GACA0S,EAAAtS,kBAAAC,oBAAAvD,EAAAuD,qBAQAqS,IAAAsB,EAAAoB,qBACApB,EAAAK,eAAA/B,iBACA0B,EAAAoB,mBAAA,IAAAzI,EAAA+F,EAAAjD,GAEAuE,EAAAoB,mBAAAZ,GAAA,6BAAApU,GAIA8S,IACAA,EAAA9S,oBAKA4T,EAAAW,mBAAA/E,eAAAxP,EAAAX,QAIAuU,EAAAoB,mBAAAZ,GAAA,oBACA1X,EAAAL,QAAAmY,KAAA9X,EAAA,YACAkX,EAAAoB,mBAAAZ,GAAA,oBACA1X,EAAAL,QAAAmY,KAAA9X,EAAA,2BAEAkX,EAAAoB,mBAAAZ,GAAA,+BAAAnU,GACA6S,GACAc,EAAAW,mBAAA7E,4BAAAzP,KAKA2T,EAAAkB,WACAX,KAAAP,EAAAoB,oBACAb,KAAAP,EAAAK,iBAGAnB,IAAAc,EAAAW,qBAEAX,EAAAK,eAAA/B,iBACA0B,EAAAW,mBAAA,IAAAjI,EAAAwG,EAAAzD,GAGAuE,EAAAI,WACAG,KAAAP,EAAAW,oBACAJ,KAAAP,EAAAK,oBAMAL,EAAAK,eAAAG,GAAA,OAAAxY,KAAAS,QAAAmY,KAAA5Y,KAAA,SAEAgY,EAAAK,eAAAG,GAAA,OAAAxY,KAAAS,QAAAmY,KAAA5Y,KAAA,UAIAA,KAAAqZ,uBAAA,SAAAhV,GACA,IAAA2T,EAAAhY,KAAA8X,kBAEArE,EAAAS,yBACAlU,KAAAqE,uBAGA6S,IACAA,EAAA9S,kBAAAX,SAAAxC,EACAiW,EAAA9S,kBAAAZ,SAAAvC,EACAoR,EAAA8B,aAAA+C,GACAzD,EAAAS,yBACAgD,EAAA9S,kBAAAC,uBAEA2T,EAAAE,8BACAF,EAAAE,6BAAAzJ,iBAGAiI,IACAsB,EAAAoB,qBACApB,EAAAoB,mBAAA7E,UAAA,GACAyD,EAAAiB,6BAAAxK,iBAEAiI,EAAAtS,kBAAAX,SAAAxC,EACAyV,EAAAtS,kBAAAZ,SAAAvC,EACAoR,EAAA8B,aAAAuC,GACAsB,EAAAmB,cAAAG,QACA7F,EAAAS,yBACAwC,EAAAtS,kBAAAC,wBAIA2T,EAAAG,sCACAH,EAAAG,qCAAA1J,iBAIAzO,KAAA+T,oBAAA,SAAAC,GACAkD,GACAlX,KAAA8X,kBAAAa,mBAAA5E,oBAAAC,IAIAhU,KAAAmW,cAAA,SAAA9B,GACAqC,GAAA1W,KAAA8X,kBAAAsB,oBACApZ,KAAA8X,kBAAAsB,mBAAAjD,cAAA9B,IAKArU,KAAAC,KAAA,SAAA4C,GACA,GAAAgV,EAAA,CACA,IAAA0B,EAAA9G,EAAA5P,GAEA0W,GAAA,QAAAvZ,KAAA8X,kBAAAxW,KACAtB,KAAA+X,mBACOwB,GAAA,OAAAvZ,KAAA8X,kBAAAxW,MACPtB,KAAA6Y,kBAEAhB,GAAA,EAEA7X,KAAA8X,kBAAAQ,eAAArY,KAAA4C,IAIA7C,KAAAU,MAAA,WACAmX,GAAA,EAEA7X,KAAA8X,kBAAAQ,eAAA5X,SAIAV,KAAAwZ,cAAA,WACAxZ,KAAA8X,kBAAAqB,eACAnZ,KAAA8X,kBAAAqB,cAAAG,UAKA7I,EAAA5Q,UAAA,IAAAX,EAEA2F,EAAAC,QAAA,CACA2L,aACAE,qBACAD,qBACAgC,mBACAC,mBAEAI,qECzkCA,IAAA0G,EAMAA,EAAA,SAAAC,GACA,IAEAC,EAAAD,EAAApZ,WAGAsZ,EAAA,EAGAC,EAAA,EAGA7Z,KAAAyC,OAAA,WACA,SAAAkX,GAIA3Z,KAAA8Z,cAAA,WACA,SAAAH,EAAAE,GAIA7Z,KAAA+Z,SAAA,WACA,IACAC,EAAAN,EAAApZ,WAAAqZ,EACAM,EAAA,IAAAta,WAAA,GACAua,EAAA/T,KAAAa,IAAA,EAAA2S,GAEA,OAAAO,EACA,UAAAC,MAAA,sBAGAF,EAAA1Z,IAAAmZ,EAAAlZ,SAAAwZ,EACAA,EAAAE,IACAN,EAAA,IAAA9O,SAAAmP,EAAAva,QAAA4Q,UAAA,GAGAuJ,EAAA,EAAAK,EACAP,GAAAO,GAIAla,KAAAoa,SAAA,SAAAC,GACA,IAAAC,EACAT,EAAAQ,GACAT,IAAAS,EACAR,GAAAQ,IAEAA,GAAAR,EACAS,EAAAnU,KAAAG,MAAA+T,EAAA,GAEAA,GAAA,EAAAC,EACAX,GAAAW,EAEAta,KAAA+Z,WAEAH,IAAAS,EACAR,GAAAQ,IAKAra,KAAAua,SAAA,SAAAtX,GACA,IACAuX,EAAArU,KAAAa,IAAA6S,EAAA5W,GACAwX,EAAAb,IAAA,GAAAY,EAUA,OARAX,GAAAW,EACAX,EAAA,EACAD,IAAAY,EACKb,EAAA,GACL3Z,KAAA+Z,WAGAS,EAAAvX,EAAAuX,EACAA,EAAA,EACAC,GAAAD,EAAAxa,KAAAua,SAAAC,GAEAC,GAIAza,KAAA0a,iBAAA,WACA,IAAAC,EACA,IAAAA,EAAA,EAA8BA,EAAAd,IAAyCc,EACvE,QAAAf,EAAA,aAAAe,GAIA,OAFAf,IAAAe,EACAd,GAAAc,EACAA,EAMA,OADA3a,KAAA+Z,WACAY,EAAA3a,KAAA0a,oBAIA1a,KAAA4a,sBAAA,WACA5a,KAAAoa,SAAA,EAAApa,KAAA0a,qBAIA1a,KAAA6a,cAAA,WACA7a,KAAAoa,SAAA,EAAApa,KAAA0a,qBAIA1a,KAAA8a,sBAAA,WACA,IAAAC,EAAA/a,KAAA0a,mBACA,OAAA1a,KAAAua,SAAAQ,EAAA,MAIA/a,KAAAgb,cAAA,WACA,IAAAP,EAAAza,KAAA8a,wBACA,SAAAL,EAEA,EAAAA,IAAA,GAEA,GAAAA,IAAA,IAKAza,KAAAib,YAAA,WACA,WAAAjb,KAAAua,SAAA,IAIAva,KAAAkb,iBAAA,WACA,OAAAlb,KAAAua,SAAA,IAGAva,KAAA+Z,YAGAlV,EAAAC,QAAA2U,wBClJA,IAEA0B,EACAC,EACAC,EACAC,EACArV,EACAO,EANAvB,EAAA,IAQAkW,EAAA,SAAAI,GACA,OAAAA,EAAAtW,GAGAmW,EAAA,SAAAG,EAAAC,GACA,OAAAD,EAAAC,GAGAH,EAAA,SAAArH,GACA,OAAAA,EAAA/O,GAGAqW,EAAA,SAAAtH,EAAAwH,GACA,OAAAxH,EAAAwH,GAGAvV,EAAA,SAAA+N,EAAAwH,GACA,OAAAL,EAAAG,EAAAtH,EAAAwH,KAGAhV,EAAA,SAAAwN,EAAAwH,GACA,OAAAJ,EAAAC,EAAArH,GAAAwH,IAGA3W,EAAAC,QAAA,CACAqW,mBACAC,mBACAC,mBACAC,mBACArV,mBACAO,yDC7BA,IAAAnH,EAAkBF,EAAQ,QAE1Bsc,EAAA,SAAAlZ,GACA,IAAAJ,EAAA,GAAAI,EAAA,GAGA,OAFAJ,IAAA,EACAA,GAAAI,EAAA,GACAJ,GAGAuZ,EAAA,SAAAnZ,GACA,YAAAA,EAAA,KAGAoZ,EAAA,SAAApZ,GACA,IAAAnB,EAAA,EASA,OAHA,GAAAmB,EAAA,YACAnB,GAAAmB,EAAA,MAEAnB,GAGAuN,EAAA,SAAApM,EAAAb,GACA,IAAAS,EAAAsZ,EAAAlZ,GACA,WAAAJ,EACA,MACGA,IAAAT,EACH,MACGA,EACH,MAEA,MAGAd,EAAA,SAAA2B,GACA,IAAAqZ,EAAAF,EAAAnZ,GACAnB,EAAA,EAAAua,EAAApZ,GAMA,OAJAqZ,IACAxa,GAAAmB,EAAAnB,GAAA,IAGA,GAAAmB,EAAAnB,EAAA,QAAAmB,EAAAnB,EAAA,KAGAP,EAAA,SAAA0B,GACA,IAAAvB,EAAA,GACA4a,EAAAF,EAAAnZ,GACAsZ,EAAA,EAAAF,EAAApZ,GAWA,GATAqZ,IACAC,GAAAtZ,EAAAsZ,GAAA,GAQA,EAAAtZ,EAAAsZ,EAAA,IAIA,IAAAja,EAAAC,EAAAC,EAEAF,GAAA,GAAAW,EAAAsZ,EAAA,OAAAtZ,EAAAsZ,EAAA,GACAha,EAAA,EAAAD,EAAA,EAIAE,GAAA,GAAAS,EAAAsZ,EAAA,QAAAtZ,EAAAsZ,EAAA,IAGA,IAAAza,EAAA,GAAAU,EACA,MAAAV,EAAAS,EAAA,CACA,IAAAmC,EAAA6X,EAAAza,EAEAJ,GAAA,GAAAuB,EAAAyB,EAAA,OAAAzB,EAAAyB,EAAA,IAAAzB,EAAAyB,GAIA5C,GAAA,OAAAmB,EAAAyB,EAAA,OAAAzB,EAAAyB,EAAA,IAEA,OAAAhD,IAGA8a,EAAA,SAAAvZ,EAAAvB,GACA,IAAAmB,EAAAsZ,EAAAlZ,GACAjB,EAAAN,EAAAmB,GACA,OAAAb,GACA,KAAAjC,EAAA+C,iBACA,cACA,KAAA/C,EAAAgD,iBACA,cACA,KAAAhD,EAAAiD,qBACA,uBACA,QACA,cAIAyZ,EAAA,SAAAxZ,GACA,IAAAqZ,EAAAF,EAAAnZ,GACA,IAAAqZ,EACA,YAGA,IAAAxa,EAAA,EAAAua,EAAApZ,GAEA,GAAAnB,GAAAmB,EAAAjC,WAWA,YAGA,IACA+C,EADAD,EAAA,KAuCA,OAjCAC,EAAAd,EAAAnB,EAAA,GAUA,IAAAiC,IACAD,EAAA,GAIAA,EAAAI,KAAA,GAAAjB,EAAAnB,EAAA,SACA,IAAAmB,EAAAnB,EAAA,UACA,IAAAmB,EAAAnB,EAAA,UACA,IAAAmB,EAAAnB,EAAA,SACA,IAAAmB,EAAAnB,EAAA,SACAgC,EAAAI,KAAA,EACAJ,EAAAI,MAAA,EAAAjB,EAAAnB,EAAA,SACAgC,EAAAK,IAAAL,EAAAI,IACA,GAAAH,IACAD,EAAAK,KAAA,GAAAlB,EAAAnB,EAAA,UACA,IAAAmB,EAAAnB,EAAA,UACA,IAAAmB,EAAAnB,EAAA,UACA,IAAAmB,EAAAnB,EAAA,SACA,IAAAmB,EAAAnB,EAAA,SACAgC,EAAAK,KAAA,EACAL,EAAAK,MAAA,EAAAlB,EAAAnB,EAAA,WAGAgC,GAGA4Y,EAAA,SAAA1a,GACA,OAAAA,GACA,OACA,kDACA,OACA,iBACA,OACA,+BACA,OACA,+BACA,OACA,mCACA,QACA,cAIA2a,EAAA,SAAA1Z,GASA,IARA,IAKA2Z,EALA9a,EAAA,EAAAua,EAAApZ,GACA4Z,EAAA5Z,EAAA/B,SAAAY,GACAgb,EAAA,EACAC,EAAA,EACAC,GAAA,EAIQD,EAAAF,EAAA7b,WAAA,EAA6C+b,IACrD,OAAAF,EAAAE,EAAA,IAEAD,EAAAC,EAAA,EACA,MAIA,MAAAD,EAAAD,EAAA7b,WAGA,OAAA6b,EAAAC,IACA,OAEA,OAAAD,EAAAC,EAAA,IACAA,GAAA,EACA,MACO,OAAAD,EAAAC,EAAA,IACPA,IACA,MAGAC,EAAA,IAAAD,EAAA,IACAF,EAAAF,EAAA,GAAAG,EAAAE,EAAA,IACA,8CAAAH,IACAI,GAAA,IAKA,GACAF,UACO,IAAAD,EAAAC,MAAAD,EAAA1Z,QACP4Z,EAAAD,EAAA,EACAA,GAAA,EACA,MACA,OAEA,OAAAD,EAAAC,EAAA,IACA,IAAAD,EAAAC,EAAA,IACAA,GAAA,EACA,MAGAF,EAAAF,EAAA,GAAAG,EAAAE,EAAA,IACA,8CAAAH,IACAI,GAAA,GAEAD,EAAAD,EAAA,EACAA,GAAA,EACA,MACA,QAGAA,GAAA,EACA,MAcA,OAXAD,IAAA3b,SAAA6b,GACAD,GAAAC,EACAA,EAAA,EAEAF,KAAA7b,WAAA,IACA4b,EAAAF,EAAA,GAAAG,EAAAE,EAAA,IACA,8CAAAH,IACAI,GAAA,IAIAA,GAIAzX,EAAAC,QAAA,CACA6J,YACA/N,WACAC,WACA6a,iCACAI,eACAC,eACAE,kEClRA,IAAA/c,EAAA,WACAc,KAAAF,KAAA,WACA,IAAAyc,EAAA,GAOAvc,KAAAwY,GAAA,SAAAlX,EAAAkb,GACAD,EAAAjb,KACAib,EAAAjb,GAAA,IAEAib,EAAAjb,GAAAib,EAAAjb,GAAAgK,OAAAkR,IAQAxc,KAAAyc,IAAA,SAAAnb,EAAAkb,GACA,IAAA/M,EACA,QAAA8M,EAAAjb,KAGAmO,EAAA8M,EAAAjb,GAAAob,QAAAF,GACAD,EAAAjb,GAAAib,EAAAjb,GAAA4K,QACAqQ,EAAAjb,GAAAiF,OAAAkJ,EAAA,GACAA,GAAA,IAOAzP,KAAAS,QAAA,SAAAa,GACA,IAAAqb,EAAA3Y,EAAAvB,EAAAma,EAEA,GADAD,EAAAJ,EAAAjb,GACAqb,EAOA,OAAA9R,UAAApI,OAEA,IADAA,EAAAka,EAAAla,OACAuB,EAAA,EAAmBA,EAAAvB,IAAYuB,EAC/B2Y,EAAA3Y,GAAAjE,KAAAC,KAAA6K,UAAA,QAEO,CAGP,IAFA+R,EAAA,GACA5Y,EAAA6G,UAAApI,OACAuB,EAAA,EAAmBA,EAAA6G,UAAApI,SAAsBuB,EACzC4Y,EAAA3c,KAAA4K,UAAA7G,IAGA,IADAvB,EAAAka,EAAAla,OACAuB,EAAA,EAAmBA,EAAAvB,IAAYuB,EAC/B2Y,EAAA3Y,GAAArB,MAAA3C,KAAA4c,KAOA5c,KAAA6c,QAAA,WACAN,EAAA,MAcArd,EAAAW,UAAA0Y,KAAA,SAAAuE,GASA,OARA9c,KAAAwY,GAAA,gBAAA3V,GACAia,EAAA7c,KAAA4C,KAGA7C,KAAAwY,GAAA,gBAAArB,GACA2F,EAAApc,MAAAyW,KAGA2F,GAOA5d,EAAAW,UAAAI,KAAA,SAAA4C,GACA7C,KAAAS,QAAA,OAAAoC,IAGA3D,EAAAW,UAAAa,MAAA,SAAAyW,GACAnX,KAAAS,QAAA,OAAA0W,IAGAtS,EAAAC,QAAA5F,uCCjGA,IAAAA,EAAaC,EAAQ,QACrB4d,EAAmB5d,EAAQ,QAE3BC,EAAA,WAEAA,EAAAS,UAAAC,KAAAC,KAAAC,MAEAA,KAAAgd,gBAAA,GAEAhd,KAAAid,WAAA,CACA,IAAAvY,EAAA,KACA,IAAAA,EAAA,KACA,IAAAA,EAAA,KACA,IAAAA,EAAA,MAGA1E,KAAAsZ,QAGAtZ,KAAAid,WAAAhN,QAAA,SAAAiN,GACAA,EAAA1E,GAAA,OAAAxY,KAAAS,QAAAmY,KAAA5Y,KAAA,SACAkd,EAAA1E,GAAA,OAAAxY,KAAAS,QAAAmY,KAAA5Y,KAAA,UACGA,OAIHZ,EAAAS,UAAA,IAAAX,EACAE,EAAAS,UAAAI,KAAA,SAAA8D,GACA,IAAAoZ,EAAAC,EAAAC,EAGA,gBAAAtZ,EAAAiN,cAKAmM,EAAAJ,EAAAO,SAAAvZ,EAAAwZ,aAGAJ,EAAAK,cAAAT,EAAAU,iCAKAL,EAAAL,EAAAW,cAAAP,GAGAC,IAYA,GAAArZ,EAAAN,IAAAzD,KAAA2d,WAEA3d,KAAA4d,qBAAA,MAFA,CAIG,GAAA7Z,EAAAN,MAAAzD,KAAA2d,YAAA3d,KAAA,oBAMH,OALAA,KAAA6d,mBACA7d,KAAA6d,cAEA7d,KAAA4d,qBAAA,IAMAP,EAAAN,EAAAe,oBAAA/Z,EAAAP,IAAA4Z,GACApd,KAAAgd,gBAAAhd,KAAAgd,gBAAA1R,OAAA+R,GACArd,KAAA2d,aAAA5Z,EAAAN,MACAzD,KAAA6d,YAAA,GAEA7d,KAAA6d,cACA7d,KAAA2d,WAAA5Z,EAAAN,MAGArE,EAAAS,UAAAa,MAAA,WAEAV,KAAAgd,gBAAAva,QASAzC,KAAAgd,gBAAA/M,QAAA,SAAA8N,EAAAC,GACAD,EAAAE,aAAAD,IAIAhe,KAAAgd,gBAAAkB,KAAA,SAAArL,EAAAC,GACA,OAAAD,EAAArP,MAAAsP,EAAAtP,IACAqP,EAAAoL,aAAAnL,EAAAmL,aAEApL,EAAArP,IAAAsP,EAAAtP,MAGAxD,KAAAgd,gBAAA/M,QAAA,SAAA1N,GACAA,EAAAjB,KAAA,GAEAtB,KAAAme,qBAAA5b,IAIGvC,MAEHA,KAAAgd,gBAAAva,OAAA,EACAzC,KAAAid,WAAAhN,QAAA,SAAAiN,GACAA,EAAAxc,SACGV,OAhCHA,KAAAid,WAAAhN,QAAA,SAAAiN,GACAA,EAAAxc,SACKV,OAkCLZ,EAAAS,UAAAyZ,MAAA,WACAtZ,KAAA2d,WAAA,KACA3d,KAAA4d,qBAAA,EACA5d,KAAA6d,YAAA,EACA7d,KAAAoe,qBAAA,YACApe,KAAAid,WAAAhN,QAAA,SAAAoO,GACAA,EAAA/E,WAIAla,EAAAS,UAAAse,qBAAA,SAAA5b,GAEAvC,KAAAse,mBAAA/b,GACAvC,KAAAoe,qBAAA7b,EAAAjB,MAAA,EACGtB,KAAAue,mBAAAhc,KACHvC,KAAAoe,qBAAA7b,EAAAjB,MAAA,GAEA,OAAAtB,KAAAoe,qBAAA7b,EAAAjB,OAKAtB,KAAAid,YAAA1a,EAAAjB,MAAA,GAAAtB,KAAAoe,qBAAA7b,EAAAjB,OAAArB,KAAAsC,IAGAnD,EAAAS,UAAAye,mBAAA,SAAA/b,GACA,qBAAAA,EAAAic,SAEApf,EAAAS,UAAA0e,mBAAA,SAAAhc,GACA,qBAAAA,EAAAic,SAcA,IAAAC,EAAA,CACAC,GAAA,IACAC,GAAA,IACAC,GAAA,IACAC,GAAA,IACAC,GAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,KACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,KACAC,IAAA,IACAC,IAAA,IACAC,IAAA,KACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,KACAC,IAAA,IACAC,IAAA,GACAC,IAAA,GACAC,IAAA,KACAC,IAAA,IACAC,IAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,GACAC,IAAA,GACAC,IAAA,GACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,KACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,MAGAC,EAAA,SAAAC,GACA,cAAAA,EACA,IAEAA,EAAA5F,EAAA4F,MACAjV,OAAAC,aAAAgV,KAIAC,EAAA,GAIAC,EAAA,yCACA,oCAIAC,EAAA,WACA,IAAAhiB,EAAA,GAAAwB,EAAAsgB,EAAA,EACA,MAAAtgB,IACAxB,EAAAvC,KAAA,IAEA,OAAAuC,GAGAkC,EAAA,SAAA+f,EAAAC,GACAhgB,EAAA7E,UAAAC,KAAAC,KAAAC,MAEAA,KAAA2kB,OAAAF,GAAA,EACAzkB,KAAA4kB,aAAAF,GAAA,EAEA1kB,KAAA6kB,MAAA,SAAA7kB,KAAA2kB,QAAA,EAAA3kB,KAAA4kB,eAEA5kB,KAAA8kB,eACA9kB,KAAAsZ,QAEAtZ,KAAAC,KAAA,SAAAsC,GACA,IAAAM,EAAAkiB,EAAAC,EAAAC,EAAAhO,EAKA,GAHApU,EAAA,MAAAN,EAAAic,OAGA3b,IAAA7C,KAAAklB,kBAeA,GATA,cAAAriB,GACA7C,KAAAklB,iBAAAriB,EACKA,IAAA7C,KAAAmlB,WACLnlB,KAAAklB,iBAAA,MAGAF,EAAAniB,IAAA,EACAoiB,EAAA,IAAApiB,EAEAA,IAAA7C,KAAAmlB,SAGK,GAAAtiB,IAAA7C,KAAAolB,wBACLplB,KAAAqlB,MAAA,aAEK,GAAAxiB,IAAA7C,KAAAslB,gBAKLtlB,KAAAqlB,MAAA,QACArlB,KAAAulB,gBAAAhjB,EAAAiB,KAEAxD,KAAAwlB,eAAAjjB,EAAAiB,KAGAuhB,EAAA/kB,KAAAylB,WACAzlB,KAAAylB,WAAAzlB,KAAA0lB,cACA1lB,KAAA0lB,cAAAX,EAGA/kB,KAAA2lB,UAAApjB,EAAAiB,SAEK,GAAAX,IAAA7C,KAAA4lB,gBACL5lB,KAAA6lB,YAAA,EACA7lB,KAAA8lB,UAAAvjB,EAAAiB,UACK,GAAAX,IAAA7C,KAAA+lB,gBACL/lB,KAAA6lB,YAAA,EACA7lB,KAAA8lB,UAAAvjB,EAAAiB,UACK,GAAAX,IAAA7C,KAAAgmB,gBACLhmB,KAAA6lB,YAAA,EACA7lB,KAAA8lB,UAAAvjB,EAAAiB,UACK,GAAAX,IAAA7C,KAAAimB,iBACLjmB,KAAAulB,gBAAAhjB,EAAAiB,KACAxD,KAAAwlB,eAAAjjB,EAAAiB,KACAxD,KAAAkmB,eACAlmB,KAAA2lB,UAAApjB,EAAAiB,SAEK,GAAAX,IAAA7C,KAAAmmB,WACL,UAAAnmB,KAAAqlB,MACArlB,KAAA0lB,cAAA1lB,KAAAomB,MAAApmB,KAAA0lB,cAAA1lB,KAAAomB,MAAAla,MAAA,MAEAlM,KAAAylB,WAAAzlB,KAAAomB,MAAApmB,KAAAylB,WAAAzlB,KAAAomB,MAAAla,MAAA,WAEK,GAAArJ,IAAA7C,KAAAqmB,wBACLrmB,KAAAwlB,eAAAjjB,EAAAiB,KACAxD,KAAAylB,WAAAjB,SACK,GAAA3hB,IAAA7C,KAAAsmB,4BACLtmB,KAAA0lB,cAAAlB,SAEK,GAAA3hB,IAAA7C,KAAAumB,0BACL,YAAAvmB,KAAAqlB,QAGArlB,KAAAwlB,eAAAjjB,EAAAiB,KACAxD,KAAAylB,WAAAjB,KAEAxkB,KAAAqlB,MAAA,UACArlB,KAAA2lB,UAAApjB,EAAAiB,SAGK,GAAAxD,KAAAwmB,mBAAAxB,EAAAC,GAKLD,GAAA,EAAAA,IAAA,EACA/N,EAAAmN,EAAAY,EAAAC,GACAjlB,UAAAqlB,OAAA9iB,EAAAiB,IAAAyT,GACAjX,KAAAymB,eAGK,GAAAzmB,KAAA0mB,eAAA1B,EAAAC,GAOL,UAAAjlB,KAAAqlB,MACArlB,KAAA0lB,cAAA1lB,KAAAomB,MAAApmB,KAAA0lB,cAAA1lB,KAAAomB,MAAAla,MAAA,MAEAlM,KAAAylB,WAAAzlB,KAAAomB,MAAApmB,KAAAylB,WAAAzlB,KAAAomB,MAAAla,MAAA,MAOA8Y,GAAA,EAAAA,IAAA,EACA/N,EAAAmN,EAAAY,EAAAC,GACAjlB,UAAAqlB,OAAA9iB,EAAAiB,IAAAyT,GACAjX,KAAAymB,eAGK,GAAAzmB,KAAA2mB,aAAA3B,EAAAC,GAELjlB,KAAAulB,gBAAAhjB,EAAAiB,KAIAxD,UAAAqlB,OAAA9iB,EAAAiB,IAAA,KACAxD,KAAAymB,UAEA,SAAAxB,IACAjlB,KAAA4mB,cAAArkB,EAAAiB,IAAA,OAGA,OAAAyhB,IACAjlB,KAAA4mB,cAAArkB,EAAAiB,IAAA,YAIK,GAAAxD,KAAA6mB,oBAAA7B,EAAAC,GAKLjlB,KAAAymB,SAAA,EAAAxB,OAGK,GAAAjlB,KAAA8mB,MAAA9B,EAAAC,GAAA,CAIL,IAAA8B,EAAAxC,EAAA7H,QAAA,KAAA7Z,GAGA,WAAA7C,KAAAqlB,QAIA0B,EAAA/mB,KAAA6lB,YAAA,MACAkB,EAAA/mB,KAAA6lB,YAAA,GAGA7lB,KAAA8lB,UAAAvjB,EAAAiB,IAAAujB,IAGAA,IAAA/mB,KAAAomB,OAEApmB,KAAAulB,gBAAAhjB,EAAAiB,KACAxD,KAAAomB,KAAAW,GAIA,EAAA9B,IAAA,IAAAjlB,KAAAgnB,YAAAtK,QAAA,MACA1c,KAAA4mB,cAAArkB,EAAAiB,IAAA,OAGA,SAAAX,KAKA7C,KAAAymB,QAAA,OAAA5jB,IAAA,IAGA7C,KAAAinB,WAAAhC,IAKA,SAAAA,IACAjlB,KAAA4mB,cAAArkB,EAAAiB,IAAA,YAKKxD,KAAAknB,aAAAlC,KACL,IAAAC,IACAA,EAAA,MAEAhO,EAAAmN,EAAAY,GACA/N,GAAAmN,EAAAa,GACAjlB,UAAAqlB,OAAA9iB,EAAAiB,IAAAyT,GACAjX,KAAAymB,SAAAxP,EAAAxU,aA/LAzC,KAAAklB,iBAAA,OAqMAxgB,EAAA7E,UAAA,IAAAX,EAGAwF,EAAA7E,UAAA2lB,eAAA,SAAAhiB,GACA,IAAA2jB,EAAAnnB,KAAAylB,WAEA7V,IAAA,SAAAmX,GACA,IACA,OAAAA,EAAAK,OACO,MAAAC,GAMP,OADAC,QAAAC,MAAA,+BACA,MAIAC,KAAA,MAEAC,QAAA,iBAEAN,EAAA1kB,QACAzC,KAAAS,QAAA,QACAwS,SAAAjT,KAAA2lB,UACAxS,OAAA3P,EACAyT,KAAAkQ,EACAxjB,OAAA3D,KAAA6kB,SAQAngB,EAAA7E,UAAAyZ,MAAA,WACAtZ,KAAAqlB,MAAA,QAKArlB,KAAA0nB,QAAA,EACA1nB,KAAA2lB,UAAA,EACA3lB,KAAAylB,WAAAjB,IACAxkB,KAAA0lB,cAAAlB,IACAxkB,KAAAklB,iBAAA,KAGAllB,KAAAymB,QAAA,EACAzmB,KAAAomB,KAAA9B,EACAtkB,KAAA6lB,YAAA,EAGA7lB,KAAAgnB,YAAA,IAMAtiB,EAAA7E,UAAAilB,aAAA,WAaA,IAAA9kB,KAAA4kB,cACA5kB,KAAA2nB,MAAA,GACA3nB,KAAA4nB,KAAA,GACA5nB,KAAA6nB,UAAA,GAAA7nB,KAAA2kB,SAAA,EACA3kB,KAAA8nB,QAAA,IACG,IAAA9nB,KAAA4kB,eACH5kB,KAAA2nB,MAAA,GACA3nB,KAAA4nB,KAAA,GACA5nB,KAAA6nB,UAAA,GAAA7nB,KAAA2kB,SAAA,EACA3kB,KAAA8nB,QAAA,IAOA9nB,KAAAmlB,SAAA,EAEAnlB,KAAAolB,wBAAA,GAAAplB,KAAA6nB,SACA7nB,KAAAslB,gBAAA,GAAAtlB,KAAA6nB,SAEA7nB,KAAA4lB,gBAAA,GAAA5lB,KAAA6nB,SACA7nB,KAAA+lB,gBAAA,GAAA/lB,KAAA6nB,SACA7nB,KAAAgmB,gBAAA,GAAAhmB,KAAA6nB,SACA7nB,KAAAimB,iBAAA,GAAAjmB,KAAA6nB,SAEA7nB,KAAAumB,0BAAA,GAAAvmB,KAAA6nB,SAEA7nB,KAAAmmB,WAAA,GAAAnmB,KAAA6nB,SACA7nB,KAAAqmB,wBAAA,GAAArmB,KAAA6nB,SACA7nB,KAAAsmB,4BAAA,GAAAtmB,KAAA6nB,UAcAnjB,EAAA7E,UAAA2mB,mBAAA,SAAAxB,EAAAC,GACA,OAAAD,IAAAhlB,KAAA4nB,MAAA3C,GAAA,IAAAA,GAAA,IAcAvgB,EAAA7E,UAAA6mB,eAAA,SAAA1B,EAAAC,GACA,OAAAD,IAAAhlB,KAAA4nB,KAAA,GAAA5C,IAAAhlB,KAAA4nB,KAAA,IACA3C,GAAA,IAAAA,GAAA,IAcAvgB,EAAA7E,UAAA8mB,aAAA,SAAA3B,EAAAC,GACA,OAAAD,IAAAhlB,KAAA4nB,MAAA3C,GAAA,IAAAA,GAAA,IAcAvgB,EAAA7E,UAAAgnB,oBAAA,SAAA7B,EAAAC,GACA,OAAAD,IAAAhlB,KAAA8nB,SAAA7C,GAAA,IAAAA,GAAA,IAcAvgB,EAAA7E,UAAAinB,MAAA,SAAA9B,EAAAC,GACA,OAAAD,GAAAhlB,KAAA2nB,OAAA3C,EAAAhlB,KAAA2nB,MAAA,GACA1C,GAAA,IAAAA,GAAA,KAYAvgB,EAAA7E,UAAAonB,WAAA,SAAAhC,GACA,OAAAA,GAAA,IAAAA,GAAA,IAAAA,GAAA,IAAAA,GAAA,KAWAvgB,EAAA7E,UAAAqnB,aAAA,SAAAa,GACA,OAAAA,GAAA,IAAAA,GAAA,KAUArjB,EAAA7E,UAAAimB,UAAA,SAAAtiB,EAAAwkB,GAWA,GATA,WAAAhoB,KAAAqlB,QACArlB,KAAAomB,KAAA9B,EACAtkB,KAAAqlB,MAAA,SAEArlB,KAAAwlB,eAAAhiB,GACAxD,KAAA0lB,cAAAlB,IACAxkB,KAAAylB,WAAAjB,UAGAvjB,IAAA+mB,OAAAhoB,KAAAomB,KAEA,QAAApiB,EAAA,EAAmBA,EAAAhE,KAAA6lB,YAAsB7hB,IACzChE,KAAAylB,WAAAuC,EAAAhkB,GAAAhE,KAAAylB,WAAAzlB,KAAAomB,KAAApiB,GACAhE,KAAAylB,WAAAzlB,KAAAomB,KAAApiB,GAAA,QAIA/C,IAAA+mB,IACAA,EAAAhoB,KAAAomB,MAGApmB,KAAA0nB,QAAAM,EAAAhoB,KAAA6lB,YAAA,GAKAnhB,EAAA7E,UAAA+mB,cAAA,SAAApjB,EAAAykB,GACAjoB,KAAAgnB,YAAAhnB,KAAAgnB,YAAA1b,OAAA2c,GACA,IAAAhR,EAAAgR,EAAA1Y,OAAA,SAAA0H,EAAAgR,GACA,OAAAhR,EAAA,IAAAgR,EAAA,KACG,IACHjoB,UAAAqlB,OAAA7hB,EAAAyT,IAKAvS,EAAA7E,UAAA0lB,gBAAA,SAAA/hB,GACA,GAAAxD,KAAAgnB,YAAAvkB,OAAA,CAGA,IAAAwU,EAAAjX,KAAAgnB,YAAAkB,UAAA3Y,OAAA,SAAA0H,EAAAgR,GACA,OAAAhR,EAAA,KAAAgR,EAAA,KACG,IACHjoB,KAAAgnB,YAAA,GACAhnB,UAAAqlB,OAAA7hB,EAAAyT,KAIAvS,EAAA7E,UAAAsoB,MAAA,SAAA3kB,EAAAyT,GACA,IAAAmR,EAAApoB,KAAA0lB,cAAA1lB,KAAAomB,MAGAgC,GAAAnR,EACAjX,KAAA0lB,cAAA1lB,KAAAomB,MAAAgC,GAGA1jB,EAAA7E,UAAAwoB,OAAA,SAAA7kB,EAAAyT,GACA,IAAAmR,EAAApoB,KAAAylB,WAAAzlB,KAAAomB,MAEAgC,GAAAnR,EACAjX,KAAAylB,WAAAzlB,KAAAomB,MAAAgC,GAIA1jB,EAAA7E,UAAAqmB,aAAA,WACA,IAAAliB,EAEA,IAAAA,EAAA,EAAaA,EAAAhE,KAAA0nB,QAAkB1jB,IAC/BhE,KAAAylB,WAAAzhB,GAAA,GAEA,IAAAA,EAAAhE,KAAAomB,KAAA,EAAyBpiB,EAAAsgB,EAAA,EAAoBtgB,IAC7ChE,KAAAylB,WAAAzhB,GAAA,GAGA,IAAAA,EAAAhE,KAAA0nB,QAAwB1jB,EAAAhE,KAAAomB,KAAepiB,IACvChE,KAAAylB,WAAAzhB,GAAAhE,KAAAylB,WAAAzhB,EAAA,GAGAhE,KAAAylB,WAAAzlB,KAAAomB,MAAA,IAGA1hB,EAAA7E,UAAAyoB,QAAA,SAAA9kB,EAAAyT,GACA,IAAAmR,EAAApoB,KAAAylB,WAAAzlB,KAAAomB,MAEAgC,GAAAnR,EACAjX,KAAAylB,WAAAzlB,KAAAomB,MAAAgC,GAIAvjB,EAAAC,QAAA,CACA1F,gBACAsF,sCCjzBAI,EAAAyjB,OAAA,SAAAC,GACA,IAAAC,EAAA,GAEA,QAAAzkB,KAAAwkB,EACAA,EAAA5jB,eAAAZ,KACAykB,EAAAhmB,SAAAgmB,GAAA,KACAA,GAAAC,mBAAA1kB,GAAA,IAAA0kB,mBAAAF,EAAAxkB,KAIA,OAAAykB,GAUA3jB,EAAA6jB,OAAA,SAAAC,GAGA,IAFA,IAAAC,EAAA,GACAC,EAAAF,EAAAG,MAAA,KACA/kB,EAAA,EAAAglB,EAAAF,EAAArmB,OAAmCuB,EAAAglB,EAAOhlB,IAAA,CAC1C,IAAAilB,EAAAH,EAAA9kB,GAAA+kB,MAAA,KACAF,EAAAK,mBAAAD,EAAA,KAAAC,mBAAAD,EAAA,IAEA,OAAAJ,wCCjCA,IAEAvW,EAFApT,EAAaC,EAAQ,QAKrBgqB,EAAA,CACA,KACA,MACA,KACA,KACA,MACA,KACA,KACA,MACA,KACA,KACA,MACA,IACA,MAWA7W,EAAA,WACA,IAAA5S,EAEA4S,EAAAzS,UAAAC,KAAAC,KAAAC,MAEAA,KAAAC,KAAA,SAAAsC,GACA,IAGA6mB,EACAC,EACAC,EACAC,EACAC,EACAC,EAPAzlB,EAAA,EACA0lB,EAAA,EAQA,aAAAnnB,EAAAjB,KAAA,CAOA5B,GACA6pB,EAAA7pB,EACAA,EAAA,IAAAC,WAAA4pB,EAAAjpB,WAAAiC,EAAAM,KAAAvC,YACAZ,EAAAa,IAAAgpB,GACA7pB,EAAAa,IAAAgC,EAAAM,KAAA0mB,EAAAjpB,aAEAZ,EAAA6C,EAAAM,KAKA,MAAAmB,EAAA,EAAAtE,EAAA+C,OAGA,SAAA/C,EAAAsE,IAAA,WAAAtE,EAAAsE,EAAA,KAyBA,GAhBAqlB,EAAA,MAAA3pB,EAAAsE,EAAA,IAIAolB,GAAA,EAAA1pB,EAAAsE,EAAA,QACAtE,EAAAsE,EAAA,OACA,IAAAtE,EAAAsE,EAAA,OAEAwlB,EAAA,WAAA9pB,EAAAsE,EAAA,KACAylB,EAAA,IAAAD,EACAL,GAAA,GAAAzpB,EAAAsE,EAAA,SAEAslB,EAAAtlB,EAAAolB,EAIA1pB,EAAAY,WAAAgpB,EACA,OAmBA,GAfAtpB,KAAAS,QAAA,QACA+C,IAAAjB,EAAAiB,IAAAkmB,EAAAD,EACAhmB,IAAAlB,EAAAkB,IAAAimB,EAAAD,EACAD,cACAve,gBAAA,GAAAvL,EAAAsE,EAAA,UACAmH,cAAA,EAAAzL,EAAAsE,EAAA,QACA,IAAAtE,EAAAsE,EAAA,QACAkC,WAAAijB,GAAA,GAAAzpB,EAAAsE,EAAA,SACAkH,wBAAA,GAAAxL,EAAAsE,EAAA,QAEAwI,WAAA,GACA3J,KAAAnD,EAAAc,SAAAwD,EAAA,EAAAqlB,EAAAC,KAIA5pB,EAAAY,aAAAgpB,EAEA,YADA5pB,OAAAuB,GAIAyoB,IAGAhqB,IAAAc,SAAA8oB,QAlDAtlB,MAqDAhE,KAAAU,MAAA,WACAV,KAAAS,QAAA,UAIA6R,EAAAzS,UAAA,IAAAX,EAEA2F,EAAAC,QAAAwN,sBC5HA,IAAAqX,EAAA,0OAEAC,EAAA,CACA,kIAGA/kB,EAAAC,QAAA,SAAA2jB,GACA,IAAAoB,EAAApB,EACA3V,EAAA2V,EAAA/L,QAAA,KACA2K,EAAAoB,EAAA/L,QAAA,MAEA,GAAA5J,IAAA,GAAAuU,IACAoB,IAAAqB,UAAA,EAAAhX,GAAA2V,EAAAqB,UAAAhX,EAAAuU,GAAAI,QAAA,UAAwEgB,EAAAqB,UAAAzC,EAAAoB,EAAAhmB,SAGxE,IAAAsnB,EAAAJ,EAAAK,KAAAvB,GAAA,IACAwB,EAAA,GACAjmB,EAAA,GAEA,MAAAA,IACAimB,EAAAL,EAAA5lB,IAAA+lB,EAAA/lB,IAAA,GAUA,OAPA,GAAA8O,IAAA,GAAAuU,IACA4C,EAAAC,OAAAL,EACAI,EAAAE,KAAAF,EAAAE,KAAAL,UAAA,EAAAG,EAAAE,KAAA1nB,OAAA,GAAAglB,QAAA,KAAwE,KACxEwC,EAAAG,UAAAH,EAAAG,UAAA3C,QAAA,QAAAA,QAAA,QAAAA,QAAA,KAAkF,KAClFwC,EAAAI,SAAA,GAGAJ,wCC/BA,IA6EAtlB,EA5EAzF,EAAWC,EAAQ,QACnBE,EAAgBF,EAAQ,QAGxBmrB,EAAA,SAAApqB,EAAAsT,EAAAvE,GACA,IAAAjL,EAAAxB,EAAA,GACA,IAAAwB,EAAAwP,EAAmBxP,EAAAiL,EAASjL,IAC5BxB,GAAA,UAAAtC,EAAA8D,GAAAumB,SAAA,KAAAre,OAAA,GAEA,OAAA1J,GAIAgoB,EAAA,SAAAtqB,EAAAsT,EAAAvE,GACA,OAAAia,mBAAAoB,EAAApqB,EAAAsT,EAAAvE,KAIAwb,EAAA,SAAAvqB,EAAAsT,EAAAvE,GACA,OAAAyb,SAAAJ,EAAApqB,EAAAsT,EAAAvE,KAEA0b,EAAA,SAAA9nB,GACA,OAAAA,EAAA,OACAA,EAAA,OACAA,EAAA,MACAA,EAAA,IAEA+nB,EAAA,CACAC,KAAA,SAAAC,GACA,IAAA9mB,EACA,OAAA8mB,EAAAjoB,KAAA,IAKA,IAAAmB,EAAA,EAAiBA,EAAA8mB,EAAAjoB,KAAAJ,OAAqBuB,IACtC,OAAA8mB,EAAAjoB,KAAAmB,GAAA,CAEA8mB,EAAAC,YAAAP,EAAAM,EAAAjoB,KAAA,EAAAmB,GAEA8mB,EAAA5c,MAAAsc,EAAAM,EAAAjoB,KAAAmB,EAAA,EAAA8mB,EAAAjoB,KAAAJ,QAAAglB,QAAA,WACA,MAGAqD,EAAAjoB,KAAAioB,EAAA5c,QAEA8c,KAAA,SAAAF,GACA,IAAA9mB,EACA,OAAA8mB,EAAAjoB,KAAA,GAKA,IAAAmB,EAAA,EAAiBA,EAAA8mB,EAAAjoB,KAAAJ,OAAqBuB,IACtC,OAAA8mB,EAAAjoB,KAAAmB,GAAA,CAEA8mB,EAAAC,YAAAP,EAAAM,EAAAjoB,KAAA,EAAAmB,GACA8mB,EAAAG,IAAAT,EAAAM,EAAAjoB,KAAAmB,EAAA,EAAA8mB,EAAAjoB,KAAAJ,QACA,QAIAyoB,KAAA,SAAAJ,GACA,IAAA9mB,EAEA,IAAAA,EAAA,EAAiBA,EAAA8mB,EAAAjoB,KAAAJ,OAAqBuB,IACtC,OAAA8mB,EAAAjoB,KAAAmB,GAAA,CAEA8mB,EAAAK,MAAAV,EAAAK,EAAAjoB,KAAA,EAAAmB,GACA,MAGA8mB,EAAAM,YAAAN,EAAAjoB,KAAArC,SAAAwD,EAAA,GACA8mB,EAAAjoB,KAAAioB,EAAAM,cAKAzmB,EAAA,SAAA8O,GACA,IAeAzP,EAdAqnB,EAAA,CACAC,SAAA7X,MAAA6X,OAKAC,WAAA9X,KAAA8X,YAGAC,EAAA,EAEA9rB,EAAA,GAEA+rB,EAAA,EAQA,GALA9mB,EAAA9E,UAAAC,KAAAC,KAAAC,MAIAA,KAAA4X,aAAAvY,EAAAiD,qBAAAioB,SAAA,IACAc,EAAAE,WACA,IAAAvnB,EAAA,EAAeA,EAAAqnB,EAAAE,WAAA9oB,OAAgCuB,IAC/ChE,KAAA4X,eAAA,KAAAyT,EAAAE,WAAAvnB,GAAAumB,SAAA,KAAAre,OAAA,GAIAlM,KAAAC,KAAA,SAAAyrB,GACA,IAAAZ,EAAAa,EAAAC,EAAAna,EAAAzN,EAAA6nB,EACA,sBAAAH,EAAApqB,KAaA,GANAoqB,EAAAnoB,yBACAkoB,EAAA,EACA/rB,EAAA+C,OAAA,GAIA,IAAA/C,EAAA+C,SACAipB,EAAA7oB,KAAAJ,OAAA,IACAipB,EAAA7oB,KAAA,SAAA8H,WAAA,IACA+gB,EAAA7oB,KAAA,SAAA8H,WAAA,IACA+gB,EAAA7oB,KAAA,SAAA8H,WAAA,IACA0gB,EAAAC,OAEAhE,QAAAwE,IAAA,8CAwBA,GAjBApsB,EAAAO,KAAAyrB,GACAD,GAAAC,EAAA7oB,KAAAvC,WAGA,IAAAZ,EAAA+C,SAKA+oB,EAAAb,EAAAe,EAAA7oB,KAAArC,SAAA,OAIAgrB,GAAA,MAIAC,EAAAD,GAAA,CAWA,IANAV,EAAA,CACAjoB,KAAA,IAAAlD,WAAA6rB,GACAhmB,OAAA,GACAhC,IAAA9D,EAAA,GAAA8D,IACAC,IAAA/D,EAAA,GAAA+D,KAEAO,EAAA,EAAeA,EAAAwnB,GACfV,EAAAjoB,KAAAtC,IAAAb,EAAA,GAAAmD,KAAArC,SAAA,EAAAgrB,EAAAxnB,MACAA,GAAAtE,EAAA,GAAAmD,KAAAvC,WACAmrB,GAAA/rB,EAAA,GAAAmD,KAAAvC,WACAZ,EAAAkD,QAIA+oB,EAAA,GACA,GAAAb,EAAAjoB,KAAA,KAEA8oB,GAAA,EACAA,GAAAhB,EAAAG,EAAAjoB,KAAArC,SAAA,QAGAgrB,GAAAb,EAAAG,EAAAjoB,KAAArC,SAAA,SAKA,GAGA,GADAorB,EAAAjB,EAAAG,EAAAjoB,KAAArC,SAAAmrB,EAAA,EAAAA,EAAA,IACAC,EAAA,EAEA,OAAAtE,QAAAwE,IAAA,+DAaA,GAXAD,EAAAzc,OAAAC,aAAAyb,EAAAjoB,KAAA8oB,GACAb,EAAAjoB,KAAA8oB,EAAA,GACAb,EAAAjoB,KAAA8oB,EAAA,GACAb,EAAAjoB,KAAA8oB,EAAA,IAGAla,EAAA,CACAnN,GAAAunB,EACAhpB,KAAAioB,EAAAjoB,KAAArC,SAAAmrB,EAAA,GAAAA,EAAAC,EAAA,KAEAna,EAAAsa,IAAAta,EAAAnN,GACAsmB,EAAAnZ,EAAAnN,MACAsmB,EAAAnZ,EAAAnN,IAAAmN,GAIA,iDAAAA,EAAA0Z,OAAA,CACA,IACAa,EAAAva,EAAA5O,KACAI,GAAA,EAAA+oB,EAAA,QACAA,EAAA,OACAA,EAAA,OACAA,EAAA,MACAA,EAAA,OAEA/oB,GAAA,EACAA,GAAA,EAAA+oB,EAAA,GACAva,EAAAiH,UAAAzV,OAKAhC,IAAA6pB,EAAAtnB,UAAAvC,IAAA6pB,EAAArnB,MACAqnB,EAAAtnB,IAAAiO,EAAAiH,UACAoS,EAAArnB,IAAAgO,EAAAiH,WAEA1Y,KAAAS,QAAA,YAAAgR,GAGAqZ,EAAAtlB,OAAAvF,KAAAwR,GAEAka,GAAA,GACAA,GAAAC,QACKD,EAAAH,GACLxrB,KAAAS,QAAA,OAAAqqB,MAGAnmB,EAAA9E,UAAA,IAAAX,EAEA2F,EAAAC,QAAAH,uCCrPA,IAGA4N,EAAA0Z,EACAC,EAJAhtB,EAAaC,EAAQ,QACrBsa,EAAgBta,EAAQ,QAQxB8sB,EAAA,WACA,IAEAjoB,EACAtE,EAFAysB,EAAA,EAGAF,EAAApsB,UAAAC,KAAAC,KAAAC,MASAA,KAAAC,KAAA,SAAA4C,GACA,IAAAupB,EAsBA,IApBA1sB,GAGA0sB,EAAA,IAAAzsB,WAAAD,EAAAY,WAAAuC,OAAAvC,YACA8rB,EAAA7rB,IAAAb,GACA0sB,EAAA7rB,IAAAsC,OAAAnD,EAAAY,YACAZ,EAAA0sB,GALA1sB,EAAAmD,OAmBUspB,EAAAzsB,EAAAY,WAAA,EAAmC6rB,IAC7C,OAAAzsB,EAAAysB,EAAA,IAEAnoB,EAAAmoB,EAAA,EACA,MAIA,MAAAnoB,EAAAtE,EAAAY,WAGA,OAAAZ,EAAAsE,IACA,OAEA,OAAAtE,EAAAsE,EAAA,IACAA,GAAA,EACA,MACS,OAAAtE,EAAAsE,EAAA,IACTA,IACA,MAIAmoB,EAAA,IAAAnoB,EAAA,GACAhE,KAAAS,QAAA,OAAAf,EAAAc,SAAA2rB,EAAA,EAAAnoB,EAAA,IAIA,GACAA,UACS,IAAAtE,EAAAsE,MAAAtE,EAAA+C,QACT0pB,EAAAnoB,EAAA,EACAA,GAAA,EACA,MACA,OAEA,OAAAtE,EAAAsE,EAAA,IACA,IAAAtE,EAAAsE,EAAA,IACAA,GAAA,EACA,MAIAhE,KAAAS,QAAA,OAAAf,EAAAc,SAAA2rB,EAAA,EAAAnoB,EAAA,IACAmoB,EAAAnoB,EAAA,EACAA,GAAA,EACA,MACA,QAGAA,GAAA,EACA,MAIAtE,IAAAc,SAAA2rB,GACAnoB,GAAAmoB,EACAA,EAAA,GAGAnsB,KAAAU,MAAA,WAEAhB,KAAAY,WAAA,GACAN,KAAAS,QAAA,OAAAf,EAAAc,SAAA2rB,EAAA,IAGAzsB,EAAA,KACAysB,EAAA,EACAnsB,KAAAS,QAAA,UAGAwrB,EAAApsB,UAAA,IAAAX,EAKAgtB,EAAA,CACAG,KAAA,EACAC,KAAA,EACAC,KAAA,EACAC,KAAA,EACAC,IAAA,EACAC,IAAA,EACAC,IAAA,EACAC,KAAA,EACAC,KAAA,EACAC,KAAA,EACAC,KAAA,EACAC,KAAA,GAOAza,EAAA,WACA,IAEAzR,EACAoD,EACA+oB,EACAC,EAEAC,EACAC,EACAC,EARAC,EAAA,IAAArB,EAUA1Z,EAAA1S,UAAAC,KAAAC,KAAAC,MACAc,EAAAd,KAaAA,KAAAC,KAAA,SAAAsC,GACA,UAAAA,EAAAjB,OAGA4C,EAAA3B,EAAA2B,QACA+oB,EAAA1qB,EAAAiB,IACA0pB,EAAA3qB,EAAAkB,IAEA6pB,EAAArtB,KAAAsC,KAWA+qB,EAAA9U,GAAA,gBAAA3V,GACA,IACAkB,EAAA,CACAG,UACAV,IAAAypB,EACAxpB,IAAAypB,EACArqB,QAGA,UAAAA,EAAA,IACA,OACAkB,EAAAiN,YAAA,4CACA,MACA,OACAjN,EAAAiN,YAAA,WACAjN,EAAAwZ,YAAA4P,EAAAtqB,EAAArC,SAAA,IACA,MACA,OACAuD,EAAAiN,YAAA,yBACAjN,EAAAwZ,YAAA4P,EAAAtqB,EAAArC,SAAA,IACAuD,EAAAqQ,OAAAgZ,EAAArpB,EAAAwZ,aACA,MACA,OACAxZ,EAAAiN,YAAA,yBACA,MACA,OACAjN,EAAAiN,YAAA,6BACA,MAEA,QACA,MAGAlQ,EAAAL,QAAA,OAAAsD,KAEAupB,EAAA9U,GAAA,kBACA1X,EAAAL,QAAA,UAGAT,KAAAU,MAAA,WACA4sB,EAAA5sB,SAYA2sB,EAAA,SAAAhT,EAAAkT,GACA,IAGA1b,EACA2b,EAHAC,EAAA,EACAC,EAAA,EAIA,IAAA7b,EAAA,EAAeA,EAAAwI,EAAWxI,IAC1B,IAAA6b,IACAF,EAAAD,EAAAvS,gBACA0S,GAAAD,EAAAD,EAAA,UAGAC,EAAA,IAAAC,EAAAD,EAAAC,GAYAP,EAAA,SAAAtqB,GACA,IAIA8qB,EAAAC,EAHAnrB,EAAAI,EAAAvC,WACAutB,EAAA,GACA7pB,EAAA,EAIA,MAAAA,EAAAvB,EAAA,EACA,IAAAI,EAAAmB,IAAA,IAAAnB,EAAAmB,EAAA,QAAAnB,EAAAmB,EAAA,IACA6pB,EAAA5tB,KAAA+D,EAAA,GACAA,GAAA,GAEAA,IAMA,OAAA6pB,EAAAprB,OACA,OAAAI,EAIA8qB,EAAAlrB,EAAAorB,EAAAprB,OACAmrB,EAAA,IAAAjuB,WAAAguB,GACA,IAAAG,EAAA,EAEA,IAAA9pB,EAAA,EAAeA,EAAA2pB,EAAeG,IAAA9pB,IAC9B8pB,IAAAD,EAAA,KAEAC,IAEAD,EAAAjrB,SAEAgrB,EAAA5pB,GAAAnB,EAAAirB,GAGA,OAAAF,GAYAR,EAAA,SAAAvqB,GACA,IAMA0qB,EAAAlhB,EAAAE,EAAAD,EACAyhB,EAAAC,EACAC,EAAAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAvqB,EAbAwqB,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EAkBA,GAPArB,EAAA,IAAA9T,EAAA5W,GACAwJ,EAAAkhB,EAAArS,mBACA5O,EAAAihB,EAAArS,mBACA3O,EAAAghB,EAAArS,mBACAqS,EAAA3S,wBAGAsR,EAAA7f,KACA0hB,EAAAR,EAAAzS,wBACA,IAAAiT,GACAR,EAAAnT,SAAA,GAEAmT,EAAA3S,wBACA2S,EAAA3S,wBACA2S,EAAAnT,SAAA,GACAmT,EAAAtS,eAEA,IADAoT,EAAA,IAAAN,EAAA,KACA/pB,EAAA,EAAmBA,EAAAqqB,EAAsBrqB,IACzCupB,EAAAtS,eAEAoS,EADArpB,EAAA,EACA,GAEA,GAFAupB,GAYA,GAHAA,EAAA3S,wBACAoT,EAAAT,EAAAzS,wBAEA,IAAAkT,EACAT,EAAAzS,6BACK,OAAAkT,EAKL,IAJAT,EAAAnT,SAAA,GACAmT,EAAA1S,gBACA0S,EAAA1S,gBACAoT,EAAAV,EAAAzS,wBACA9W,EAAA,EAAiBA,EAAAiqB,EAAoCjqB,IACrDupB,EAAA1S,gBAsBA,GAlBA0S,EAAA3S,wBACA2S,EAAAnT,SAAA,GAEA8T,EAAAX,EAAAzS,wBACAqT,EAAAZ,EAAAzS,wBAEAsT,EAAAb,EAAAhT,SAAA,GACA,IAAA6T,GACAb,EAAAnT,SAAA,GAGAmT,EAAAnT,SAAA,GACAmT,EAAAtS,gBACAuT,EAAAjB,EAAAzS,wBACA2T,EAAAlB,EAAAzS,wBACA4T,EAAAnB,EAAAzS,wBACA6T,EAAApB,EAAAzS,yBAEAyS,EAAAtS,eAEAsS,EAAAtS,cAAA,CAGA,OADAsT,EAAAhB,EAAArS,mBACAqT,GACA,OAAAD,EAAA,MAAoC,MACpC,OAAAA,EAAA,QAAsC,MACtC,OAAAA,EAAA,QAAsC,MACtC,OAAAA,EAAA,QAAsC,MACtC,OAAAA,EAAA,QAAsC,MACtC,OAAAA,EAAA,QAAsC,MACtC,OAAAA,EAAA,QAAsC,MACtC,OAAAA,EAAA,QAAsC,MACtC,OAAAA,EAAA,QAAsC,MACtC,QAAAA,EAAA,QAAuC,MACvC,QAAAA,EAAA,QAAuC,MACvC,QAAAA,EAAA,QAAuC,MACvC,QAAAA,EAAA,SAAwC,MACxC,QAAAA,EAAA,MAAqC,MACrC,QAAAA,EAAA,MAAqC,MACrC,QAAAA,EAAA,MAAqC,MACrC,SACAA,EAAA,CAAAf,EAAArS,oBAAA,EACAqS,EAAArS,mBACAqS,EAAArS,oBAAA,EACAqS,EAAArS,oBACA,MAGAoT,IACAM,EAAAN,EAAA,GAAAA,EAAA,IAIA,OACAjiB,aACAE,WACAD,uBACAH,MAAAhG,KAAAC,MAAA,IAAA8nB,EAAA,KAAAM,EAAA,EAAAC,GAAAG,GACAxiB,QAAA,EAAAgiB,IAAAD,EAAA,QAAAO,EAAA,EAAAC,KAKApc,EAAA1S,UAAA,IAAAX,EAEA2F,EAAAC,QAAA,CACAyN,aACA0Z,uCC3bA,IAAA7E,EAAWjoB,EAAQ,QACnB8Q,EAAc9Q,EAAQ,QACtB0vB,EAAA,SAAAC,GACA,yBAAAC,OAAAlvB,UAAA0qB,SAAAxqB,KAAA+uB,IAGAjqB,EAAAC,QAAA,SAAAkqB,GACA,IAAAA,EACA,SAEA,IAAAxsB,EAAA,GAmBA,OAjBAyN,EACAmX,EAAA4H,GAAAjG,MAAA,MACA,SAAAhC,GACA,IAAAtX,EAAAsX,EAAArK,QAAA,KACAqP,EAAA3E,EAAAL,EAAA7a,MAAA,EAAAuD,IAAAwf,cACA/gB,EAAAkZ,EAAAL,EAAA7a,MAAAuD,EAAA,IAEA,qBAAAjN,EAAAupB,GACAvpB,EAAAupB,GAAA7d,EACS2gB,EAAArsB,EAAAupB,IACTvpB,EAAAupB,GAAA9rB,KAAAiO,GAEA1L,EAAAupB,GAAA,CAAAvpB,EAAAupB,GAAA7d,KAKA1L,yBC7BA,IAAA0sB,EAAA,oBACAC,EAAA,4CACAC,EAAA,SAAA/U,GACA,IAAAxH,EAAA,GACA,MAAAwH,IACAxH,EAAA5S,KAAA,GAEA,OAAA4S,GAGAwc,EAAA,SAAAC,GACA,OAAAP,OAAAQ,KAAAD,GAAA/f,OAAA,SAAAiZ,EAAAuD,GAIA,OAHAvD,EAAAuD,GAAA,IAAApsB,WAAA2vB,EAAAvD,GAAAxc,OAAA,SAAAigB,EAAAC,GACA,OAAAD,EAAAlkB,OAAAmkB,IACK,KACLjH,GACG,KAIHzjB,EAAA,CACA2qB,MAAA,CAAAR,EAAA,SAAAE,EAAA,WACAO,MAAA,CAAAT,EAAA,MAAAE,EAAA,WACAQ,MAAA,CAAAV,EAAA,UAAAE,EAAA,WACAS,MAAA,CAAAX,EAAA,UAAAE,EAAA,kBAAAA,EAAA,WACAU,MAAA,CAAAZ,EAAA,UAAAE,EAAA,kBAAAA,EAAA,WACAW,MAAA,CAAAb,EAAA,UAAAE,EAAA,cAAAA,EAAA,YACAY,MAAA,CAAAd,EAAA,UAAAE,EAAA,kBAAAA,EAAA,eAAAA,EAAA,YACAa,MAAA,CAAAf,EAAA,UAAAE,EAAA,kBAAAA,EAAA,eAAAA,EAAA,eAAAA,EAAA,cACAc,MAAA,CAAAf,EAAAC,EAAA,iBAAAA,EAAA,iBAAAA,EAAA,kBAAAA,EAAA,kBAAAA,EAAA,WACAe,MAAA,CAAAhB,EAAAC,EAAA,iBAAAA,EAAA,iBAAAA,EAAA,kBAAAA,EAAA,kBAAAA,EAAA,kBAAAA,EAAA,YACAgB,KAAA,CAAAjB,EAAAC,EAAA,gBAAAA,EAAA,UAGAvqB,EAAAC,QAAAuqB,EAAAtqB,yBClCA,IAAAgK,EAAA,SAAAb,GACA,OAAAA,IAAA,GAGArJ,EAAAC,QAAA,CACAiK,mDCMA,IACAshB,EACAC,EAEA3hB,EAAcxP,EAAQ,QAAcwP,UACpC4hB,EAAA,SAAAhV,GACA,WAAAiV,KAAA,IAAAjV,EAAA,aAEAkV,EAAA,SAAAjlB,GACA,OACA+B,WAAA,GAAA/B,EAAA,QACAC,UAAA,EAAAD,EAAA,GACAE,cAAA,IAAAF,EAAA,QACAgC,eAAA,GAAAhC,EAAA,QACAiC,cAAA,GAAAjC,EAAA,QACAkC,gBAAA,EAAAlC,EAAA,GACAmC,oBAAAnC,EAAA,MAAAA,EAAA,KAGAklB,EAAA,SAAAC,GACA,IAGA3sB,EACAvB,EAHAmuB,EAAA,IAAA9lB,SAAA6lB,EAAAjxB,OAAAixB,EAAA5lB,WAAA4lB,EAAArwB,YACAkC,EAAA,GAGA,IAAAwB,EAAA,EAAeA,EAAA,EAAA2sB,EAAAluB,OAA0BuB,GAAAvB,EAKzC,GAJAA,EAAAmuB,EAAAtgB,UAAAtM,GACAA,GAAA,EAGAvB,GAAA,EACAD,EAAAvC,KAAA,uDAIA,UAAA0wB,EAAA3sB,IACA,OACAxB,EAAAvC,KAAA,yCACA,MACA,OACAuC,EAAAvC,KAAA,6CACA,MACA,OACAuC,EAAAvC,KAAA,YACA,MACA,OACAuC,EAAAvC,KAAA,0BACA,MACA,OACAuC,EAAAvC,KAAA,0BACA,MACA,OACAuC,EAAAvC,KAAA,8BACA,MACA,QACAuC,EAAAvC,KAAA,iBAAA0wB,EAAA3sB,GAAA,IACA,MAGA,OAAAxB,GAIAquB,EAAA,CAIAhnB,KAAA,SAAAhH,GACA,IAAA+H,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACA,OACAwwB,mBAAAlmB,EAAAmmB,UAAA,GACA5kB,MAAAvB,EAAAmmB,UAAA,IACA3kB,OAAAxB,EAAAmmB,UAAA,IACAC,gBAAApmB,EAAAmmB,UAAA,IAAAnmB,EAAAmmB,UAAA,OACAE,eAAArmB,EAAAmmB,UAAA,IAAAnmB,EAAAmmB,UAAA,OACAG,WAAAtmB,EAAAmmB,UAAA,IACAI,MAAAvmB,EAAAmmB,UAAA,IACA3c,OAAAic,EAAAxtB,EAAArC,SAAA,GAAAqC,EAAAvC,eAGAwJ,KAAA,SAAAjH,GACA,IAYAuuB,EACAC,EACAjwB,EACA4C,EAdA4G,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACAkC,EAAA,CACA8uB,qBAAAzuB,EAAA,GACA0uB,qBAAA1uB,EAAA,GACAyJ,qBAAAzJ,EAAA,GACA2uB,mBAAA3uB,EAAA,GACA4uB,mBAAA,EAAA5uB,EAAA,GACAgJ,IAAA,GACAC,IAAA,IAEA4lB,EAAA,GAAA7uB,EAAA,GAQA,IADAzB,EAAA,EACA4C,EAAA,EAAiBA,EAAA0tB,EAAgC1tB,IACjDqtB,EAAAzmB,EAAAmmB,UAAA3vB,GACAA,GAAA,EACAoB,EAAAqJ,IAAA5L,KAAA,IAAAN,WAAAkD,EAAArC,SAAAY,IAAAiwB,KACAjwB,GAAAiwB,EAKA,IAFAD,EAAAvuB,EAAAzB,GACAA,IACA4C,EAAA,EAAiBA,EAAAotB,EAA+BptB,IAChDqtB,EAAAzmB,EAAAmmB,UAAA3vB,GACAA,GAAA,EACAoB,EAAAsJ,IAAA7L,KAAA,IAAAN,WAAAkD,EAAArC,SAAAY,IAAAiwB,KACAjwB,GAAAiwB,EAEA,OAAA7uB,GAEAuH,KAAA,SAAAlH,GACA,IAAA+H,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACA,OACAqxB,aAAA/mB,EAAA0F,UAAA,GACAshB,WAAAhnB,EAAA0F,UAAA,GACAuhB,WAAAjnB,EAAA0F,UAAA,KAGA7I,KAAA,SAAA5E,GACA,OACA2M,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACAsxB,KAAAjvB,EAAA,MAAAA,EAAA,GACAkvB,eAAA,GAAAlvB,EAAA,GACAmvB,cAAA,CACAC,wBAAApvB,EAAA,IACAX,WAAAW,EAAA,WACA4oB,WAAA5oB,EAAA,QAAAA,EAAA,OAAAA,EAAA,IACA+uB,WAAA/uB,EAAA,QACAA,EAAA,QACAA,EAAA,OACAA,EAAA,IACAgvB,WAAAhvB,EAAA,QACAA,EAAA,QACAA,EAAA,OACAA,EAAA,IACAqvB,wBAAA,CACApH,IAAAjoB,EAAA,IACAJ,OAAAI,EAAA,IACAsvB,gBAAAtvB,EAAA,WACAuvB,wBAAA,EAAAvvB,EAAA,QACAA,EAAA,UACAwvB,qBAAAxvB,EAAA,eAKA6E,KAAA,SAAA7E,GACA,IACA+H,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACAkC,EAAA,CACA8vB,WAAA3jB,EAAA9L,EAAArC,SAAA,MACA+xB,aAAA3nB,EAAA0F,UAAA,GACAkiB,iBAAA,IAEAxuB,EAAA,EACA,MAAAA,EAAAnB,EAAAvC,WACAkC,EAAAgwB,iBAAAvyB,KAAA0O,EAAA9L,EAAArC,SAAAwD,IAAA,KACAA,GAAA,EAEA,OAAAxB,GAEAgF,KAAA,SAAA3E,GACA,OACA0I,MAAA8kB,EAAAxtB,KAGAmH,KAAA,SAAAnH,GACA,OACA2M,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACAiyB,eAAApC,EAAAxtB,EAAArC,SAAA,MAGA8H,KAAA,SAAAzF,GACA,IACA+H,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACAkC,EAAA,CACAgN,QAAA5E,EAAAyF,SAAA,GACA7E,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACA4P,YAAAzB,EAAA9L,EAAArC,SAAA,OACAkyB,KAAA,IAEA1uB,EAAA,EAGA,IAAAA,EAAA,GAAkBA,EAAAnB,EAAAvC,WAAqB0D,IAAA,CACvC,OAAAnB,EAAAmB,GAAA,CAEAA,IACA,MAEAxB,EAAAkwB,MAAAtjB,OAAAC,aAAAxM,EAAAmB,IAMA,OAFAxB,EAAAkwB,KAAAxJ,mBAAAyJ,OAAAnwB,EAAAkwB,OAEAlwB,GAEAmF,KAAA,SAAA9E,GACA,OACAvC,WAAAuC,EAAAvC,WACAsyB,KAAAlC,EAAA7tB,KAGAwF,KAAA,SAAAxF,GACA,IAGAgwB,EAFAjoB,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACA0D,EAAA,EAEAxB,EAAA,CACAgN,QAAA5E,EAAAyF,SAAA,GACA7E,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACAqyB,SAAA,IA4BA,OA1BA,IAAArwB,EAAAgN,SACAxL,GAAA,EACAxB,EAAAswB,aAAAvC,EAAA3lB,EAAA0F,UAAAtM,IACAA,GAAA,EACAxB,EAAAuwB,iBAAAxC,EAAA3lB,EAAA0F,UAAAtM,IACAA,GAAA,EACAxB,EAAAoM,UAAAhE,EAAA0F,UAAAtM,GACAA,GAAA,EACAxB,EAAA4E,SAAAwD,EAAA0F,UAAAtM,KAEAxB,EAAAswB,aAAAvC,EAAA3lB,EAAA0F,UAAAtM,IACAA,GAAA,EACAxB,EAAAuwB,iBAAAxC,EAAA3lB,EAAA0F,UAAAtM,IACAA,GAAA,EACAxB,EAAAoM,UAAAhE,EAAA0F,UAAAtM,GACAA,GAAA,EACAxB,EAAA4E,SAAAwD,EAAA0F,UAAAtM,IAEAA,GAAA,EAGA6uB,EAAAjoB,EAAAmmB,UAAA/sB,GACAxB,EAAAqwB,UAAAzjB,OAAAC,aAAA,IAAAwjB,GAAA,KACArwB,EAAAqwB,UAAAzjB,OAAAC,aAAA,SAAAwjB,IAAA,IACArwB,EAAAqwB,UAAAzjB,OAAAC,aAAA,OAAAwjB,IAEArwB,GAEA4F,KAAA,SAAAvF,GACA,OACA0I,MAAA8kB,EAAAxtB,KAGA+E,KAAA,SAAA/E,GACA,OACA2M,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACA4K,eAAAvI,EAAA,OACAA,EAAA,OACAA,EAAA,MACAA,EAAA,KAGAgF,KAAA,SAAAhF,GACA,OACA0I,MAAA8kB,EAAAxtB,KAMAoH,KAAA,SAAApH,GACA,IACA+H,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACAkC,EAAA,CAEAsuB,mBAAAlmB,EAAAmmB,UAAA,GAEA5lB,aAAAP,EAAAmmB,UAAA,IACAvkB,WAAA5B,EAAAmmB,UAAA,IAGA7qB,WAAA0E,EAAAmmB,UAAA,IAAAnmB,EAAAmmB,UAAA,WAQA,OAHAluB,EAAAvC,WAAA,KACAkC,EAAAwwB,iBAAA3C,EAAAxtB,EAAArC,SAAA,SAEAgC,GAEAsF,KAAA,SAAAjF,GACA,OACA0I,MAAA8kB,EAAAxtB,KAGAkF,KAAA,SAAAlF,GACA,OACA0I,MAAA8kB,EAAAxtB,KAGAmF,KAAA,SAAAnF,GACA,OACA0I,MAAA8kB,EAAAxtB,KAGAoF,KAAA,SAAApF,GACA,IACA+H,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACA0D,EAAA,EACAxB,EAAA,CACAgN,QAAA5E,EAAAyF,SAAA,GACA7E,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,OAkCA,OA/BA,IAAAgC,EAAAgN,SACAxL,GAAA,EACAxB,EAAAswB,aAAAvC,EAAA3lB,EAAA0F,UAAAtM,IACAA,GAAA,EACAxB,EAAAuwB,iBAAAxC,EAAA3lB,EAAA0F,UAAAtM,IACAA,GAAA,EACAxB,EAAAoM,UAAAhE,EAAA0F,UAAAtM,GACAA,GAAA,EACAxB,EAAA4E,SAAAwD,EAAA0F,UAAAtM,KAEAxB,EAAAswB,aAAAvC,EAAA3lB,EAAA0F,UAAAtM,IACAA,GAAA,EACAxB,EAAAuwB,iBAAAxC,EAAA3lB,EAAA0F,UAAAtM,IACAA,GAAA,EACAxB,EAAAoM,UAAAhE,EAAA0F,UAAAtM,GACAA,GAAA,EACAxB,EAAA4E,SAAAwD,EAAA0F,UAAAtM,IAEAA,GAAA,EAGAxB,EAAAywB,KAAAroB,EAAAmmB,UAAA/sB,GAAA4G,EAAAmmB,UAAA/sB,EAAA,MACAA,GAAA,EACAxB,EAAA0wB,OAAAtoB,EAAAyF,SAAArM,GAAA4G,EAAAyF,SAAArM,EAAA,KACAA,GAAA,EACAA,GAAA,EACAA,GAAA,EACAxB,EAAA2wB,OAAA,IAAAC,YAAAvwB,EAAArC,SAAAwD,IAAA,KACAA,GAAA,GACAA,GAAA,GACAxB,EAAA6wB,YAAAzoB,EAAA0F,UAAAtM,GACAxB,GAEA8wB,KAAA,SAAAzwB,GACA,IAAA+H,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACA,OACAkP,QAAA5E,EAAAyF,SAAA,GACA7E,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACAyyB,KAAAroB,EAAA0F,UAAA,GACAijB,aAAA3oB,EAAA0F,UAAA,KAGA/H,KAAA,SAAA1F,GACA,IAKSmB,EAJTxB,EAAA,CACAgN,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACA2G,QAAA,IAGA,IAAAnD,EAAA,EAAiBA,EAAAnB,EAAAvC,WAAqB0D,IACtCxB,EAAA2E,QAAAlH,KAAA,CACAwL,WAAA,GAAA5I,EAAAmB,KAAA,EACA0H,cAAA,GAAA7I,EAAAmB,KAAA,EACAwJ,cAAA,EAAA3K,EAAAmB,KAGA,OAAAxB,GAEAgxB,KAAA,SAAA3wB,GACA,IAWAmB,EAXA4G,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACAkC,EAAA,CACAgN,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACAizB,WAAA,GACAC,YAAA9oB,EAAA0F,UAAA,GACA1B,UAAAhE,EAAA0F,UAAA,GACAqjB,yBAAA/oB,EAAA0F,UAAA,IACAsjB,YAAAhpB,EAAA0F,UAAA,KAEAujB,EAAAjpB,EAAAmmB,UAAA,IAGA,IAAA/sB,EAAA,GAAkB6vB,EAAgB7vB,GAAA,GAAA6vB,IAClCrxB,EAAAixB,WAAAxzB,KAAA,CACA6zB,eAAA,IAAAjxB,EAAAmB,MAAA,EACA+vB,eAAA,WAAAnpB,EAAA0F,UAAAtM,GACAgwB,mBAAAppB,EAAA0F,UAAAtM,EAAA,GACAiwB,iBAAA,IAAApxB,EAAAmB,EAAA,IACAkwB,SAAA,IAAArxB,EAAAmB,EAAA,QACAmwB,aAAA,UAAAvpB,EAAA0F,UAAAtM,EAAA,KAIA,OAAAxB,GAEA0H,KAAA,SAAArH,GACA,OACA2M,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACA4zB,QAAAvxB,EAAA,GAAAA,EAAA,SAGA2F,KAAA,SAAA3F,GACA,OACA0I,MAAA8kB,EAAAxtB,KAGAsH,KAAA,SAAAtH,GACA,IAQAmB,EAPA4G,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACAkC,EAAA,CACAgN,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACA6zB,aAAA,IAEAC,EAAA1pB,EAAA0F,UAAA,GAEA,IAAAtM,EAAA,EAAiBswB,EAAYtwB,GAAA,EAAAswB,IAC7B9xB,EAAA6xB,aAAAp0B,KAAA2K,EAAA0F,UAAAtM,IAEA,OAAAxB,GAEA4H,KAAA,SAAAvH,GACA,IAQAmB,EAPA4G,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACAg0B,EAAA1pB,EAAA0F,UAAA,GACA9N,EAAA,CACAgN,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACA+zB,eAAA,IAGA,IAAAvwB,EAAA,EAAiBswB,EAAYtwB,GAAA,GAAAswB,IAC7B9xB,EAAA+xB,eAAAt0B,KAAA,CACAu0B,WAAA5pB,EAAA0F,UAAAtM,GACAywB,gBAAA7pB,EAAA0F,UAAAtM,EAAA,GACA0wB,uBAAA9pB,EAAA0F,UAAAtM,EAAA,KAGA,OAAAxB,GAEAiG,KAAA,SAAA5F,GACA,OACA2M,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACAm0B,mBAAAtE,EAAAxtB,EAAArC,SAAA,MAGA6J,KAAA,SAAAxH,GACA,IAQAmB,EAPA4G,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACAkC,EAAA,CACAgN,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACAo0B,WAAAhqB,EAAA0F,UAAA,GACAukB,QAAA,IAGA,IAAA7wB,EAAA,GAAkBA,EAAAnB,EAAAvC,WAAqB0D,GAAA,EACvCxB,EAAAqyB,QAAA50B,KAAA2K,EAAA0F,UAAAtM,IAEA,OAAAxB,GAEA8H,KAAA,SAAAzH,GACA,IAQAmB,EAPA4G,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACAkC,EAAA,CACAgN,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACAs0B,cAAA,IAEAR,EAAA1pB,EAAA0F,UAAA,GAGA,IAAAtM,EAAA,EAAiBswB,EAAYtwB,GAAA,EAAAswB,IAC7B9xB,EAAAsyB,cAAA70B,KAAA,CACAupB,YAAA5e,EAAA0F,UAAAtM,GACA+wB,YAAAnqB,EAAA0F,UAAAtM,EAAA,KAGA,OAAAxB,GAEA+H,KAAA,SAAA1H,GACA,OAAAguB,EAAAnpB,KAAA7E,IAEA2H,KAAA,SAAA3H,GACA,IAAAL,EAAA,CACAgN,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACA6D,oBAAAxB,EAAA,OAAAA,EAAA,OAAAA,EAAA,MAAAA,EAAA,IAMA,OAJA,IAAAL,EAAAgN,UACAhN,EAAA6B,qBAAA8B,KAAAyD,IAAA,MACApH,EAAA6B,qBAAAxB,EAAA,OAAAA,EAAA,OAAAA,EAAA,OAAAA,EAAA,KAEAL,GAEAiI,KAAA,SAAA5H,GACA,IAcAmB,EAbA4G,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACAkC,EAAA,CACAgN,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACA0D,QAAA0G,EAAA0F,UAAA,IAEA0kB,EAAA,EAAAxyB,EAAAgJ,MAAA,GACAypB,EAAA,EAAAzyB,EAAAgJ,MAAA,GACA0pB,EAAA,EAAA1yB,EAAAgJ,MAAA,GACA2pB,EAAA,GAAA3yB,EAAAgJ,MAAA,GACA4pB,EAAA,GAAA5yB,EAAAgJ,MAAA,GACA6pB,EAAA,MAAA7yB,EAAAgJ,MAAA,GACA8pB,EAAA,OAAA9yB,EAAAgJ,MAAA,GA+BA,OA5BAxH,EAAA,EACAgxB,IACAhxB,GAAA,EAEAxB,EAAAkP,eAAA9G,EAAA0F,UAAA,IACAtM,GAAA,GAEAixB,IACAzyB,EAAAkyB,uBAAA9pB,EAAA0F,UAAAtM,GACAA,GAAA,GAEAkxB,IACA1yB,EAAA+yB,sBAAA3qB,EAAA0F,UAAAtM,GACAA,GAAA,GAEAmxB,IACA3yB,EAAAgzB,kBAAA5qB,EAAA0F,UAAAtM,GACAA,GAAA,GAEAoxB,IACA5yB,EAAAizB,mBAAA7qB,EAAA0F,UAAAtM,IAEAqxB,IACA7yB,EAAA6yB,iBAAA,IAEAL,GAAAM,IACA9yB,EAAAkzB,sBAAA,GAEAlzB,GAEA2F,KAAA,SAAAtF,GACA,IACA+H,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACA0D,EAAA,EACAxB,EAAA,CACAgN,QAAA5E,EAAAyF,SAAA,GACA7E,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,OAqCA,OAnCA,IAAAgC,EAAAgN,SACAxL,GAAA,EACAxB,EAAAswB,aAAAvC,EAAA3lB,EAAA0F,UAAAtM,IACAA,GAAA,EACAxB,EAAAuwB,iBAAAxC,EAAA3lB,EAAA0F,UAAAtM,IACAA,GAAA,EACAxB,EAAA0B,QAAA0G,EAAA0F,UAAAtM,GACAA,GAAA,EACAA,GAAA,EACAxB,EAAA4E,SAAAwD,EAAA0F,UAAAtM,KAEAxB,EAAAswB,aAAAvC,EAAA3lB,EAAA0F,UAAAtM,IACAA,GAAA,EACAxB,EAAAuwB,iBAAAxC,EAAA3lB,EAAA0F,UAAAtM,IACAA,GAAA,EACAxB,EAAA0B,QAAA0G,EAAA0F,UAAAtM,GACAA,GAAA,EACAA,GAAA,EACAxB,EAAA4E,SAAAwD,EAAA0F,UAAAtM,IAEAA,GAAA,EACAA,GAAA,EACAxB,EAAAmzB,MAAA/qB,EAAAmmB,UAAA/sB,GACAA,GAAA,EACAxB,EAAAozB,eAAAhrB,EAAAmmB,UAAA/sB,GACAA,GAAA,EAEAxB,EAAA0wB,OAAAtoB,EAAAyF,SAAArM,GAAA4G,EAAAyF,SAAArM,EAAA,KACAA,GAAA,EACAA,GAAA,EACAxB,EAAA2wB,OAAA,IAAAC,YAAAvwB,EAAArC,SAAAwD,IAAA,KACAA,GAAA,GACAxB,EAAA2J,MAAAvB,EAAAmmB,UAAA/sB,GAAA4G,EAAAmmB,UAAA/sB,EAAA,MACAA,GAAA,EACAxB,EAAA4J,OAAAxB,EAAAmmB,UAAA/sB,GAAA4G,EAAAmmB,UAAA/sB,EAAA,MACAxB,GAEAkG,KAAA,SAAA7F,GACA,OACA0I,MAAA8kB,EAAAxtB,KAGAqF,KAAA,SAAArF,GACA,OACA0I,MAAA8kB,EAAAxtB,KAGA8F,KAAA,SAAA9F,GACA,IAAA+H,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACA,OACAkP,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACA0D,QAAA0G,EAAA0F,UAAA,GACAulB,8BAAAjrB,EAAA0F,UAAA,GACAilB,sBAAA3qB,EAAA0F,UAAA,IACAklB,kBAAA5qB,EAAA0F,UAAA,IACAwlB,gBAAA,EAAAjzB,EAAA,IACAkzB,oBAAA,IAAAlzB,EAAA,QACAmzB,qBAAA,GAAAnzB,EAAA,QACAozB,oBAAA,GAAApzB,EAAA,QACAqzB,4BAAA,EAAArzB,EAAA,KACAszB,0BAAAvrB,EAAAmmB,UAAA,MAGAnoB,KAAA,SAAA/F,GACA,IAgBAyK,EAfA9K,EAAA,CACAgN,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACA2G,QAAA,IAEAyD,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YAEA81B,EAAA,EAAA5zB,EAAAgJ,MAAA,GACA6qB,EAAA,EAAA7zB,EAAAgJ,MAAA,GACA8qB,EAAA,EAAA9zB,EAAAgJ,MAAA,GACA+qB,EAAA,EAAA/zB,EAAAgJ,MAAA,GACAgrB,EAAA,EAAAh0B,EAAAgJ,MAAA,GACAirB,EAAA,EAAAj0B,EAAAgJ,MAAA,GACAge,EAAA5e,EAAA0F,UAAA,GACAlP,EAAA,EAGAg1B,IAEA5zB,EAAA8E,WAAAsD,EAAA8rB,SAAAt1B,GACAA,GAAA,GAKAi1B,GAAA7M,IACAlc,EAAA,CACA9B,MAAAilB,EAAA5tB,EAAArC,SAAAY,IAAA,KAEAA,GAAA,EACAk1B,IACAhpB,EAAAlG,SAAAwD,EAAA0F,UAAAlP,GACAA,GAAA,GAEAm1B,IACAjpB,EAAArK,KAAA2H,EAAA0F,UAAAlP,GACAA,GAAA,GAEAq1B,IAEAnpB,EAAAD,sBAAAzC,EAAA0F,UAAAlP,GACAA,GAAA,GAEAoB,EAAA2E,QAAAlH,KAAAqN,GACAkc,KAGA,MAAAA,IACAlc,EAAA,GACAgpB,IACAhpB,EAAAlG,SAAAwD,EAAA0F,UAAAlP,GACAA,GAAA,GAEAm1B,IACAjpB,EAAArK,KAAA2H,EAAA0F,UAAAlP,GACAA,GAAA,GAEAo1B,IACAlpB,EAAA9B,MAAAilB,EAAA5tB,EAAArC,SAAAY,IAAA,IACAA,GAAA,GAEAq1B,IAEAnpB,EAAAD,sBAAAzC,EAAA0F,UAAAlP,GACAA,GAAA,GAEAoB,EAAA2E,QAAAlH,KAAAqN,GAEA,OAAA9K,GAEAm0B,OAAA,SAAA9zB,GACA,OACA2M,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,QAGAkK,KAAA,SAAA7H,GACA,IAAA+H,EAAA,IAAAE,SAAAjI,EAAAnD,OAAAmD,EAAAkI,WAAAlI,EAAAvC,YACA,OACAkP,QAAA3M,EAAA,GACA2I,MAAA,IAAA7L,WAAAkD,EAAArC,SAAA,MACAo2B,aAAAhsB,EAAAmmB,UAAA,GACA8F,QAAA,IAAAC,YAAA,CAAAlsB,EAAAmmB,UAAA,GACAnmB,EAAAmmB,UAAA,GACAnmB,EAAAmmB,UAAA,SAYAV,EAAA,SAAAxtB,GAaA,IAZA,IAGA+H,EACA3H,EACA3B,EACA2N,EACA1H,EANAvD,EAAA,EACAxB,EAAA,GAQAu0B,EAAA,IAAAC,YAAAn0B,EAAAJ,QACAw0B,EAAA,IAAAt3B,WAAAo3B,GACAG,EAAA,EAAiBA,EAAAr0B,EAAAJ,SAAiBy0B,EAClCD,EAAAC,GAAAr0B,EAAAq0B,GAEAtsB,EAAA,IAAAE,SAAAisB,GAEA,MAAA/yB,EAAAnB,EAAAvC,WAEA2C,EAAA2H,EAAA0F,UAAAtM,GACA1C,EAAAqN,EAAA9L,EAAArC,SAAAwD,EAAA,EAAAA,EAAA,IACAiL,EAAAhM,EAAA,EAAAe,EAAAf,EAAAJ,EAAAvC,WAGAiH,GAAAspB,EAAAvvB,IAAA,SAAAuB,GACA,OACAA,UAEKA,EAAArC,SAAAwD,EAAA,EAAAiL,IACL1H,EAAAtE,OACAsE,EAAAjG,OAGAkB,EAAAvC,KAAAsH,GACAvD,EAAAiL,EAEA,OAAAzM,GAaA8tB,EAAA,SAAA6G,EAAAhG,GACA,IAAAiG,EAKA,OAJAjG,KAAA,EACAiG,EAAA,IAAAnrB,MAAA,EAAAklB,EAAA,GAAA3J,KAAA,KAGA2P,EAAAvnB,IAAA,SAAArI,EAAAkI,GAGA,OAAA2nB,EAAA7vB,EAAAjG,KAAA,KAGAytB,OAAAQ,KAAAhoB,GAAAT,OAAA,SAAAilB,GACA,eAAAA,GAAA,UAAAA,IAGOnc,IAAA,SAAAmc,GACP,IAAAsL,EAAAD,EAAA,KAAArL,EAAA,KACA7d,EAAA3G,EAAAwkB,GAGA,GAAA7d,aAAAvO,YAAAuO,aAAAklB,YAAA,CACA,IAAAlzB,EAAA+L,MAAApM,UAAAqM,MAAAnM,KAAA,IAAAJ,WAAAuO,EAAAxO,OAAAwO,EAAAnD,WAAAmD,EAAA5N,aACAsP,IAAA,SAAA0nB,GACA,gBAAAA,EAAA/M,SAAA,KAAAre,OAAA,KACesb,KAAA,IAAA+P,MAAA,YACf,OAAAr3B,EAGA,IAAAA,EAAAuC,OACA40B,EAAA,IAAAn3B,EAAAsnB,KAAA,IAAAtb,MAAA,OAEAmrB,EAAA,MAAAn3B,EAAA0P,IAAA,SAAA4nB,GACA,OAAAJ,EAAA,KAAAI,IACWhQ,KAAA,WAAA4P,EAAA,MAPXC,EAAA,KAWA,OAAAA,EACAI,KAAAC,UAAAxpB,EAAA,QACA6a,MAAA,MAAAnZ,IAAA,SAAA4nB,EAAA/nB,GACA,WAAAA,EACA+nB,EAEAJ,EAAA,KAAAI,IACehQ,KAAA,QACRA,KAAA,OAGPjgB,EAAAgE,MAAA,KAAA+kB,EAAA/oB,EAAAgE,MAAA4lB,EAAA,SACG3J,KAAA,OAGH3iB,EAAAC,QAAA,CACA6yB,QAAAtH,EACAuH,QAAAtH,EACAuH,UAAAhH,EAAArmB,KACAstB,UAAAjH,EAAAvoB,KACAyvB,UAAAlH,EAAApmB,KACAutB,UAAAnH,EAAAjoB,KACAqvB,UAAApH,EAAA2C,2CCl0BA,IAIAhhB,EAJAtT,EAAaC,EAAQ,QACrB+4B,EAAe/4B,EAAQ,QASvBqT,EAAA,WACA,IACArS,EAAA,IAAAR,WACA+Y,EAAA,EAEAlG,EAAA3S,UAAAC,KAAAC,KAAAC,MAEAA,KAAAyY,aAAA,SAAAzE,GACA0E,EAAA1E,GAGAhU,KAAAC,KAAA,SAAAC,GACA,IAGAi4B,EACAzM,EACAnpB,EACA61B,EALAxM,EAAA,EACAyM,EAAA,EAQAl4B,EAAAsC,QACA21B,EAAAj4B,EAAAsC,OACAtC,EAAA,IAAAR,WAAAO,EAAAI,WAAA83B,GACAj4B,EAAAI,IAAAJ,EAAAK,SAAA,EAAA43B,IACAj4B,EAAAI,IAAAL,EAAAk4B,IAEAj4B,EAAAD,EAGA,MAAAC,EAAAsC,OAAA41B,GAAA,EACA,GAAAl4B,EAAAk4B,KAAA,IAAA1tB,WAAA,IACAxK,EAAAk4B,EAAA,SAAA1tB,WAAA,IACAxK,EAAAk4B,EAAA,SAAA1tB,WAAA,GAwBO,cAAAxK,EAAAk4B,KACP,WAAAl4B,EAAAk4B,EAAA,IA0BAA,QA3BO,CAKP,GAAAl4B,EAAAsC,OAAA41B,EAAA,EACA,MAOA,GAJAzM,EAAAsM,EAAAI,cAAAn4B,EAAAk4B,GAIAA,EAAAzM,EAAAzrB,EAAAsC,OACA,MAGAF,EAAA,CACAjB,KAAA,QACAuB,KAAA1C,EAAAK,SAAA63B,IAAAzM,GACApoB,IAAAkV,EACAjV,IAAAiV,GAEA1Y,KAAAS,QAAA,OAAA8B,GACA81B,GAAAzM,MAlDA,CAMA,GAAAzrB,EAAAsC,OAAA41B,EAAA,GACA,MASA,GALAzM,EAAAsM,EAAAK,gBAAAp4B,EAAAk4B,GAKAA,EAAAzM,EAAAzrB,EAAAsC,OACA,MAEAipB,EAAA,CACApqB,KAAA,iBACAuB,KAAA1C,EAAAK,SAAA63B,IAAAzM,IAEA5rB,KAAAS,QAAA,OAAAirB,GACA2M,GAAAzM,EA+BAuM,EAAAh4B,EAAAsC,OAAA41B,EAGAl4B,EADAg4B,EAAA,EACAh4B,EAAAK,SAAA63B,GAEA,IAAA14B,aAKA6S,EAAA3S,UAAA,IAAAX,EAEA2F,EAAAC,QAAA0N,qCC7GA,IAAA2a,EAAsChuB,EAAQ,QAAgCguB,gCAC9E/tB,EAAoBD,EAAQ,QAAwBC,cACpDoR,EAAYrR,EAAQ,QACpBw4B,EAAcx4B,EAAQ,QAYtBq5B,EAAA,SAAAp3B,EAAA+F,GAGA,IAFA,IAAAsxB,EAAAr3B,EAEA4C,EAAA,EAAiBA,EAAAmD,EAAA1E,OAAoBuB,IAAA,CACrC,IAAAsJ,EAAAnG,EAAAnD,GAEA,GAAAy0B,EAAAnrB,EAAArK,KACA,OAAAqK,EAGAmrB,GAAAnrB,EAAArK,KAGA,aAiBAy1B,EAAA,SAAA/H,EAAAxpB,EAAAjD,GACA,IAGAy0B,EACA30B,EACAvB,EACAm2B,EALAhI,EAAA,IAAA9lB,SAAA6lB,EAAAjxB,OAAAixB,EAAA5lB,WAAA4lB,EAAArwB,YACAkC,EAAA,GAMA,IAAAwB,EAAA,EAAaA,EAAA,EAAA2sB,EAAAluB,OAA0BuB,GAAAvB,EAKvC,GAJAA,EAAAmuB,EAAAtgB,UAAAtM,GACAA,GAAA,IAGAvB,GAAA,GAIA,UAAAkuB,EAAA3sB,IACA,OACA,IAAAnB,EAAA8tB,EAAAnwB,SAAAwD,EAAA,EAAAA,EAAA,EAAAvB,GACAo2B,EAAAL,EAAAx0B,EAAAmD,GAEAwxB,EAAA,CACA3nB,YAAA,WACA/N,KAAAR,EACAI,OACA0a,YAAA4P,EAAAtqB,GACAqB,WAGA20B,GACAF,EAAAn1B,IAAAq1B,EAAAr1B,IACAm1B,EAAAl1B,IAAAo1B,EAAAp1B,IACAm1B,EAAAC,IAIAF,EAAAn1B,IAAAo1B,EAAAp1B,IACAm1B,EAAAl1B,IAAAm1B,EAAAn1B,KAGAjB,EAAAvC,KAAA04B,GACA,MACA,QACA,MAIA,OAAAn2B,GAgBAs2B,EAAA,SAAAC,EAAA10B,EAAAoG,GACA,IAAAyiB,EAAA7oB,EACAkxB,EAAA9qB,EAAA8qB,uBAAA,EACAC,EAAA/qB,EAAA+qB,mBAAA,EACAtxB,EAAAuG,EAAAvG,QACA80B,EAAA,GA6BA,OA3BAD,EAAA9oB,QAAA,SAAArH,GAIA,IAAAqwB,EAAAtB,EAAAK,UAAApvB,GACAzB,EAAA8xB,EAAA9xB,QAEAA,EAAA8I,QAAA,SAAA3C,QACArM,IAAAqM,EAAAlG,WACAkG,EAAAlG,SAAAmuB,QAEAt0B,IAAAqM,EAAArK,OACAqK,EAAArK,KAAAuyB,GAEAloB,EAAApJ,UACAoJ,EAAA7J,IAAAypB,OACAjsB,IAAAqM,EAAAD,wBACAC,EAAAD,sBAAA,GAEAC,EAAA9J,IAAA0pB,EAAA5f,EAAAD,sBAEA6f,GAAA5f,EAAAlG,WAGA4xB,IAAA1tB,OAAAnE,KAGA6xB,GAWAE,EAAA,SAAAC,EAAAC,GAEA,IAAA1pB,EAAAc,EAAA9B,QAAAyqB,EAAA,iBAEAE,EAAA7oB,EAAA9B,QAAAyqB,EAAA,UACAG,EAAA,GACAC,EAAA,GAuCA,OApCAF,EAAAppB,QAAA,SAAAtI,EAAA8H,GACA,IAAA+pB,EAAA9pB,EAAAD,GACA8pB,EAAAt5B,KAAA,CACA0H,OACAe,KAAA8wB,MAIAD,EAAAtpB,QAAA,SAAAgZ,GACA,IAUA9hB,EACAsyB,EAXA9xB,EAAAshB,EAAAthB,KACAe,EAAAugB,EAAAvgB,KACA+B,EAAA+F,EAAA9B,QAAAhG,EAAA,UAEAgxB,EAAA/B,EAAAI,UAAAttB,EAAA,IACAvG,EAAAw1B,EAAAx1B,QACAsG,EAAAgG,EAAA9B,QAAAhG,EAAA,UAEArE,EAAAmG,EAAA/H,OAAA,EAAAk1B,EAAAE,UAAArtB,EAAA,IAAAnG,oBAAA,EACA00B,EAAAvoB,EAAA9B,QAAAhG,EAAA,UAKA0wB,IAAAl1B,GAAA60B,EAAAt2B,OAAA,IACA0E,EAAA2xB,EAAAC,EAAA10B,EAAAq1B,GAEAD,EAAAf,EAAA/wB,EAAAR,EAAAjD,GAEAo1B,EAAAp1B,KACAo1B,EAAAp1B,GAAA,IAGAo1B,EAAAp1B,GAAAo1B,EAAAp1B,GAAAoH,OAAAmuB,MAIAH,GAmBAK,EAAA,SAAAR,EAAAj1B,EAAA0K,GACA,IAAA6qB,EAEA,OAAAv1B,GAIAu1B,EAAAP,EAAAC,EAAAj1B,GAEA,CACAu1B,UAAAv1B,GACA0K,cAPA,MAcAgC,EAAA,WACA,IACAuI,EAGAygB,EAEA11B,EAEA0K,EAEAirB,EAVAC,GAAA,EAgBA95B,KAAA85B,cAAA,WACA,OAAAA,GAOA95B,KAAAF,KAAA,WACAqZ,EAAA,IAAA/Z,EACA06B,GAAA,EAGA3gB,EAAAX,GAAA,gBAAAzU,GAEAA,EAAA8K,UAAA9K,EAAAkP,SAAArE,EACA7K,EAAA2T,QAAA3T,EAAAoP,OAAAvE,EAEAirB,EAAAviB,SAAArX,KAAA8D,GACA81B,EAAAtiB,eAAAxT,EAAAJ,SAAA,KASA3D,KAAA+5B,UAAA,SAAA/pB,EAAAgqB,GACA,QAAAhqB,GAAA,IAAAA,EAAAvN,QACAu3B,GAAA,kBAAAA,GACA,IAAAjL,OAAAQ,KAAAyK,GAAAv3B,UAIAyB,IAAA8L,EAAA,IACApB,IAAAorB,EAAA91B,KAaAlE,KAAA6wB,MAAA,SAAAsI,EAAAnpB,EAAAgqB,GACA,IAAAC,EAEA,IAAAj6B,KAAA85B,gBACA,YAGK,IAAA9pB,IAAAgqB,EACL,YAEK,GAAAh6B,KAAA+5B,UAAA/pB,EAAAgqB,GAGL91B,EAAA8L,EAAA,GACApB,EAAAorB,EAAA91B,QAIK,IAAAA,IAAA0K,EAEL,OADAgrB,EAAA35B,KAAAk5B,GACA,KAIA,MAAAS,EAAAn3B,OAAA,GACA,IAAAy3B,EAAAN,EAAAh3B,QAEA5C,KAAA6wB,MAAAqJ,EAAAlqB,EAAAgqB,GAKA,OAFAC,EAAAN,EAAAR,EAAAj1B,EAAA0K,GAEA,OAAAqrB,KAAAR,SAIAz5B,KAAAm6B,SAAAF,EAAAR,SAEAz5B,KAAA0D,cAEAm2B,GAPA,MAgBA75B,KAAAm6B,SAAA,SAAAvH,GACA,IAAA5yB,KAAA85B,kBAAAlH,GAAA,IAAAA,EAAAnwB,OACA,YAGAmwB,EAAA3iB,QAAA,SAAAmqB,GACAjhB,EAAAlZ,KAAAm6B,MAQAp6B,KAAA0D,YAAA,WACA,IAAA1D,KAAA85B,gBACA,YAGA3gB,EAAAzY,SAMAV,KAAAq6B,oBAAA,WACAR,EAAAviB,SAAA,GACAuiB,EAAAtiB,eAAA,IAOAvX,KAAAs6B,mBAAA,WACA,IAAAt6B,KAAA85B,gBACA,YAGA3gB,EAAAG,SAQAtZ,KAAAu6B,iBAAA,WACAv6B,KAAAq6B,sBACAr6B,KAAAs6B,sBAMAt6B,KAAAsZ,MAAA,WACAsgB,EAAA,GACA11B,EAAA,KACA0K,EAAA,KAEAirB,EAOA75B,KAAAq6B,sBANAR,EAAA,CACAviB,SAAA,GAEAC,eAAA,IAMAvX,KAAAs6B,sBAGAt6B,KAAAsZ,SAGAzU,EAAAC,QAAA8L,qCCrbA/L,EAAAC,QAAA,CACA1C,iBAAA,GACAC,iBAAA,GACAC,qBAAA,uCCHA,IAAAk4B,EACA,IAAAzL,OAAAQ,KAAA,CAEA,IAAAkL,EAAA1L,OAAAlvB,UAAA+E,eACA81B,EAAA3L,OAAAlvB,UAAA0qB,SACAoQ,EAAcx7B,EAAQ,QACtBy7B,EAAA7L,OAAAlvB,UAAAg7B,qBACAC,GAAAF,EAAA76B,KAAA,CAA0CwqB,SAAA,MAAiB,YAC3DwQ,EAAAH,EAAA76B,KAAA,aAAuD,aACvDi7B,EAAA,CACA,WACA,iBACA,UACA,iBACA,gBACA,uBACA,eAEAC,EAAA,SAAAC,GACA,IAAAC,EAAAD,EAAAE,YACA,OAAAD,KAAAt7B,YAAAq7B,GAEAG,EAAA,CACAC,mBAAA,EACAC,UAAA,EACAC,WAAA,EACAC,QAAA,EACAC,eAAA,EACAC,SAAA,EACAC,cAAA,EACAC,aAAA,EACAC,wBAAA,EACAC,uBAAA,EACAC,cAAA,EACAC,aAAA,EACAC,cAAA,EACAC,cAAA,EACAC,SAAA,EACAC,aAAA,EACAC,YAAA,EACAC,UAAA,EACAC,UAAA,EACAC,OAAA,EACAC,kBAAA,EACAC,oBAAA,EACAC,SAAA,GAEAC,EAAA,WAEA,wBAAAC,OAAsC,SACtC,QAAAC,KAAAD,OACA,IACA,IAAAzB,EAAA,IAAA0B,IAAAtC,EAAA16B,KAAA+8B,OAAAC,IAAA,OAAAD,OAAAC,IAAA,kBAAAD,OAAAC,GACA,IACA9B,EAAA6B,OAAAC,IACM,MAAA1V,GACN,UAGI,MAAAA,GACJ,SAGA,SAhBA,GAkBA2V,EAAA,SAAA9B,GAEA,wBAAA4B,SAAAD,EACA,OAAA5B,EAAAC,GAEA,IACA,OAAAD,EAAAC,GACG,MAAA7T,GACH,WAIAmT,EAAA,SAAAyC,GACA,IAAAC,EAAA,OAAAD,GAAA,kBAAAA,EACAE,EAAA,sBAAAzC,EAAA36B,KAAAk9B,GACAG,EAAAzC,EAAAsC,GACAI,EAAAH,GAAA,oBAAAxC,EAAA36B,KAAAk9B,GACAK,EAAA,GAEA,IAAAJ,IAAAC,IAAAC,EACA,UAAAG,UAAA,sCAGA,IAAAC,EAAAzC,GAAAoC,EACA,GAAAE,GAAAJ,EAAAx6B,OAAA,IAAAg4B,EAAA16B,KAAAk9B,EAAA,GACA,QAAAj5B,EAAA,EAAkBA,EAAAi5B,EAAAx6B,SAAmBuB,EACrCs5B,EAAAr9B,KAAAmP,OAAApL,IAIA,GAAAo5B,GAAAH,EAAAx6B,OAAA,EACA,QAAAoP,EAAA,EAAkBA,EAAAorB,EAAAx6B,SAAmBoP,EACrCyrB,EAAAr9B,KAAAmP,OAAAyC,SAGA,QAAA6gB,KAAAuK,EACAO,GAAA,cAAA9K,IAAA+H,EAAA16B,KAAAk9B,EAAAvK,IACA4K,EAAAr9B,KAAAmP,OAAAsjB,IAKA,GAAAoI,EAGA,IAFA,IAAA2C,EAAAT,EAAAC,GAEAF,EAAA,EAAkBA,EAAA/B,EAAAv4B,SAAsBs6B,EACxCU,GAAA,gBAAAzC,EAAA+B,KAAAtC,EAAA16B,KAAAk9B,EAAAjC,EAAA+B,KACAO,EAAAr9B,KAAA+6B,EAAA+B,IAIA,OAAAO,GAGAz4B,EAAAC,QAAA01B,qCCvHA,IAAAE,EAAA3L,OAAAlvB,UAAA0qB,SAEA1lB,EAAAC,QAAA,SAAAoJ,GACA,IAAAua,EAAAiS,EAAA36B,KAAAmO,GACAysB,EAAA,uBAAAlS,EASA,OARAkS,IACAA,EAAA,mBAAAlS,GACA,OAAAva,GACA,kBAAAA,GACA,kBAAAA,EAAAzL,QACAyL,EAAAzL,QAAA,GACA,sBAAAi4B,EAAA36B,KAAAmO,EAAAwvB,SAEA/C,sCCbA,IAAAzuB,EAAAD,MAAApM,UAAAqM,MACAyuB,EAAax7B,EAAQ,QAErBw+B,EAAA5O,OAAAQ,KACAiL,EAAAmD,EAAA,SAAAzC,GAA4C,OAAAyC,EAAAzC,IAAyB/7B,EAAQ,QAE7Ey+B,EAAA7O,OAAAQ,KAEAiL,EAAAqD,KAAA,WACA,GAAA9O,OAAAQ,KAAA,CACA,IAAAuO,EAAA,WAEA,IAAAlhB,EAAAmS,OAAAQ,KAAA1kB,WACA,OAAA+R,KAAAna,SAAAoI,UAAApI,OAHA,CAIG,KACHq7B,IACA/O,OAAAQ,KAAA,SAAA0N,GACA,OAAAtC,EAAAsC,GACAW,EAAA1xB,EAAAnM,KAAAk9B,IAEAW,EAAAX,UAIAlO,OAAAQ,KAAAiL,EAEA,OAAAzL,OAAAQ,MAAAiL,GAGA31B,EAAAC,QAAA01B,qCCrBA,IAAAn7B,EAAkBF,EAAQ,QAC1B8O,EAAqB9O,EAAQ,QAAsC8O,eACnEuC,EAAA,GACAA,EAAAutB,GAAW5+B,EAAQ,QACnBqR,EAAAwtB,IAAY7+B,EAAQ,QAGpB,IACA8+B,EAAA,IACAz+B,EAAA,IACAC,EAAA,GAMAy+B,EAAA,SAAAh+B,EAAAyB,GACA,IAGAY,EAAAjB,EAFAlB,EAAA,EACAC,EAAAb,EAGA,MAAAa,EAAAH,EAAAI,WAEA,GAAAJ,EAAAE,KAAAX,GAAAS,EAAAG,KAAAZ,EAiCAW,IACAC,QAlCA,CAKA,OAHAkC,EAAArC,EAAAM,SAAAJ,EAAAC,GACAiB,EAAAkP,EAAAutB,GAAApvB,UAAApM,EAAAZ,EAAAQ,KAEAb,GACA,UACAK,EAAAQ,MACAR,EAAAQ,IAAAqO,EAAAutB,GAAAn9B,SAAA2B,IAEA,MACA,UACAZ,EAAAw8B,QACAx8B,EAAAw8B,MAAA3tB,EAAAutB,GAAAl9B,SAAA0B,IAEA,MACA,QACA,MAIA,GAAAZ,EAAAQ,KAAAR,EAAAw8B,MACA,OAGA/9B,GAAAZ,EACAa,GAAAb,IAgBA4+B,EAAA,SAAAl+B,EAAAyB,EAAAa,GACA,IAGAD,EAAAjB,EAAA+8B,EAAAziB,EAAA0iB,EAFAl+B,EAAA,EACAC,EAAAb,EAGA++B,GAAA,EAGA,MAAAl+B,GAAAH,EAAAI,WAEA,GAAAJ,EAAAE,KAAAX,GACAS,EAAAG,KAAAZ,GAAAY,IAAAH,EAAAI,WAkCAF,IACAC,QApCA,CAMA,OAHAkC,EAAArC,EAAAM,SAAAJ,EAAAC,GACAiB,EAAAkP,EAAAutB,GAAApvB,UAAApM,EAAAZ,EAAAQ,KAEAb,GACA,UACA+8B,EAAA7tB,EAAAutB,GAAAjiB,aAAAvZ,EAAAZ,EAAAw8B,OACAviB,EAAApL,EAAAutB,GAAAriB,+BAAAnZ,GACA,UAAA87B,GAAAziB,IACA0iB,EAAA9tB,EAAAutB,GAAAhiB,aAAAxZ,GACA+7B,IACAA,EAAAh9B,KAAA,QACAkB,EAAAR,MAAA/B,KAAAq+B,GACAC,GAAA,IAGA,MACA,QACA,MAGA,GAAAA,EACA,MAGAn+B,GAAAZ,EACAa,GAAAb,EAYAa,EAAAH,EAAAI,WACAF,EAAAC,EAAAb,EACA++B,GAAA,EACA,MAAAn+B,GAAA,EAEA,GAAAF,EAAAE,KAAAX,GACAS,EAAAG,KAAAZ,GAAAY,IAAAH,EAAAI,WAkCAF,IACAC,QApCA,CAMA,OAHAkC,EAAArC,EAAAM,SAAAJ,EAAAC,GACAiB,EAAAkP,EAAAutB,GAAApvB,UAAApM,EAAAZ,EAAAQ,KAEAb,GACA,UACA+8B,EAAA7tB,EAAAutB,GAAAjiB,aAAAvZ,EAAAZ,EAAAw8B,OACAviB,EAAApL,EAAAutB,GAAAriB,+BAAAnZ,GACA,UAAA87B,GAAAziB,IACA0iB,EAAA9tB,EAAAutB,GAAAhiB,aAAAxZ,GACA+7B,IACAA,EAAAh9B,KAAA,QACAkB,EAAAR,MAAA/B,KAAAq+B,GACAC,GAAA,IAGA,MACA,QACA,MAGA,GAAAA,EACA,MAGAn+B,GAAAZ,EACAa,GAAAb,IAiBAg/B,EAAA,SAAAt+B,EAAAyB,EAAAa,GACA,IAGAD,EAAAjB,EAAA+8B,EAAAziB,EAAA0iB,EAAA7sB,EAAAzN,EAAAZ,EAFAhD,EAAA,EACAC,EAAAb,EAGA++B,GAAA,EAEAx3B,EAAA,CACAlE,KAAA,GACAI,KAAA,GAIA,MAAA5C,EAAAH,EAAAI,WAEA,GAAAJ,EAAAE,KAAAX,GAAAS,EAAAG,KAAAZ,EAwDAW,IACAC,QAzDA,CAKA,OAHAkC,EAAArC,EAAAM,SAAAJ,EAAAC,GACAiB,EAAAkP,EAAAutB,GAAApvB,UAAApM,EAAAZ,EAAAQ,KAEAb,GACA,UAGA,GAFA+8B,EAAA7tB,EAAAutB,GAAAjiB,aAAAvZ,EAAAZ,EAAAw8B,OACAviB,EAAApL,EAAAutB,GAAAriB,+BAAAnZ,GACA,UAAA87B,IACAziB,IAAA2iB,IACAD,EAAA9tB,EAAAutB,GAAAhiB,aAAAxZ,GACA+7B,IACAA,EAAAh9B,KAAA,QACAkB,EAAAT,MAAA9B,KAAAq+B,GACAC,GAAA,KAGA/7B,EAAAi8B,eAAA,CACA,GAAA7iB,GACA,IAAA7U,EAAA9D,KAAA,CACAwO,EAAA,IAAA9R,WAAAoH,EAAA9D,MACAe,EAAA,EACA,MAAA+C,EAAAlE,KAAAJ,OACAW,EAAA2D,EAAAlE,KAAAD,QACA6O,EAAAlR,IAAA6C,EAAAY,GACAA,GAAAZ,EAAA9C,WAEAkQ,EAAAutB,GAAA9hB,4BAAAxK,KACAjP,EAAAi8B,cAAAjuB,EAAAutB,GAAAhiB,aAAAtK,GACAjP,EAAAi8B,cAAAn9B,KAAA,SAEAyF,EAAA9D,KAAA,EAGA8D,EAAAlE,KAAA5C,KAAAsC,GACAwE,EAAA9D,MAAAV,EAAAjC,WAGA,MACA,QACA,MAGA,GAAAi+B,GAAA/7B,EAAAi8B,cACA,MAGAr+B,GAAAZ,EACAa,GAAAb,EAYAa,EAAAH,EAAAI,WACAF,EAAAC,EAAAb,EACA++B,GAAA,EACA,MAAAn+B,GAAA,EAEA,GAAAF,EAAAE,KAAAX,GAAAS,EAAAG,KAAAZ,EAkCAW,IACAC,QAnCA,CAKA,OAHAkC,EAAArC,EAAAM,SAAAJ,EAAAC,GACAiB,EAAAkP,EAAAutB,GAAApvB,UAAApM,EAAAZ,EAAAQ,KAEAb,GACA,UACA+8B,EAAA7tB,EAAAutB,GAAAjiB,aAAAvZ,EAAAZ,EAAAw8B,OACAviB,EAAApL,EAAAutB,GAAAriB,+BAAAnZ,GACA,UAAA87B,GAAAziB,IACA0iB,EAAA9tB,EAAAutB,GAAAhiB,aAAAxZ,GACA+7B,IACAA,EAAAh9B,KAAA,QACAkB,EAAAT,MAAA9B,KAAAq+B,GACAC,GAAA,IAGA,MACA,QACA,MAGA,GAAAA,EACA,MAGAn+B,GAAAZ,EACAa,GAAAb,IAgBAk/B,EAAA,SAAAC,EAAAC,GACA,GAAAD,EAAA38B,OAAA28B,EAAA38B,MAAAS,OAAA,CACA,IAAAo8B,EAAAD,EACA,qBAAAC,IACAA,EAAAF,EAAA38B,MAAA,GAAAyB,KAEAk7B,EAAA38B,MAAAiO,QAAA,SAAAuH,GACAA,EAAA/T,IAAAwK,EAAAuJ,EAAA/T,IAAAo7B,GACArnB,EAAAhU,IAAAyK,EAAAuJ,EAAAhU,IAAAq7B,GAEArnB,EAAAsnB,QAAAtnB,EAAA/T,IAAAw6B,EACAzmB,EAAAunB,QAAAvnB,EAAAhU,IAAAy6B,IAIA,GAAAU,EAAA58B,OAAA48B,EAAA58B,MAAAU,OAAA,CACA,IAAAu8B,EAAAJ,EAWA,GAVA,qBAAAI,IACAA,EAAAL,EAAA58B,MAAA,GAAA0B,KAEAk7B,EAAA58B,MAAAkO,QAAA,SAAAuH,GACAA,EAAA/T,IAAAwK,EAAAuJ,EAAA/T,IAAAu7B,GACAxnB,EAAAhU,IAAAyK,EAAAuJ,EAAAhU,IAAAw7B,GAEAxnB,EAAAsnB,QAAAtnB,EAAA/T,IAAAw6B,EACAzmB,EAAAunB,QAAAvnB,EAAAhU,IAAAy6B,IAEAU,EAAAF,cAAA,CACA,IAAAhtB,EAAAktB,EAAAF,cACAhtB,EAAAhO,IAAAwK,EAAAwD,EAAAhO,IAAAu7B,GACAvtB,EAAAjO,IAAAyK,EAAAwD,EAAAjO,IAAAw7B,GAEAvtB,EAAAqtB,QAAArtB,EAAAhO,IAAAw6B,EACAxsB,EAAAstB,QAAAttB,EAAAhO,IAAAw6B,KAQAgB,EAAA,SAAA/+B,GACA,IAOAqC,EANAg8B,GAAA,EACAW,EAAA,EACA1jB,EAAA,KACAxH,EAAA,KACA4X,EAAA,EACAyM,EAAA,EAGA,MAAAn4B,EAAAuC,OAAA41B,GAAA,GACA,IAAA/2B,EAAAkP,EAAAwtB,IAAArvB,UAAAzO,EAAAm4B,GACA,OAAA/2B,GACA,qBAGA,GAAApB,EAAAuC,OAAA41B,EAAA,IACAkG,GAAA,EACA,MAOA,GAJA3S,EAAApb,EAAAwtB,IAAAzF,gBAAAr4B,EAAAm4B,GAIAzM,EAAA1rB,EAAAuC,OAAA,CACA87B,GAAA,EACA,MAEA,OAAAvqB,IACAzR,EAAArC,EAAAM,SAAA63B,IAAAzM,GACA5X,EAAAxD,EAAAwtB,IAAAmB,kBAAA58B,IAEA81B,GAAAzM,EACA,MACA,YAGA,GAAA1rB,EAAAuC,OAAA41B,EAAA,GACAkG,GAAA,EACA,MAOA,GAJA3S,EAAApb,EAAAwtB,IAAA1F,cAAAp4B,EAAAm4B,GAIAzM,EAAA1rB,EAAAuC,OAAA,CACA87B,GAAA,EACA,MAEA,OAAA/iB,IACAjZ,EAAArC,EAAAM,SAAA63B,IAAAzM,GACApQ,EAAAhL,EAAAwtB,IAAAoB,gBAAA78B,IAEA28B,IACA7G,GAAAzM,EACA,MACA,QACAyM,IACA,MAEA,GAAAkG,EACA,YAGA,UAAA/iB,GAAA,OAAAxH,EACA,YAGA,IAAAqrB,EAAApB,EAAAziB,EAEAhZ,EAAA,CACAR,MAAA,CACA,CACAV,KAAA,QACAmC,IAAAuQ,EACAxQ,IAAAwQ,GAEA,CACA1S,KAAA,QACAmC,IAAAuQ,EAAA,KAAAkrB,EAAAG,EACA77B,IAAAwQ,EAAA,KAAAkrB,EAAAG,KAKA,OAAA78B,GAQA88B,EAAA,SAAAp/B,GACA,IAAAyB,EAAA,CACAQ,IAAA,KACAg8B,MAAA,MAGA37B,EAAA,GAIA,QAAAL,KAFA+7B,EAAAh+B,EAAAyB,GAEAA,EAAAw8B,MACA,GAAAx8B,EAAAw8B,MAAAv5B,eAAAzC,GAAA,CACA,IAAAb,EAAAK,EAAAw8B,MAAAh8B,GACA,OAAAb,GACA,KAAAjC,EAAA+C,iBACAI,EAAAT,MAAA,GACAy8B,EAAAt+B,EAAAyB,EAAAa,GACA,IAAAA,EAAAT,MAAAU,eACAD,EAAAT,MAEA,MACA,KAAA1C,EAAAgD,iBACAG,EAAAR,MAAA,GACAo8B,EAAAl+B,EAAAyB,EAAAa,GACA,IAAAA,EAAAR,MAAAS,eACAD,EAAAR,MAEA,MACA,QACA,OAIA,OAAAQ,GAWAm1B,EAAA,SAAAz3B,EAAA0+B,GACA,IAEAp8B,EAFA+8B,EAAA/uB,EAAAwtB,IAAAvrB,gBAAAvS,GAUA,OALAsC,EADA+8B,EACAN,EAAA/+B,GAEAo/B,EAAAp/B,GAGAsC,MAAAR,OAAAQ,EAAAT,QAIA28B,EAAAl8B,EAAAo8B,GAEAp8B,GALA,MAQAqC,EAAAC,QAAA,CACA6yB,UACAyG,qDCreA,IAAA3gB,EAAA,EACA+hB,EAAA,IAUAliB,EAAA,SAAApd,GACA,IACA8D,EAAA,EACAxB,EAAA,CACAgb,aAAA,EACAiiB,YAAA,GAEAjiB,EAAA,EACAiiB,EAAA,EAGA,MAAAz7B,EAAA9D,EAAAI,WAAA,CAEA,GAAAJ,EAAA8D,KAAAw7B,EACA,MAIA,YAAAt/B,EAAA8D,GACAwZ,GAAA,IACAxZ,IAEAwZ,GAAAtd,EAAA8D,KAGA,YAAA9D,EAAA8D,GACAy7B,GAAA,IACAz7B,IAMA,GAJAy7B,GAAAv/B,EAAA8D,MAIAxB,EAAAtB,SAAAsc,IAAAC,EAAA,CACAjb,EAAAgb,cACAhb,EAAAi9B,cACAj9B,EAAAtB,QAAAhB,EAAAM,SAAAwD,IAAAy7B,GACA,MAIAz7B,GAAAy7B,EACAjiB,EAAA,EACAiiB,EAAA,EAGA,OAAAj9B,GAIAkb,EAAA,SAAAP,GAGA,aAAAA,EAAAjc,QAAA,GACA,KAIA,MAAAic,EAAAjc,QAAA,MAAAic,EAAAjc,QAAA,IACA,KAOA,SAHAkO,OAAAC,aAAA8N,EAAAjc,QAAA,GACAic,EAAAjc,QAAA,GACAic,EAAAjc,QAAA,GACAic,EAAAjc,QAAA,IACA,KAIA,IAAAic,EAAAjc,QAAA,GACA,KAKAic,EAAAjc,QAAAV,SAAA,EAAA2c,EAAAjc,QAAAuB,OAAA,IAIAqb,EAAA,SAAAta,EAAA4Z,GACA,IAAApZ,EAAAqW,EAAAjZ,EAAAyB,EAAAsM,EAAA,GAGA,QAAAiO,EAAA,IACA,OAAAjO,EAKA,IADAkL,EAAA,GAAA+C,EAAA,GACApZ,EAAA,EAAaA,EAAAqW,EAAWrW,IACxB5C,EAAA,EAAA4C,EACAnB,EAAA,CACAvB,KAAA,EAAA8b,EAAAhc,EAAA,GACAoC,OAIA,EAAA4Z,EAAAhc,EAAA,KACAyB,EAAA2b,OAAApB,EAAAhc,EAAA,MAAAgc,EAAAhc,EAAA,GACA+N,EAAAlP,KAAA4C,IAGA,OAAAsM,GAGAge,EAAA,SAAAtqB,GACA,IAIA8qB,EAAAC,EAHAnrB,EAAAI,EAAAvC,WACAutB,EAAA,GACA7pB,EAAA,EAIA,MAAAA,EAAAvB,EAAA,EACA,IAAAI,EAAAmB,IAAA,IAAAnB,EAAAmB,EAAA,QAAAnB,EAAAmB,EAAA,IACA6pB,EAAA5tB,KAAA+D,EAAA,GACAA,GAAA,GAEAA,IAMA,OAAA6pB,EAAAprB,OACA,OAAAI,EAIA8qB,EAAAlrB,EAAAorB,EAAAprB,OACAmrB,EAAA,IAAAjuB,WAAAguB,GACA,IAAAG,EAAA,EAEA,IAAA9pB,EAAA,EAAeA,EAAA2pB,EAAeG,IAAA9pB,IAC9B8pB,IAAAD,EAAA,KAEAC,IAEAD,EAAAjrB,SAEAgrB,EAAA5pB,GAAAnB,EAAAirB,GAGA,OAAAF,GAIA/oB,EAAAC,QAAA,CACAwY,WACAI,gBACAI,sBACAqP,kCACA1P,sDCxLA,IAAAxY,EAAA,IAOAyO,EAAA,SAAAnO,EAAA1C,GACA,kBAAAA,EAAAW,WACAvC,IAAAsE,EAAAnB,kBAAAZ,MACA+B,EAAAnB,kBAAAZ,IAAAX,EAAAW,UAGAvC,IAAAsE,EAAA0B,cACA1B,EAAA0B,cAAApE,EAAAW,IAEA+B,EAAA0B,cAAAd,KAAAa,IAAAzB,EAAA0B,cAAApE,EAAAW,UAGAvC,IAAAsE,EAAAm6B,cACAn6B,EAAAm6B,cAAA78B,EAAAW,IAEA+B,EAAAm6B,cAAAv5B,KAAAE,IAAAd,EAAAm6B,cAAA78B,EAAAW,MAIA,kBAAAX,EAAAY,WACAxC,IAAAsE,EAAAnB,kBAAAX,MACA8B,EAAAnB,kBAAAX,IAAAZ,EAAAY,UAGAxC,IAAAsE,EAAAqB,cACArB,EAAAqB,cAAA/D,EAAAY,IAEA8B,EAAAqB,cAAAT,KAAAa,IAAAzB,EAAAqB,cAAA/D,EAAAY,UAGAxC,IAAAsE,EAAAo6B,cACAp6B,EAAAo6B,cAAA98B,EAAAY,IAEA8B,EAAAo6B,cAAAx5B,KAAAE,IAAAd,EAAAo6B,cAAA98B,EAAAY,OASA0Q,EAAA,SAAA5O,UACAA,EAAAqB,qBACArB,EAAAo6B,qBACAp6B,EAAA0B,qBACA1B,EAAAm6B,eAWAzrB,EAAA,SAAA1O,EAAA2O,GACA,IACA7P,EACAwL,EACAjJ,EAAArB,EAAAqB,cAyBA,OAtBAsN,IACAtN,GAAArB,EAAAnB,kBAAAX,KAKAY,EAAAkB,EAAAnB,kBAAAC,oBAGAA,GAAAuC,EAGAvC,EAAA8B,KAAAE,IAAA,EAAAhC,GAEA,UAAAkB,EAAAjE,OAGAuO,EAAAtK,EAAAW,WAAAjB,EACAZ,GAAAwL,EACAxL,EAAA8B,KAAAG,MAAAjC,IAGAA,GAGAQ,EAAAC,QAAA,CACAqP,eACAF,oCACAP,qDCzFA,IAAAyV,EAAA,CACA,KACA,MACA,KACA,KACA,MACA,KACA,KACA,MACA,KACA,KACA,MACA,IACA,MAGA1W,EAAA,SAAA5P,GACA,OAAAA,EAAA,SAAA8H,WAAA,IACA9H,EAAA,SAAA8H,WAAA,IACA9H,EAAA,SAAA8H,WAAA,IAMAggB,EAAA,SAAA9nB,GACA,OAAAA,EAAA,OACAA,EAAA,OACAA,EAAA,MACAA,EAAA,IAKAynB,EAAA,SAAApqB,EAAAsT,EAAAvE,GACA,IAAAjL,EAAAxB,EAAA,GACA,IAAAwB,EAAAwP,EAAiBxP,EAAAiL,EAASjL,IAC1BxB,GAAA,UAAAtC,EAAA8D,GAAAumB,SAAA,KAAAre,OAAA,GAEA,OAAA1J,GAKAioB,EAAA,SAAAvqB,EAAAsT,EAAAvE,GACA,OAAAyb,SAAAJ,EAAApqB,EAAAsT,EAAAvE,KAGAspB,EAAA,SAAAqH,EAAAvH,GACA,IACAwH,EAAAD,EAAAvH,EAAA,OACAuH,EAAAvH,EAAA,OACAuH,EAAAvH,EAAA,MACAuH,EAAAvH,EAAA,GACA7sB,EAAAo0B,EAAAvH,EAAA,GACAyH,GAAA,GAAAt0B,IAAA,EAEA,OAAAs0B,EACAD,EAAA,GAEAA,EAAA,IAGAvH,EAAA,SAAAsH,EAAAvH,GACA,IACA0H,GAAA,IAAAH,EAAAvH,EAAA,OACA2H,EAAAJ,EAAAvH,EAAA,MACA4H,EAAA,KAAAL,EAAAvH,EAAA,GAEA,OAAA4H,EAAAD,EAAAD,GAGApxB,EAAA,SAAAixB,EAAAvH,GACA,OAAAuH,EAAAvH,KAAA,IAAA1tB,WAAA,IACAi1B,EAAAvH,EAAA,SAAA1tB,WAAA,IACAi1B,EAAAvH,EAAA,SAAA1tB,WAAA,GACA,kBACG,EAAAi1B,EAAAvH,IACH,WAAAuH,EAAAvH,EAAA,IACA,QAEA,MAGA+G,EAAA,SAAA78B,GACA,IAAAyB,EAAA,EAEA,MAAAA,EAAA,EAAAzB,EAAAE,OAAA,CACA,SAAAF,EAAAyB,IAAA,WAAAzB,EAAAyB,EAAA,IAMA,OAAAmlB,GAAA,GAAA5mB,EAAAyB,EAAA,SAHAA,IAMA,aAGAm7B,EAAA,SAAA58B,GACA,IAAAopB,EAAAC,EAAAna,EAAAoa,EAGAF,EAAA,GACA,GAAAppB,EAAA,KAEAopB,GAAA,EACAA,GAAAhB,EAAApoB,EAAA/B,SAAA,SAKA,GAGA,GADAorB,EAAAjB,EAAApoB,EAAA/B,SAAAmrB,EAAA,EAAAA,EAAA,IACAC,EAAA,EACA,YAOA,GALAC,EAAAzc,OAAAC,aAAA9M,EAAAopB,GACAppB,EAAAopB,EAAA,GACAppB,EAAAopB,EAAA,GACAppB,EAAAopB,EAAA,IAEA,SAAAE,EAAA,CACApa,EAAAlP,EAAA/B,SAAAmrB,EAAA,GAAAA,EAAAC,EAAA,IAEA,QAAA5nB,EAAA,EAAqBA,EAAAyN,EAAAnR,WAAsB0D,IAC3C,OAAAyN,EAAAzN,GAAA,CACA,IAAAmnB,EAAAV,EAAAhZ,EAAA,EAAAzN,GACA,oDAAAmnB,EAAA,CACA,IAAAa,EAAAva,EAAAjR,SAAAwD,EAAA,GACAf,GAAA,EAAA+oB,EAAA,QACAA,EAAA,OACAA,EAAA,OACAA,EAAA,MACAA,EAAA,OAIA,OAHA/oB,GAAA,EACAA,GAAA,EAAA+oB,EAAA,GAEA/oB,EAEA,OAKA0oB,GAAA,GACAA,GAAAC,QACGD,EAAAppB,EAAAjC,YACH,aAGAuE,EAAAC,QAAA,CACA2N,kBACA8lB,kBACAD,gBACA3pB,YACAywB,kBACAD","file":"js/chunk-vendors~9c5b28f6.58eec38c.js","sourcesContent":["/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\nvar Stream = require('../utils/stream.js'),\n  CaptionStream = require('./caption-stream'),\n  StreamTypes = require('./stream-types'),\n  TimestampRolloverStream = require('./timestamp-rollover-stream').TimestampRolloverStream;\n\nvar m2tsStreamTypes = require('./stream-types.js');\n\n// object types\nvar TransportPacketStream, TransportParseStream, ElementaryStream;\n\n// constants\nvar\n  MP2T_PACKET_LENGTH = 188, // bytes\n  SYNC_BYTE = 0x47;\n\n/**\n * Splits an incoming stream of binary data into MPEG-2 Transport\n * Stream packets.\n */\nTransportPacketStream = function() {\n  var\n    buffer = new Uint8Array(MP2T_PACKET_LENGTH),\n    bytesInBuffer = 0;\n\n  TransportPacketStream.prototype.init.call(this);\n\n   // Deliver new bytes to the stream.\n\n  /**\n   * Split a stream of data into M2TS packets\n  **/\n  this.push = function(bytes) {\n    var\n      startIndex = 0,\n      endIndex = MP2T_PACKET_LENGTH,\n      everything;\n\n    // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n    if (bytesInBuffer) {\n      everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n      everything.set(buffer.subarray(0, bytesInBuffer));\n      everything.set(bytes, bytesInBuffer);\n      bytesInBuffer = 0;\n    } else {\n      everything = bytes;\n    }\n\n    // While we have enough data for a packet\n    while (endIndex < everything.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (everything[startIndex] === SYNC_BYTE && everything[endIndex] === SYNC_BYTE) {\n        // We found a packet so emit it and jump one whole packet forward in\n        // the stream\n        this.trigger('data', everything.subarray(startIndex, endIndex));\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      }\n      // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n      startIndex++;\n      endIndex++;\n    }\n\n    // If there was some data left over at the end of the segment that couldn't\n    // possibly be a whole packet, keep it because it might be the start of a packet\n    // that continues in the next segment\n    if (startIndex < everything.byteLength) {\n      buffer.set(everything.subarray(startIndex), 0);\n      bytesInBuffer = everything.byteLength - startIndex;\n    }\n  };\n\n  /**\n   * Passes identified M2TS packets to the TransportParseStream to be parsed\n  **/\n  this.flush = function() {\n    // If the buffer contains a whole packet when we are being flushed, emit it\n    // and empty the buffer. Otherwise hold onto the data because it may be\n    // important for decoding the next segment\n    if (bytesInBuffer === MP2T_PACKET_LENGTH && buffer[0] === SYNC_BYTE) {\n      this.trigger('data', buffer);\n      bytesInBuffer = 0;\n    }\n    this.trigger('done');\n  };\n};\nTransportPacketStream.prototype = new Stream();\n\n/**\n * Accepts an MP2T TransportPacketStream and emits data events with parsed\n * forms of the individual transport stream packets.\n */\nTransportParseStream = function() {\n  var parsePsi, parsePat, parsePmt, self;\n  TransportParseStream.prototype.init.call(this);\n  self = this;\n\n  this.packetsWaitingForPmt = [];\n  this.programMapTable = undefined;\n\n  parsePsi = function(payload, psi) {\n    var offset = 0;\n\n    // PSI packets may be split into multiple sections and those\n    // sections may be split into multiple packets. If a PSI\n    // section starts in this packet, the payload_unit_start_indicator\n    // will be true and the first byte of the payload will indicate\n    // the offset from the current position to the start of the\n    // section.\n    if (psi.payloadUnitStartIndicator) {\n      offset += payload[offset] + 1;\n    }\n\n    if (psi.type === 'pat') {\n      parsePat(payload.subarray(offset), psi);\n    } else {\n      parsePmt(payload.subarray(offset), psi);\n    }\n  };\n\n  parsePat = function(payload, pat) {\n    pat.section_number = payload[7]; // eslint-disable-line camelcase\n    pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n\n    // skip the PSI header and parse the first PMT entry\n    self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n    pat.pmtPid = self.pmtPid;\n  };\n\n  /**\n   * Parse out the relevant fields of a Program Map Table (PMT).\n   * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n   * packet. The first byte in this array should be the table_id\n   * field.\n   * @param pmt {object} the object that should be decorated with\n   * fields parsed from the PMT.\n   */\n  parsePmt = function(payload, pmt) {\n    var sectionLength, tableEnd, programInfoLength, offset;\n\n    // PMTs can be sent ahead of the time when they should actually\n    // take effect. We don't believe this should ever be the case\n    // for HLS but we'll ignore \"forward\" PMT declarations if we see\n    // them. Future PMT declarations have the current_next_indicator\n    // set to zero.\n    if (!(payload[5] & 0x01)) {\n      return;\n    }\n\n    // overwrite any existing program map table\n    self.programMapTable = {\n      video: null,\n      audio: null,\n      'timed-metadata': {}\n    };\n\n    // the mapping table ends at the end of the current section\n    sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n    tableEnd = 3 + sectionLength - 4;\n\n    // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n    programInfoLength = (payload[10] & 0x0f) << 8 | payload[11];\n\n    // advance the offset to the first entry in the mapping table\n    offset = 12 + programInfoLength;\n    while (offset < tableEnd) {\n      var streamType = payload[offset];\n      var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2];\n\n      // only map a single elementary_pid for audio and video stream types\n      // TODO: should this be done for metadata too? for now maintain behavior of\n      //       multiple metadata streams\n      if (streamType === StreamTypes.H264_STREAM_TYPE &&\n          self.programMapTable.video === null) {\n        self.programMapTable.video = pid;\n      } else if (streamType === StreamTypes.ADTS_STREAM_TYPE &&\n                 self.programMapTable.audio === null) {\n        self.programMapTable.audio = pid;\n      } else if (streamType === StreamTypes.METADATA_STREAM_TYPE) {\n        // map pid to stream type for metadata streams\n        self.programMapTable['timed-metadata'][pid] = streamType;\n      }\n\n      // move to the next table entry\n      // skip past the elementary stream descriptors, if present\n      offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n    }\n\n    // record the map on the packet as well\n    pmt.programMapTable = self.programMapTable;\n  };\n\n  /**\n   * Deliver a new MP2T packet to the next stream in the pipeline.\n   */\n  this.push = function(packet) {\n    var\n      result = {},\n      offset = 4;\n\n    result.payloadUnitStartIndicator = !!(packet[1] & 0x40);\n\n    // pid is a 13-bit field starting at the last bit of packet[1]\n    result.pid = packet[1] & 0x1f;\n    result.pid <<= 8;\n    result.pid |= packet[2];\n\n    // if an adaption field is present, its length is specified by the\n    // fifth byte of the TS packet header. The adaptation field is\n    // used to add stuffing to PES packets that don't fill a complete\n    // TS packet, and to specify some forms of timing and control data\n    // that we do not currently use.\n    if (((packet[3] & 0x30) >>> 4) > 0x01) {\n      offset += packet[offset] + 1;\n    }\n\n    // parse the rest of the packet based on the type\n    if (result.pid === 0) {\n      result.type = 'pat';\n      parsePsi(packet.subarray(offset), result);\n      this.trigger('data', result);\n    } else if (result.pid === this.pmtPid) {\n      result.type = 'pmt';\n      parsePsi(packet.subarray(offset), result);\n      this.trigger('data', result);\n\n      // if there are any packets waiting for a PMT to be found, process them now\n      while (this.packetsWaitingForPmt.length) {\n        this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n      }\n    } else if (this.programMapTable === undefined) {\n      // When we have not seen a PMT yet, defer further processing of\n      // PES packets until one has been parsed\n      this.packetsWaitingForPmt.push([packet, offset, result]);\n    } else {\n      this.processPes_(packet, offset, result);\n    }\n  };\n\n  this.processPes_ = function(packet, offset, result) {\n    // set the appropriate stream type\n    if (result.pid === this.programMapTable.video) {\n      result.streamType = StreamTypes.H264_STREAM_TYPE;\n    } else if (result.pid === this.programMapTable.audio) {\n      result.streamType = StreamTypes.ADTS_STREAM_TYPE;\n    } else {\n      // if not video or audio, it is timed-metadata or unknown\n      // if unknown, streamType will be undefined\n      result.streamType = this.programMapTable['timed-metadata'][result.pid];\n    }\n\n    result.type = 'pes';\n    result.data = packet.subarray(offset);\n\n    this.trigger('data', result);\n  };\n\n};\nTransportParseStream.prototype = new Stream();\nTransportParseStream.STREAM_TYPES  = {\n  h264: 0x1b,\n  adts: 0x0f\n};\n\n/**\n * Reconsistutes program elementary stream (PES) packets from parsed\n * transport stream packets. That is, if you pipe an\n * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n * events will be events which capture the bytes for individual PES\n * packets plus relevant metadata that has been extracted from the\n * container.\n */\nElementaryStream = function() {\n  var\n    self = this,\n    // PES packet fragments\n    video = {\n      data: [],\n      size: 0\n    },\n    audio = {\n      data: [],\n      size: 0\n    },\n    timedMetadata = {\n      data: [],\n      size: 0\n    },\n    parsePes = function(payload, pes) {\n      var ptsDtsFlags;\n\n      // get the packet length, this will be 0 for video\n      pes.packetLength = 6 + ((payload[4] << 8) | payload[5]);\n\n      // find out if this packets starts a new keyframe\n      pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0;\n      // PES packets may be annotated with a PTS value, or a PTS value\n      // and a DTS value. Determine what combination of values is\n      // available to work with.\n      ptsDtsFlags = payload[7];\n\n      // PTS and DTS are normally stored as a 33-bit number.  Javascript\n      // performs all bitwise operations on 32-bit integers but javascript\n      // supports a much greater range (52-bits) of integer using standard\n      // mathematical operations.\n      // We construct a 31-bit value using bitwise operators over the 31\n      // most significant bits and then multiply by 4 (equal to a left-shift\n      // of 2) before we add the final 2 least significant bits of the\n      // timestamp (equal to an OR.)\n      if (ptsDtsFlags & 0xC0) {\n        // the PTS and DTS are not written out directly. For information\n        // on how they are encoded, see\n        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n        pes.pts = (payload[9] & 0x0E) << 27 |\n          (payload[10] & 0xFF) << 20 |\n          (payload[11] & 0xFE) << 12 |\n          (payload[12] & 0xFF) <<  5 |\n          (payload[13] & 0xFE) >>>  3;\n        pes.pts *= 4; // Left shift by 2\n        pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n        pes.dts = pes.pts;\n        if (ptsDtsFlags & 0x40) {\n          pes.dts = (payload[14] & 0x0E) << 27 |\n            (payload[15] & 0xFF) << 20 |\n            (payload[16] & 0xFE) << 12 |\n            (payload[17] & 0xFF) << 5 |\n            (payload[18] & 0xFE) >>> 3;\n          pes.dts *= 4; // Left shift by 2\n          pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n        }\n      }\n      // the data section starts immediately after the PES header.\n      // pes_header_data_length specifies the number of header bytes\n      // that follow the last byte of the field.\n      pes.data = payload.subarray(9 + payload[8]);\n    },\n    /**\n      * Pass completely parsed PES packets to the next stream in the pipeline\n     **/\n    flushStream = function(stream, type, forceFlush) {\n      var\n        packetData = new Uint8Array(stream.size),\n        event = {\n          type: type\n        },\n        i = 0,\n        offset = 0,\n        packetFlushable = false,\n        fragment;\n\n      // do nothing if there is not enough buffered data for a complete\n      // PES header\n      if (!stream.data.length || stream.size < 9) {\n        return;\n      }\n      event.trackId = stream.data[0].pid;\n\n      // reassemble the packet\n      for (i = 0; i < stream.data.length; i++) {\n        fragment = stream.data[i];\n\n        packetData.set(fragment.data, offset);\n        offset += fragment.data.byteLength;\n      }\n\n      // parse assembled packet's PES header\n      parsePes(packetData, event);\n\n      // non-video PES packets MUST have a non-zero PES_packet_length\n      // check that there is enough stream data to fill the packet\n      packetFlushable = type === 'video' || event.packetLength <= stream.size;\n\n      // flush pending packets if the conditions are right\n      if (forceFlush || packetFlushable) {\n        stream.size = 0;\n        stream.data.length = 0;\n      }\n\n      // only emit packets that are complete. this is to avoid assembling\n      // incomplete PES packets due to poor segmentation\n      if (packetFlushable) {\n        self.trigger('data', event);\n      }\n    };\n\n  ElementaryStream.prototype.init.call(this);\n\n  /**\n   * Identifies M2TS packet types and parses PES packets using metadata\n   * parsed from the PMT\n   **/\n  this.push = function(data) {\n    ({\n      pat: function() {\n        // we have to wait for the PMT to arrive as well before we\n        // have any meaningful metadata\n      },\n      pes: function() {\n        var stream, streamType;\n\n        switch (data.streamType) {\n        case StreamTypes.H264_STREAM_TYPE:\n        case m2tsStreamTypes.H264_STREAM_TYPE:\n          stream = video;\n          streamType = 'video';\n          break;\n        case StreamTypes.ADTS_STREAM_TYPE:\n          stream = audio;\n          streamType = 'audio';\n          break;\n        case StreamTypes.METADATA_STREAM_TYPE:\n          stream = timedMetadata;\n          streamType = 'timed-metadata';\n          break;\n        default:\n          // ignore unknown stream types\n          return;\n        }\n\n        // if a new packet is starting, we can flush the completed\n        // packet\n        if (data.payloadUnitStartIndicator) {\n          flushStream(stream, streamType, true);\n        }\n\n        // buffer this fragment until we are sure we've received the\n        // complete payload\n        stream.data.push(data);\n        stream.size += data.data.byteLength;\n      },\n      pmt: function() {\n        var\n          event = {\n            type: 'metadata',\n            tracks: []\n          },\n          programMapTable = data.programMapTable;\n\n        // translate audio and video streams to tracks\n        if (programMapTable.video !== null) {\n          event.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.video,\n            codec: 'avc',\n            type: 'video'\n          });\n        }\n        if (programMapTable.audio !== null) {\n          event.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.audio,\n            codec: 'adts',\n            type: 'audio'\n          });\n        }\n\n        self.trigger('data', event);\n      }\n    })[data.type]();\n  };\n\n  /**\n   * Flush any remaining input. Video PES packets may be of variable\n   * length. Normally, the start of a new video packet can trigger the\n   * finalization of the previous packet. That is not possible if no\n   * more video is forthcoming, however. In that case, some other\n   * mechanism (like the end of the file) has to be employed. When it is\n   * clear that no additional data is forthcoming, calling this method\n   * will flush the buffered packets.\n   */\n  this.flush = function() {\n    // !!THIS ORDER IS IMPORTANT!!\n    // video first then audio\n    flushStream(video, 'video');\n    flushStream(audio, 'audio');\n    flushStream(timedMetadata, 'timed-metadata');\n    this.trigger('done');\n  };\n};\nElementaryStream.prototype = new Stream();\n\nvar m2ts = {\n  PAT_PID: 0x0000,\n  MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH,\n  TransportPacketStream: TransportPacketStream,\n  TransportParseStream: TransportParseStream,\n  ElementaryStream: ElementaryStream,\n  TimestampRolloverStream: TimestampRolloverStream,\n  CaptionStream: CaptionStream.CaptionStream,\n  Cea608Stream: CaptionStream.Cea608Stream,\n  MetadataStream: require('./metadata-stream')\n};\n\nfor (var type in StreamTypes) {\n  if (StreamTypes.hasOwnProperty(type)) {\n    m2ts[type] = StreamTypes[type];\n  }\n}\n\nmodule.exports = m2ts;\n","var coneOfSilence = require('../data/silence');\nvar clock = require('../utils/clock');\n\nvar ONE_SECOND_IN_TS = 90000; // 90kHz clock\n\n/**\n * Sum the `byteLength` properties of the data in each AAC frame\n */\nvar sumFrameByteLengths = function(array) {\n  var\n    i,\n    currentObj,\n    sum = 0;\n\n  // sum the byteLength's all each nal unit in the frame\n  for (i = 0; i < array.length; i++) {\n    currentObj = array[i];\n    sum += currentObj.data.byteLength;\n  }\n\n  return sum;\n};\n\n// Possibly pad (prefix) the audio track with silence if appending this track\n// would lead to the introduction of a gap in the audio buffer\nvar prefixWithSilence = function(\n  track,\n  frames,\n  audioAppendStartTs,\n  videoBaseMediaDecodeTime\n) {\n  var\n    baseMediaDecodeTimeTs,\n    frameDuration = 0,\n    audioGapDuration = 0,\n    audioFillFrameCount = 0,\n    audioFillDuration = 0,\n    silentFrame,\n    i;\n\n  if (!frames.length) {\n    return;\n  }\n\n  baseMediaDecodeTimeTs =\n    clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);\n  // determine frame clock duration based on sample rate, round up to avoid overfills\n  frameDuration = Math.ceil(ONE_SECOND_IN_TS / (track.samplerate / 1024));\n\n  if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n    // insert the shortest possible amount (audio gap or audio to video gap)\n    audioGapDuration =\n      baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);\n    // number of full frames in the audio gap\n    audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n    audioFillDuration = audioFillFrameCount * frameDuration;\n  }\n\n  // don't attempt to fill gaps smaller than a single frame or larger\n  // than a half second\n  if (audioFillFrameCount < 1 || audioFillDuration > ONE_SECOND_IN_TS / 2) {\n    return;\n  }\n\n  silentFrame = coneOfSilence[track.samplerate];\n\n  if (!silentFrame) {\n    // we don't have a silent frame pregenerated for the sample rate, so use a frame\n    // from the content instead\n    silentFrame = frames[0].data;\n  }\n\n  for (i = 0; i < audioFillFrameCount; i++) {\n    frames.splice(i, 0, {\n      data: silentFrame\n    });\n  }\n\n  track.baseMediaDecodeTime -=\n    Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\n};\n\n// If the audio segment extends before the earliest allowed dts\n// value, remove AAC frames until starts at or after the earliest\n// allowed DTS so that we don't end up with a negative baseMedia-\n// DecodeTime for the audio track\nvar trimAdtsFramesByEarliestDts = function(adtsFrames, track, earliestAllowedDts) {\n  if (track.minSegmentDts >= earliestAllowedDts) {\n    return adtsFrames;\n  }\n\n  // We will need to recalculate the earliest segment Dts\n  track.minSegmentDts = Infinity;\n\n  return adtsFrames.filter(function(currentFrame) {\n    // If this is an allowed frame, keep it and record it's Dts\n    if (currentFrame.dts >= earliestAllowedDts) {\n      track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n      track.minSegmentPts = track.minSegmentDts;\n      return true;\n    }\n    // Otherwise, discard it\n    return false;\n  });\n};\n\n// generate the track's raw mdat data from an array of frames\nvar generateSampleTable = function(frames) {\n  var\n    i,\n    currentFrame,\n    samples = [];\n\n  for (i = 0; i < frames.length; i++) {\n    currentFrame = frames[i];\n    samples.push({\n      size: currentFrame.data.byteLength,\n      duration: 1024 // For AAC audio, all samples contain 1024 samples\n    });\n  }\n  return samples;\n};\n\n// generate the track's sample table from an array of frames\nvar concatenateFrameData = function(frames) {\n  var\n    i,\n    currentFrame,\n    dataOffset = 0,\n    data = new Uint8Array(sumFrameByteLengths(frames));\n\n  for (i = 0; i < frames.length; i++) {\n    currentFrame = frames[i];\n\n    data.set(currentFrame.data, dataOffset);\n    dataOffset += currentFrame.data.byteLength;\n  }\n  return data;\n};\n\nmodule.exports = {\n  prefixWithSilence: prefixWithSilence,\n  trimAdtsFramesByEarliestDts: trimAdtsFramesByEarliestDts,\n  generateSampleTable: generateSampleTable,\n  concatenateFrameData: concatenateFrameData\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Functions that generate fragmented MP4s suitable for use with Media\n * Source Extensions.\n */\n'use strict';\n\nvar UINT32_MAX = Math.pow(2, 32) - 1;\n\nvar box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd,\n    trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex,\n    trun, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR,\n    AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;\n\n// pre-calculate constants\n(function() {\n  var i;\n  types = {\n    avc1: [], // codingname\n    avcC: [],\n    btrt: [],\n    dinf: [],\n    dref: [],\n    esds: [],\n    ftyp: [],\n    hdlr: [],\n    mdat: [],\n    mdhd: [],\n    mdia: [],\n    mfhd: [],\n    minf: [],\n    moof: [],\n    moov: [],\n    mp4a: [], // codingname\n    mvex: [],\n    mvhd: [],\n    sdtp: [],\n    smhd: [],\n    stbl: [],\n    stco: [],\n    stsc: [],\n    stsd: [],\n    stsz: [],\n    stts: [],\n    styp: [],\n    tfdt: [],\n    tfhd: [],\n    traf: [],\n    trak: [],\n    trun: [],\n    trex: [],\n    tkhd: [],\n    vmhd: []\n  };\n\n  // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n  // don't throw an error\n  if (typeof Uint8Array === 'undefined') {\n    return;\n  }\n\n  for (i in types) {\n    if (types.hasOwnProperty(i)) {\n      types[i] = [\n        i.charCodeAt(0),\n        i.charCodeAt(1),\n        i.charCodeAt(2),\n        i.charCodeAt(3)\n      ];\n    }\n  }\n\n  MAJOR_BRAND = new Uint8Array([\n    'i'.charCodeAt(0),\n    's'.charCodeAt(0),\n    'o'.charCodeAt(0),\n    'm'.charCodeAt(0)\n  ]);\n  AVC1_BRAND = new Uint8Array([\n    'a'.charCodeAt(0),\n    'v'.charCodeAt(0),\n    'c'.charCodeAt(0),\n    '1'.charCodeAt(0)\n  ]);\n  MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n  VIDEO_HDLR = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x56, 0x69, 0x64, 0x65,\n    0x6f, 0x48, 0x61, 0x6e,\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n  ]);\n  AUDIO_HDLR = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x53, 0x6f, 0x75, 0x6e,\n    0x64, 0x48, 0x61, 0x6e,\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n  ]);\n  HDLR_TYPES = {\n    video: VIDEO_HDLR,\n    audio: AUDIO_HDLR\n  };\n  DREF = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version 0\n    0x00, 0x00, 0x01 // entry_flags\n  ]);\n  SMHD = new Uint8Array([\n    0x00,             // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00,       // balance, 0 means centered\n    0x00, 0x00        // reserved\n  ]);\n  STCO = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n  ]);\n  STSC = STCO;\n  STSZ = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n  ]);\n  STTS = STCO;\n  VMHD = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphicsmode\n    0x00, 0x00,\n    0x00, 0x00,\n    0x00, 0x00 // opcolor\n  ]);\n}());\n\nbox = function(type) {\n  var\n    payload = [],\n    size = 0,\n    i,\n    result,\n    view;\n\n  for (i = 1; i < arguments.length; i++) {\n    payload.push(arguments[i]);\n  }\n\n  i = payload.length;\n\n  // calculate the total size we need to allocate\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  result = new Uint8Array(size + 8);\n  view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n  view.setUint32(0, result.byteLength);\n  result.set(type, 4);\n\n  // copy the payload into the result\n  for (i = 0, size = 8; i < payload.length; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n};\n\ndinf = function() {\n  return box(types.dinf, box(types.dref, DREF));\n};\n\nesds = function(track) {\n  return box(types.esds, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n\n    // ES_Descriptor\n    0x03, // tag, ES_DescrTag\n    0x19, // length\n    0x00, 0x00, // ES_ID\n    0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n\n    // DecoderConfigDescriptor\n    0x04, // tag, DecoderConfigDescrTag\n    0x11, // length\n    0x40, // object type\n    0x15,  // streamType\n    0x00, 0x06, 0x00, // bufferSizeDB\n    0x00, 0x00, 0xda, 0xc0, // maxBitrate\n    0x00, 0x00, 0xda, 0xc0, // avgBitrate\n\n    // DecoderSpecificInfo\n    0x05, // tag, DecoderSpecificInfoTag\n    0x02, // length\n    // ISO/IEC 14496-3, AudioSpecificConfig\n    // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n    (track.audioobjecttype << 3) | (track.samplingfrequencyindex >>> 1),\n    (track.samplingfrequencyindex << 7) | (track.channelcount << 3),\n    0x06, 0x01, 0x02 // GASpecificConfig\n  ]));\n};\n\nftyp = function() {\n  return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n};\n\nhdlr = function(type) {\n  return box(types.hdlr, HDLR_TYPES[type]);\n};\nmdat = function(data) {\n  return box(types.mdat, data);\n};\nmdhd = function(track) {\n  var result = new Uint8Array([\n    0x00,                   // version 0\n    0x00, 0x00, 0x00,       // flags\n    0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x03, // modification_time\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n\n    (track.duration >>> 24) & 0xFF,\n    (track.duration >>> 16) & 0xFF,\n    (track.duration >>>  8) & 0xFF,\n    track.duration & 0xFF,  // duration\n    0x55, 0xc4,             // 'und' language (undetermined)\n    0x00, 0x00\n  ]);\n\n  // Use the sample rate from the track metadata, when it is\n  // defined. The sample rate can be parsed out of an ADTS header, for\n  // instance.\n  if (track.samplerate) {\n    result[12] = (track.samplerate >>> 24) & 0xFF;\n    result[13] = (track.samplerate >>> 16) & 0xFF;\n    result[14] = (track.samplerate >>>  8) & 0xFF;\n    result[15] = (track.samplerate)        & 0xFF;\n  }\n\n  return box(types.mdhd, result);\n};\nmdia = function(track) {\n  return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n};\nmfhd = function(sequenceNumber) {\n  return box(types.mfhd, new Uint8Array([\n    0x00,\n    0x00, 0x00, 0x00, // flags\n    (sequenceNumber & 0xFF000000) >> 24,\n    (sequenceNumber & 0xFF0000) >> 16,\n    (sequenceNumber & 0xFF00) >> 8,\n    sequenceNumber & 0xFF // sequence_number\n  ]));\n};\nminf = function(track) {\n  return box(types.minf,\n             track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD),\n             dinf(),\n             stbl(track));\n};\nmoof = function(sequenceNumber, tracks) {\n  var\n    trackFragments = [],\n    i = tracks.length;\n  // build traf boxes for each track fragment\n  while (i--) {\n    trackFragments[i] = traf(tracks[i]);\n  }\n  return box.apply(null, [\n    types.moof,\n    mfhd(sequenceNumber)\n  ].concat(trackFragments));\n};\n/**\n * Returns a movie box.\n * @param tracks {array} the tracks associated with this movie\n * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n */\nmoov = function(tracks) {\n  var\n    i = tracks.length,\n    boxes = [];\n\n  while (i--) {\n    boxes[i] = trak(tracks[i]);\n  }\n\n  return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n};\nmvex = function(tracks) {\n  var\n    i = tracks.length,\n    boxes = [];\n\n  while (i--) {\n    boxes[i] = trex(tracks[i]);\n  }\n  return box.apply(null, [types.mvex].concat(boxes));\n};\nmvhd = function(duration) {\n  var\n    bytes = new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // creation_time\n      0x00, 0x00, 0x00, 0x02, // modification_time\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n      (duration & 0xFF000000) >> 24,\n      (duration & 0xFF0000) >> 16,\n      (duration & 0xFF00) >> 8,\n      duration & 0xFF, // duration\n      0x00, 0x01, 0x00, 0x00, // 1.0 rate\n      0x01, 0x00, // 1.0 volume\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n  return box(types.mvhd, bytes);\n};\n\nsdtp = function(track) {\n  var\n    samples = track.samples || [],\n    bytes = new Uint8Array(4 + samples.length),\n    flags,\n    i;\n\n  // leave the full box header (4 bytes) all zero\n\n  // write the sample table\n  for (i = 0; i < samples.length; i++) {\n    flags = samples[i].flags;\n\n    bytes[i + 4] = (flags.dependsOn << 4) |\n      (flags.isDependedOn << 2) |\n      (flags.hasRedundancy);\n  }\n\n  return box(types.sdtp,\n             bytes);\n};\n\nstbl = function(track) {\n  return box(types.stbl,\n             stsd(track),\n             box(types.stts, STTS),\n             box(types.stsc, STSC),\n             box(types.stsz, STSZ),\n             box(types.stco, STCO));\n};\n\n(function() {\n  var videoSample, audioSample;\n\n  stsd = function(track) {\n\n    return box(types.stsd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01\n    ]), track.type === 'video' ? videoSample(track) : audioSample(track));\n  };\n\n  videoSample = function(track) {\n    var\n      sps = track.sps || [],\n      pps = track.pps || [],\n      sequenceParameterSets = [],\n      pictureParameterSets = [],\n      i;\n\n    // assemble the SPSs\n    for (i = 0; i < sps.length; i++) {\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF)); // sequenceParameterSetLength\n      sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < pps.length; i++) {\n      pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n      pictureParameterSets.push((pps[i].byteLength & 0xFF));\n      pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n    }\n\n    return box(types.avc1, new Uint8Array([\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      (track.width & 0xff00) >> 8,\n      track.width & 0xff, // width\n      (track.height & 0xff00) >> 8,\n      track.height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x13,\n      0x76, 0x69, 0x64, 0x65,\n      0x6f, 0x6a, 0x73, 0x2d,\n      0x63, 0x6f, 0x6e, 0x74,\n      0x72, 0x69, 0x62, 0x2d,\n      0x68, 0x6c, 0x73, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11 // pre_defined = -1\n    ]), box(types.avcC, new Uint8Array([\n      0x01, // configurationVersion\n      track.profileIdc, // AVCProfileIndication\n      track.profileCompatibility, // profile_compatibility\n      track.levelIdc, // AVCLevelIndication\n      0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n    ].concat([\n      sps.length // numOfSequenceParameterSets\n    ]).concat(sequenceParameterSets).concat([\n      pps.length // numOfPictureParameterSets\n    ]).concat(pictureParameterSets))), // \"PPS\"\n            box(types.btrt, new Uint8Array([\n              0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n              0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n              0x00, 0x2d, 0xc6, 0xc0\n            ])) // avgBitrate\n              );\n  };\n\n  audioSample = function(track) {\n    return box(types.mp4a, new Uint8Array([\n\n      // SampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n\n      // AudioSampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      (track.channelcount & 0xff00) >> 8,\n      (track.channelcount & 0xff), // channelcount\n\n      (track.samplesize & 0xff00) >> 8,\n      (track.samplesize & 0xff), // samplesize\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n\n      (track.samplerate & 0xff00) >> 8,\n      (track.samplerate & 0xff),\n      0x00, 0x00 // samplerate, 16.16\n\n      // MP4AudioSampleEntry, ISO/IEC 14496-14\n    ]), esds(track));\n  };\n}());\n\ntkhd = function(track) {\n  var result = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x07, // flags\n    0x00, 0x00, 0x00, 0x00, // creation_time\n    0x00, 0x00, 0x00, 0x00, // modification_time\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x00, // reserved\n    (track.duration & 0xFF000000) >> 24,\n    (track.duration & 0xFF0000) >> 16,\n    (track.duration & 0xFF00) >> 8,\n    track.duration & 0xFF, // duration\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, // layer\n    0x00, 0x00, // alternate_group\n    0x01, 0x00, // non-audio track volume\n    0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x01, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    (track.width & 0xFF00) >> 8,\n    track.width & 0xFF,\n    0x00, 0x00, // width\n    (track.height & 0xFF00) >> 8,\n    track.height & 0xFF,\n    0x00, 0x00 // height\n  ]);\n\n  return box(types.tkhd, result);\n};\n\n/**\n * Generate a track fragment (traf) box. A traf box collects metadata\n * about tracks in a movie fragment (moof) box.\n */\ntraf = function(track) {\n  var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun,\n      sampleDependencyTable, dataOffset,\n      upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n\n  trackFragmentHeader = box(types.tfhd, new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x3a, // flags\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    (track.id & 0xFF), // track_ID\n    0x00, 0x00, 0x00, 0x01, // sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x00, 0x00, 0x00  // default_sample_flags\n  ]));\n\n  upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / (UINT32_MAX + 1));\n  lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % (UINT32_MAX + 1));\n\n  trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([\n    0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    // baseMediaDecodeTime\n    (upperWordBaseMediaDecodeTime >>> 24) & 0xFF,\n    (upperWordBaseMediaDecodeTime >>> 16) & 0xFF,\n    (upperWordBaseMediaDecodeTime >>>  8) & 0xFF,\n    upperWordBaseMediaDecodeTime & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>> 24) & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>> 16) & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>>  8) & 0xFF,\n    lowerWordBaseMediaDecodeTime & 0xFF\n  ]));\n\n  // the data offset specifies the number of bytes from the start of\n  // the containing moof to the first payload byte of the associated\n  // mdat\n  dataOffset = (32 + // tfhd\n                20 + // tfdt\n                8 +  // traf header\n                16 + // mfhd\n                8 +  // moof header\n                8);  // mdat header\n\n  // audio tracks require less metadata\n  if (track.type === 'audio') {\n    trackFragmentRun = trun(track, dataOffset);\n    return box(types.traf,\n               trackFragmentHeader,\n               trackFragmentDecodeTime,\n               trackFragmentRun);\n  }\n\n  // video tracks should contain an independent and disposable samples\n  // box (sdtp)\n  // generate one and adjust offsets to match\n  sampleDependencyTable = sdtp(track);\n  trackFragmentRun = trun(track,\n                          sampleDependencyTable.length + dataOffset);\n  return box(types.traf,\n             trackFragmentHeader,\n             trackFragmentDecodeTime,\n             trackFragmentRun,\n             sampleDependencyTable);\n};\n\n/**\n * Generate a track box.\n * @param track {object} a track definition\n * @return {Uint8Array} the track box\n */\ntrak = function(track) {\n  track.duration = track.duration || 0xffffffff;\n  return box(types.trak,\n             tkhd(track),\n             mdia(track));\n};\n\ntrex = function(track) {\n  var result = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    (track.id & 0xFF), // track_ID\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n  ]);\n  // the last two bytes of default_sample_flags is the sample\n  // degradation priority, a hint about the importance of this sample\n  // relative to others. Lower the degradation priority for all sample\n  // types other than video.\n  if (track.type !== 'video') {\n    result[result.length - 1] = 0x00;\n  }\n\n  return box(types.trex, result);\n};\n\n(function() {\n  var audioTrun, videoTrun, trunHeader;\n\n  // This method assumes all samples are uniform. That is, if a\n  // duration is present for the first sample, it will be present for\n  // all subsequent samples.\n  // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n  trunHeader = function(samples, offset) {\n    var durationPresent = 0, sizePresent = 0,\n        flagsPresent = 0, compositionTimeOffset = 0;\n\n    // trun flag constants\n    if (samples.length) {\n      if (samples[0].duration !== undefined) {\n        durationPresent = 0x1;\n      }\n      if (samples[0].size !== undefined) {\n        sizePresent = 0x2;\n      }\n      if (samples[0].flags !== undefined) {\n        flagsPresent = 0x4;\n      }\n      if (samples[0].compositionTimeOffset !== undefined) {\n        compositionTimeOffset = 0x8;\n      }\n    }\n\n    return [\n      0x00, // version 0\n      0x00,\n      durationPresent | sizePresent | flagsPresent | compositionTimeOffset,\n      0x01, // flags\n      (samples.length & 0xFF000000) >>> 24,\n      (samples.length & 0xFF0000) >>> 16,\n      (samples.length & 0xFF00) >>> 8,\n      samples.length & 0xFF, // sample_count\n      (offset & 0xFF000000) >>> 24,\n      (offset & 0xFF0000) >>> 16,\n      (offset & 0xFF00) >>> 8,\n      offset & 0xFF // data_offset\n    ];\n  };\n\n  videoTrun = function(track, offset) {\n    var bytes, samples, sample, i;\n\n    samples = track.samples || [];\n    offset += 8 + 12 + (16 * samples.length);\n\n    bytes = trunHeader(samples, offset);\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([\n        (sample.duration & 0xFF000000) >>> 24,\n        (sample.duration & 0xFF0000) >>> 16,\n        (sample.duration & 0xFF00) >>> 8,\n        sample.duration & 0xFF, // sample_duration\n        (sample.size & 0xFF000000) >>> 24,\n        (sample.size & 0xFF0000) >>> 16,\n        (sample.size & 0xFF00) >>> 8,\n        sample.size & 0xFF, // sample_size\n        (sample.flags.isLeading << 2) | sample.flags.dependsOn,\n        (sample.flags.isDependedOn << 6) |\n          (sample.flags.hasRedundancy << 4) |\n          (sample.flags.paddingValue << 1) |\n          sample.flags.isNonSyncSample,\n        sample.flags.degradationPriority & 0xF0 << 8,\n        sample.flags.degradationPriority & 0x0F, // sample_flags\n        (sample.compositionTimeOffset & 0xFF000000) >>> 24,\n        (sample.compositionTimeOffset & 0xFF0000) >>> 16,\n        (sample.compositionTimeOffset & 0xFF00) >>> 8,\n        sample.compositionTimeOffset & 0xFF // sample_composition_time_offset\n      ]);\n    }\n    return box(types.trun, new Uint8Array(bytes));\n  };\n\n  audioTrun = function(track, offset) {\n    var bytes, samples, sample, i;\n\n    samples = track.samples || [];\n    offset += 8 + 12 + (8 * samples.length);\n\n    bytes = trunHeader(samples, offset);\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([\n        (sample.duration & 0xFF000000) >>> 24,\n        (sample.duration & 0xFF0000) >>> 16,\n        (sample.duration & 0xFF00) >>> 8,\n        sample.duration & 0xFF, // sample_duration\n        (sample.size & 0xFF000000) >>> 24,\n        (sample.size & 0xFF0000) >>> 16,\n        (sample.size & 0xFF00) >>> 8,\n        sample.size & 0xFF]); // sample_size\n    }\n\n    return box(types.trun, new Uint8Array(bytes));\n  };\n\n  trun = function(track, offset) {\n    if (track.type === 'audio') {\n      return audioTrun(track, offset);\n    }\n\n    return videoTrun(track, offset);\n  };\n}());\n\nmodule.exports = {\n  ftyp: ftyp,\n  mdat: mdat,\n  moof: moof,\n  moov: moov,\n  initSegment: function(tracks) {\n    var\n      fileType = ftyp(),\n      movie = moov(tracks),\n      result;\n\n    result = new Uint8Array(fileType.byteLength + movie.byteLength);\n    result.set(fileType);\n    result.set(movie, fileType.byteLength);\n    return result;\n  }\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Accepts program elementary stream (PES) data events and corrects\n * decode and presentation time stamps to account for a rollover\n * of the 33 bit value.\n */\n\n'use strict';\n\nvar Stream = require('../utils/stream');\n\nvar MAX_TS = 8589934592;\n\nvar RO_THRESH = 4294967296;\n\nvar handleRollover = function(value, reference) {\n  var direction = 1;\n\n  if (value > reference) {\n    // If the current timestamp value is greater than our reference timestamp and we detect a\n    // timestamp rollover, this means the roll over is happening in the opposite direction.\n    // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n    // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n    // rollover point. In loading this segment, the timestamp values will be very large,\n    // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n    // the time stamp to be `value - 2^33`.\n    direction = -1;\n  }\n\n  // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n  // cause an incorrect adjustment.\n  while (Math.abs(reference - value) > RO_THRESH) {\n    value += (direction * MAX_TS);\n  }\n\n  return value;\n};\n\nvar TimestampRolloverStream = function(type) {\n  var lastDTS, referenceDTS;\n\n  TimestampRolloverStream.prototype.init.call(this);\n\n  this.type_ = type;\n\n  this.push = function(data) {\n    if (data.type !== this.type_) {\n      return;\n    }\n\n    if (referenceDTS === undefined) {\n      referenceDTS = data.dts;\n    }\n\n    data.dts = handleRollover(data.dts, referenceDTS);\n    data.pts = handleRollover(data.pts, referenceDTS);\n\n    lastDTS = data.dts;\n\n    this.trigger('data', data);\n  };\n\n  this.flush = function() {\n    referenceDTS = lastDTS;\n    this.trigger('done');\n  };\n\n  this.discontinuity = function() {\n    referenceDTS = void 0;\n    lastDTS = void 0;\n  };\n\n};\n\nTimestampRolloverStream.prototype = new Stream();\n\nmodule.exports = {\n  TimestampRolloverStream: TimestampRolloverStream,\n  handleRollover: handleRollover\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about MP4s.\n */\n'use strict';\n\nvar toUnsigned = require('../utils/bin').toUnsigned;\nvar findBox, parseType, timescale, startTime, getVideoTrackIds;\n\n// Find the data for a box specified by its path\nfindBox = function(data, path) {\n  var results = [],\n      i, size, type, end, subresults;\n\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return null;\n  }\n\n  for (i = 0; i < data.byteLength;) {\n    size  = toUnsigned(data[i]     << 24 |\n                       data[i + 1] << 16 |\n                       data[i + 2] <<  8 |\n                       data[i + 3]);\n\n    type = parseType(data.subarray(i + 4, i + 8));\n\n    end = size > 1 ? i + size : data.byteLength;\n\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, end));\n      } else {\n        // recursively search for the next box along the path\n        subresults = findBox(data.subarray(i + 8, end), path.slice(1));\n        if (subresults.length) {\n          results = results.concat(subresults);\n        }\n      }\n    }\n    i = end;\n  }\n\n  // we've finished searching all of data\n  return results;\n};\n\n/**\n * Returns the string representation of an ASCII encoded four byte buffer.\n * @param buffer {Uint8Array} a four-byte buffer to translate\n * @return {string} the corresponding string\n */\nparseType = function(buffer) {\n  var result = '';\n  result += String.fromCharCode(buffer[0]);\n  result += String.fromCharCode(buffer[1]);\n  result += String.fromCharCode(buffer[2]);\n  result += String.fromCharCode(buffer[3]);\n  return result;\n};\n\n/**\n * Parses an MP4 initialization segment and extracts the timescale\n * values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * ```\n * @param init {Uint8Array} the bytes of the init segment\n * @return {object} a hash of track ids to timescale values or null if\n * the init segment is malformed.\n */\ntimescale = function(init) {\n  var\n    result = {},\n    traks = findBox(init, ['moov', 'trak']);\n\n  // mdhd timescale\n  return traks.reduce(function(result, trak) {\n    var tkhd, version, index, id, mdhd;\n\n    tkhd = findBox(trak, ['tkhd'])[0];\n    if (!tkhd) {\n      return null;\n    }\n    version = tkhd[0];\n    index = version === 0 ? 12 : 20;\n    id = toUnsigned(tkhd[index]     << 24 |\n                    tkhd[index + 1] << 16 |\n                    tkhd[index + 2] <<  8 |\n                    tkhd[index + 3]);\n\n    mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n    if (!mdhd) {\n      return null;\n    }\n    version = mdhd[0];\n    index = version === 0 ? 12 : 20;\n    result[id] = toUnsigned(mdhd[index]     << 24 |\n                            mdhd[index + 1] << 16 |\n                            mdhd[index + 2] <<  8 |\n                            mdhd[index + 3]);\n    return result;\n  }, result);\n};\n\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param timescale {object} a hash of track ids to timescale values.\n * @return {number} the earliest base media decode start time for the\n * fragment, in seconds\n */\nstartTime = function(timescale, fragment) {\n  var trafs, baseTimes, result;\n\n  // we need info from two childrend of each track fragment box\n  trafs = findBox(fragment, ['moof', 'traf']);\n\n  // determine the start times for each track\n  baseTimes = [].concat.apply([], trafs.map(function(traf) {\n    return findBox(traf, ['tfhd']).map(function(tfhd) {\n      var id, scale, baseTime;\n\n      // get the track id from the tfhd\n      id = toUnsigned(tfhd[4] << 24 |\n                      tfhd[5] << 16 |\n                      tfhd[6] <<  8 |\n                      tfhd[7]);\n      // assume a 90kHz clock if no timescale was specified\n      scale = timescale[id] || 90e3;\n\n      // get the base media decode time from the tfdt\n      baseTime = findBox(traf, ['tfdt']).map(function(tfdt) {\n        var version, result;\n\n        version = tfdt[0];\n        result = toUnsigned(tfdt[4] << 24 |\n                            tfdt[5] << 16 |\n                            tfdt[6] <<  8 |\n                            tfdt[7]);\n        if (version ===  1) {\n          result *= Math.pow(2, 32);\n          result += toUnsigned(tfdt[8]  << 24 |\n                               tfdt[9]  << 16 |\n                               tfdt[10] <<  8 |\n                               tfdt[11]);\n        }\n        return result;\n      })[0];\n      baseTime = baseTime || Infinity;\n\n      // convert base time to seconds\n      return baseTime / scale;\n    });\n  }));\n\n  // return the minimum\n  result = Math.min.apply(null, baseTimes);\n  return isFinite(result) ? result : 0;\n};\n\n/**\n  * Find the trackIds of the video tracks in this source.\n  * Found by parsing the Handler Reference and Track Header Boxes:\n  *   moov > trak > mdia > hdlr\n  *   moov > trak > tkhd\n  *\n  * @param {Uint8Array} init - The bytes of the init segment for this source\n  * @return {Number[]} A list of trackIds\n  *\n  * @see ISO-BMFF-12/2015, Section 8.4.3\n **/\ngetVideoTrackIds = function(init) {\n  var traks = findBox(init, ['moov', 'trak']);\n  var videoTrackIds = [];\n\n  traks.forEach(function(trak) {\n    var hdlrs = findBox(trak, ['mdia', 'hdlr']);\n    var tkhds = findBox(trak, ['tkhd']);\n\n    hdlrs.forEach(function(hdlr, index) {\n      var handlerType = parseType(hdlr.subarray(8, 12));\n      var tkhd = tkhds[index];\n      var view;\n      var version;\n      var trackId;\n\n      if (handlerType === 'vide') {\n        view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n        version = view.getUint8(0);\n        trackId = (version === 0) ? view.getUint32(12) : view.getUint32(20);\n\n        videoTrackIds.push(trackId);\n      }\n    });\n  });\n\n  return videoTrackIds;\n};\n\nmodule.exports = {\n  findBox: findBox,\n  parseType: parseType,\n  timescale: timescale,\n  startTime: startTime,\n  videoTrackIds: getVideoTrackIds\n};\n","module.exports = {\n  generator: require('./mp4-generator'),\n  probe: require('./probe'),\n  Transmuxer: require('./transmuxer').Transmuxer,\n  AudioSegmentStream: require('./transmuxer').AudioSegmentStream,\n  VideoSegmentStream: require('./transmuxer').VideoSegmentStream,\n  CaptionParser: require('./caption-parser')\n};\n","// Convert an array of nal units into an array of frames with each frame being\n// composed of the nal units that make up that frame\n// Also keep track of cummulative data about the frame from the nal units such\n// as the frame duration, starting pts, etc.\nvar groupNalsIntoFrames = function(nalUnits) {\n  var\n    i,\n    currentNal,\n    currentFrame = [],\n    frames = [];\n\n  currentFrame.byteLength = 0;\n\n  for (i = 0; i < nalUnits.length; i++) {\n    currentNal = nalUnits[i];\n\n    // Split on 'aud'-type nal units\n    if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n      // Since the very first nal unit is expected to be an AUD\n      // only push to the frames array when currentFrame is not empty\n      if (currentFrame.length) {\n        currentFrame.duration = currentNal.dts - currentFrame.dts;\n        frames.push(currentFrame);\n      }\n      currentFrame = [currentNal];\n      currentFrame.byteLength = currentNal.data.byteLength;\n      currentFrame.pts = currentNal.pts;\n      currentFrame.dts = currentNal.dts;\n    } else {\n      // Specifically flag key frames for ease of use later\n      if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n        currentFrame.keyFrame = true;\n      }\n      currentFrame.duration = currentNal.dts - currentFrame.dts;\n      currentFrame.byteLength += currentNal.data.byteLength;\n      currentFrame.push(currentNal);\n    }\n  }\n\n  // For the last frame, use the duration of the previous frame if we\n  // have nothing better to go on\n  if (frames.length &&\n      (!currentFrame.duration ||\n       currentFrame.duration <= 0)) {\n    currentFrame.duration = frames[frames.length - 1].duration;\n  }\n\n  // Push the final frame\n  frames.push(currentFrame);\n  return frames;\n};\n\n// Convert an array of frames into an array of Gop with each Gop being composed\n// of the frames that make up that Gop\n// Also keep track of cummulative data about the Gop from the frames such as the\n// Gop duration, starting pts, etc.\nvar groupFramesIntoGops = function(frames) {\n  var\n    i,\n    currentFrame,\n    currentGop = [],\n    gops = [];\n\n  // We must pre-set some of the values on the Gop since we\n  // keep running totals of these values\n  currentGop.byteLength = 0;\n  currentGop.nalCount = 0;\n  currentGop.duration = 0;\n  currentGop.pts = frames[0].pts;\n  currentGop.dts = frames[0].dts;\n\n  // store some metadata about all the Gops\n  gops.byteLength = 0;\n  gops.nalCount = 0;\n  gops.duration = 0;\n  gops.pts = frames[0].pts;\n  gops.dts = frames[0].dts;\n\n  for (i = 0; i < frames.length; i++) {\n    currentFrame = frames[i];\n\n    if (currentFrame.keyFrame) {\n      // Since the very first frame is expected to be an keyframe\n      // only push to the gops array when currentGop is not empty\n      if (currentGop.length) {\n        gops.push(currentGop);\n        gops.byteLength += currentGop.byteLength;\n        gops.nalCount += currentGop.nalCount;\n        gops.duration += currentGop.duration;\n      }\n\n      currentGop = [currentFrame];\n      currentGop.nalCount = currentFrame.length;\n      currentGop.byteLength = currentFrame.byteLength;\n      currentGop.pts = currentFrame.pts;\n      currentGop.dts = currentFrame.dts;\n      currentGop.duration = currentFrame.duration;\n    } else {\n      currentGop.duration += currentFrame.duration;\n      currentGop.nalCount += currentFrame.length;\n      currentGop.byteLength += currentFrame.byteLength;\n      currentGop.push(currentFrame);\n    }\n  }\n\n  if (gops.length && currentGop.duration <= 0) {\n    currentGop.duration = gops[gops.length - 1].duration;\n  }\n  gops.byteLength += currentGop.byteLength;\n  gops.nalCount += currentGop.nalCount;\n  gops.duration += currentGop.duration;\n\n  // push the final Gop\n  gops.push(currentGop);\n  return gops;\n};\n\n/*\n * Search for the first keyframe in the GOPs and throw away all frames\n * until that keyframe. Then extend the duration of the pulled keyframe\n * and pull the PTS and DTS of the keyframe so that it covers the time\n * range of the frames that were disposed.\n *\n * @param {Array} gops video GOPs\n * @returns {Array} modified video GOPs\n */\nvar extendFirstKeyFrame = function(gops) {\n  var currentGop;\n\n  if (!gops[0][0].keyFrame && gops.length > 1) {\n    // Remove the first GOP\n    currentGop = gops.shift();\n\n    gops.byteLength -= currentGop.byteLength;\n    gops.nalCount -= currentGop.nalCount;\n\n    // Extend the first frame of what is now the\n    // first gop to cover the time period of the\n    // frames we just removed\n    gops[0][0].dts = currentGop.dts;\n    gops[0][0].pts = currentGop.pts;\n    gops[0][0].duration += currentGop.duration;\n  }\n\n  return gops;\n};\n\n/**\n * Default sample object\n * see ISO/IEC 14496-12:2012, section 8.6.4.3\n */\nvar createDefaultSample = function() {\n  return {\n    size: 0,\n    flags: {\n      isLeading: 0,\n      dependsOn: 1,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradationPriority: 0,\n      isNonSyncSample: 1\n    }\n  };\n};\n\n/*\n * Collates information from a video frame into an object for eventual\n * entry into an MP4 sample table.\n *\n * @param {Object} frame the video frame\n * @param {Number} dataOffset the byte offset to position the sample\n * @return {Object} object containing sample table info for a frame\n */\nvar sampleForFrame = function(frame, dataOffset) {\n  var sample = createDefaultSample();\n\n  sample.dataOffset = dataOffset;\n  sample.compositionTimeOffset = frame.pts - frame.dts;\n  sample.duration = frame.duration;\n  sample.size = 4 * frame.length; // Space for nal unit size\n  sample.size += frame.byteLength;\n\n  if (frame.keyFrame) {\n    sample.flags.dependsOn = 2;\n    sample.flags.isNonSyncSample = 0;\n  }\n\n  return sample;\n};\n\n// generate the track's sample table from an array of gops\nvar generateSampleTable = function(gops, baseDataOffset) {\n  var\n    h, i,\n    sample,\n    currentGop,\n    currentFrame,\n    dataOffset = baseDataOffset || 0,\n    samples = [];\n\n  for (h = 0; h < gops.length; h++) {\n    currentGop = gops[h];\n\n    for (i = 0; i < currentGop.length; i++) {\n      currentFrame = currentGop[i];\n\n      sample = sampleForFrame(currentFrame, dataOffset);\n\n      dataOffset += sample.size;\n\n      samples.push(sample);\n    }\n  }\n  return samples;\n};\n\n// generate the track's raw mdat data from an array of gops\nvar concatenateNalData = function(gops) {\n  var\n    h, i, j,\n    currentGop,\n    currentFrame,\n    currentNal,\n    dataOffset = 0,\n    nalsByteLength = gops.byteLength,\n    numberOfNals = gops.nalCount,\n    totalByteLength = nalsByteLength + 4 * numberOfNals,\n    data = new Uint8Array(totalByteLength),\n    view = new DataView(data.buffer);\n\n  // For each Gop..\n  for (h = 0; h < gops.length; h++) {\n    currentGop = gops[h];\n\n    // For each Frame..\n    for (i = 0; i < currentGop.length; i++) {\n      currentFrame = currentGop[i];\n\n      // For each NAL..\n      for (j = 0; j < currentFrame.length; j++) {\n        currentNal = currentFrame[j];\n\n        view.setUint32(dataOffset, currentNal.data.byteLength);\n        dataOffset += 4;\n        data.set(currentNal.data, dataOffset);\n        dataOffset += currentNal.data.byteLength;\n      }\n    }\n  }\n  return data;\n};\n\nmodule.exports = {\n  groupNalsIntoFrames: groupNalsIntoFrames,\n  groupFramesIntoGops: groupFramesIntoGops,\n  extendFirstKeyFrame: extendFirstKeyFrame,\n  generateSampleTable: generateSampleTable,\n  concatenateNalData: concatenateNalData\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar mp4 = require('./mp4-generator.js');\nvar frameUtils = require('./frame-utils');\nvar audioFrameUtils = require('./audio-frame-utils');\nvar trackDecodeInfo = require('./track-decode-info');\nvar m2ts = require('../m2ts/m2ts.js');\nvar AdtsStream = require('../codecs/adts.js');\nvar H264Stream = require('../codecs/h264').H264Stream;\nvar AacStream = require('../aac');\nvar isLikelyAacData = require('../aac/utils').isLikelyAacData;\n\n// constants\nvar AUDIO_PROPERTIES = [\n  'audioobjecttype',\n  'channelcount',\n  'samplerate',\n  'samplingfrequencyindex',\n  'samplesize'\n];\n\nvar VIDEO_PROPERTIES = [\n  'width',\n  'height',\n  'profileIdc',\n  'levelIdc',\n  'profileCompatibility'\n];\n\n// object types\nvar VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;\n\n/**\n * Compare two arrays (even typed) for same-ness\n */\nvar arrayEquals = function(a, b) {\n  var\n    i;\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  // compare the value of each element in the array\n  for (i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar generateVideoSegmentTimingInfo = function(\n  baseMediaDecodeTime,\n  startDts,\n  startPts,\n  endDts,\n  endPts,\n  prependedContentDuration\n) {\n  var\n    ptsOffsetFromDts = startPts - startDts,\n    decodeDuration = endDts - startDts,\n    presentationDuration = endPts - startPts;\n\n  // The PTS and DTS values are based on the actual stream times from the segment,\n  // however, the player time values will reflect a start from the baseMediaDecodeTime.\n  // In order to provide relevant values for the player times, base timing info on the\n  // baseMediaDecodeTime and the DTS and PTS durations of the segment.\n  return {\n    start: {\n      dts: baseMediaDecodeTime,\n      pts: baseMediaDecodeTime + ptsOffsetFromDts\n    },\n    end: {\n      dts: baseMediaDecodeTime + decodeDuration,\n      pts: baseMediaDecodeTime + presentationDuration\n    },\n    prependedContentDuration: prependedContentDuration,\n    baseMediaDecodeTime: baseMediaDecodeTime\n  };\n};\n\n/**\n * Constructs a single-track, ISO BMFF media segment from AAC data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n * @param track {object} track metadata configuration\n * @param options {object} transmuxer options object\n * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at 0.\n */\nAudioSegmentStream = function(track, options) {\n  var\n    adtsFrames = [],\n    sequenceNumber = 0,\n    earliestAllowedDts = 0,\n    audioAppendStartTs = 0,\n    videoBaseMediaDecodeTime = Infinity;\n\n  options = options || {};\n\n  AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    trackDecodeInfo.collectDtsInfo(track, data);\n\n    if (track) {\n      AUDIO_PROPERTIES.forEach(function(prop) {\n        track[prop] = data[prop];\n      });\n    }\n\n    // buffer audio data until end() is called\n    adtsFrames.push(data);\n  };\n\n  this.setEarliestDts = function(earliestDts) {\n    earliestAllowedDts = earliestDts - track.timelineStartInfo.baseMediaDecodeTime;\n  };\n\n  this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {\n    videoBaseMediaDecodeTime = baseMediaDecodeTime;\n  };\n\n  this.setAudioAppendStart = function(timestamp) {\n    audioAppendStartTs = timestamp;\n  };\n\n  this.flush = function() {\n    var\n      frames,\n      moof,\n      mdat,\n      boxes;\n\n    // return early if no audio data has been observed\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n\n    frames = audioFrameUtils.trimAdtsFramesByEarliestDts(\n      adtsFrames, track, earliestAllowedDts);\n    track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(\n      track, options.keepOriginalTimestamps);\n\n    audioFrameUtils.prefixWithSilence(\n      track, frames, audioAppendStartTs, videoBaseMediaDecodeTime);\n\n    // we have to build the index from byte locations to\n    // samples (that is, adts frames) in the audio data\n    track.samples = audioFrameUtils.generateSampleTable(frames);\n\n    // concatenate the audio data to constuct the mdat\n    mdat = mp4.mdat(audioFrameUtils.concatenateFrameData(frames));\n\n    adtsFrames = [];\n\n    moof = mp4.moof(sequenceNumber, [track]);\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // bump the sequence number for next time\n    sequenceNumber++;\n\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n\n    trackDecodeInfo.clearDtsInfo(track);\n\n    this.trigger('data', {track: track, boxes: boxes});\n    this.trigger('done', 'AudioSegmentStream');\n  };\n};\n\nAudioSegmentStream.prototype = new Stream();\n\n/**\n * Constructs a single-track, ISO BMFF media segment from H264 data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n * @param track {object} track metadata configuration\n * @param options {object} transmuxer options object\n * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n *        gopsToAlignWith list when attempting to align gop pts\n * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at 0.\n */\nVideoSegmentStream = function(track, options) {\n  var\n    sequenceNumber = 0,\n    nalUnits = [],\n    gopsToAlignWith = [],\n    config,\n    pps;\n\n  options = options || {};\n\n  VideoSegmentStream.prototype.init.call(this);\n\n  delete track.minPTS;\n\n  this.gopCache_ = [];\n\n  /**\n    * Constructs a ISO BMFF segment given H264 nalUnits\n    * @param {Object} nalUnit A data event representing a nalUnit\n    * @param {String} nalUnit.nalUnitType\n    * @param {Object} nalUnit.config Properties for a mp4 track\n    * @param {Uint8Array} nalUnit.data The nalUnit bytes\n    * @see lib/codecs/h264.js\n   **/\n  this.push = function(nalUnit) {\n    trackDecodeInfo.collectDtsInfo(track, nalUnit);\n\n    // record the track config\n    if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n      config = nalUnit.config;\n      track.sps = [nalUnit.data];\n\n      VIDEO_PROPERTIES.forEach(function(prop) {\n        track[prop] = config[prop];\n      }, this);\n    }\n\n    if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' &&\n        !pps) {\n      pps = nalUnit.data;\n      track.pps = [nalUnit.data];\n    }\n\n    // buffer video until flush() is called\n    nalUnits.push(nalUnit);\n  };\n\n  /**\n    * Pass constructed ISO BMFF track and boxes on to the\n    * next stream in the pipeline\n   **/\n  this.flush = function() {\n    var\n      frames,\n      gopForFusion,\n      gops,\n      moof,\n      mdat,\n      boxes,\n      prependedContentDuration = 0,\n      firstGop,\n      lastGop;\n\n    // Throw away nalUnits at the start of the byte stream until\n    // we find the first AUD\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n      nalUnits.shift();\n    }\n\n    // Return early if no video data has been observed\n    if (nalUnits.length === 0) {\n      this.resetStream_();\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n\n    // Organize the raw nal-units into arrays that represent\n    // higher-level constructs such as frames and gops\n    // (group-of-pictures)\n    frames = frameUtils.groupNalsIntoFrames(nalUnits);\n    gops = frameUtils.groupFramesIntoGops(frames);\n\n    // If the first frame of this fragment is not a keyframe we have\n    // a problem since MSE (on Chrome) requires a leading keyframe.\n    //\n    // We have two approaches to repairing this situation:\n    // 1) GOP-FUSION:\n    //    This is where we keep track of the GOPS (group-of-pictures)\n    //    from previous fragments and attempt to find one that we can\n    //    prepend to the current fragment in order to create a valid\n    //    fragment.\n    // 2) KEYFRAME-PULLING:\n    //    Here we search for the first keyframe in the fragment and\n    //    throw away all the frames between the start of the fragment\n    //    and that keyframe. We then extend the duration and pull the\n    //    PTS of the keyframe forward so that it covers the time range\n    //    of the frames that were disposed of.\n    //\n    // #1 is far prefereable over #2 which can cause \"stuttering\" but\n    // requires more things to be just right.\n    if (!gops[0][0].keyFrame) {\n      // Search for a gop for fusion from our gopCache\n      gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n\n      if (gopForFusion) {\n        // in order to provide more accurate timing information about the segment, save\n        // the number of seconds prepended to the original segment due to GOP fusion\n        prependedContentDuration = gopForFusion.duration;\n\n        gops.unshift(gopForFusion);\n        // Adjust Gops' metadata to account for the inclusion of the\n        // new gop at the beginning\n        gops.byteLength += gopForFusion.byteLength;\n        gops.nalCount += gopForFusion.nalCount;\n        gops.pts = gopForFusion.pts;\n        gops.dts = gopForFusion.dts;\n        gops.duration += gopForFusion.duration;\n      } else {\n        // If we didn't find a candidate gop fall back to keyframe-pulling\n        gops = frameUtils.extendFirstKeyFrame(gops);\n      }\n    }\n\n    // Trim gops to align with gopsToAlignWith\n    if (gopsToAlignWith.length) {\n      var alignedGops;\n\n      if (options.alignGopsAtEnd) {\n        alignedGops = this.alignGopsAtEnd_(gops);\n      } else {\n        alignedGops = this.alignGopsAtStart_(gops);\n      }\n\n      if (!alignedGops) {\n        // save all the nals in the last GOP into the gop cache\n        this.gopCache_.unshift({\n          gop: gops.pop(),\n          pps: track.pps,\n          sps: track.sps\n        });\n\n        // Keep a maximum of 6 GOPs in the cache\n        this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n        // Clear nalUnits\n        nalUnits = [];\n\n        // return early no gops can be aligned with desired gopsToAlignWith\n        this.resetStream_();\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      }\n\n      // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n      // when recalculated before sending off to CoalesceStream\n      trackDecodeInfo.clearDtsInfo(track);\n\n      gops = alignedGops;\n    }\n\n    trackDecodeInfo.collectDtsInfo(track, gops);\n\n    // First, we have to build the index from byte locations to\n    // samples (that is, frames) in the video data\n    track.samples = frameUtils.generateSampleTable(gops);\n\n    // Concatenate the video data and construct the mdat\n    mdat = mp4.mdat(frameUtils.concatenateNalData(gops));\n\n    track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(\n      track, options.keepOriginalTimestamps);\n\n    this.trigger('processedGopsInfo', gops.map(function(gop) {\n      return {\n        pts: gop.pts,\n        dts: gop.dts,\n        byteLength: gop.byteLength\n      };\n    }));\n\n    firstGop = gops[0];\n    lastGop = gops[gops.length - 1];\n\n    this.trigger(\n      'segmentTimingInfo',\n      generateVideoSegmentTimingInfo(\n        track.baseMediaDecodeTime,\n        firstGop.dts,\n        firstGop.pts,\n        lastGop.dts + lastGop.duration,\n        lastGop.pts + lastGop.duration,\n        prependedContentDuration));\n\n    // save all the nals in the last GOP into the gop cache\n    this.gopCache_.unshift({\n      gop: gops.pop(),\n      pps: track.pps,\n      sps: track.sps\n    });\n\n    // Keep a maximum of 6 GOPs in the cache\n    this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n    // Clear nalUnits\n    nalUnits = [];\n\n    this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n    this.trigger('timelineStartInfo', track.timelineStartInfo);\n\n    moof = mp4.moof(sequenceNumber, [track]);\n\n    // it would be great to allocate this array up front instead of\n    // throwing away hundreds of media segment fragments\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // Bump the sequence number for next time\n    sequenceNumber++;\n\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n\n    this.trigger('data', {track: track, boxes: boxes});\n\n    this.resetStream_();\n\n    // Continue with the flush process now\n    this.trigger('done', 'VideoSegmentStream');\n  };\n\n  this.resetStream_ = function() {\n    trackDecodeInfo.clearDtsInfo(track);\n\n    // reset config and pps because they may differ across segments\n    // for instance, when we are rendition switching\n    config = undefined;\n    pps = undefined;\n  };\n\n  // Search for a candidate Gop for gop-fusion from the gop cache and\n  // return it or return null if no good candidate was found\n  this.getGopForFusion_ = function(nalUnit) {\n    var\n      halfSecond = 45000, // Half-a-second in a 90khz clock\n      allowableOverlap = 10000, // About 3 frames @ 30fps\n      nearestDistance = Infinity,\n      dtsDistance,\n      nearestGopObj,\n      currentGop,\n      currentGopObj,\n      i;\n\n    // Search for the GOP nearest to the beginning of this nal unit\n    for (i = 0; i < this.gopCache_.length; i++) {\n      currentGopObj = this.gopCache_[i];\n      currentGop = currentGopObj.gop;\n\n      // Reject Gops with different SPS or PPS\n      if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) ||\n          !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n        continue;\n      }\n\n      // Reject Gops that would require a negative baseMediaDecodeTime\n      if (currentGop.dts < track.timelineStartInfo.dts) {\n        continue;\n      }\n\n      // The distance between the end of the gop and the start of the nalUnit\n      dtsDistance = (nalUnit.dts - currentGop.dts) - currentGop.duration;\n\n      // Only consider GOPS that start before the nal unit and end within\n      // a half-second of the nal unit\n      if (dtsDistance >= -allowableOverlap &&\n          dtsDistance <= halfSecond) {\n\n        // Always use the closest GOP we found if there is more than\n        // one candidate\n        if (!nearestGopObj ||\n            nearestDistance > dtsDistance) {\n          nearestGopObj = currentGopObj;\n          nearestDistance = dtsDistance;\n        }\n      }\n    }\n\n    if (nearestGopObj) {\n      return nearestGopObj.gop;\n    }\n    return null;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the START of the list\n  this.alignGopsAtStart_ = function(gops) {\n    var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n\n    byteLength = gops.byteLength;\n    nalCount = gops.nalCount;\n    duration = gops.duration;\n    alignIndex = gopIndex = 0;\n\n    while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        break;\n      }\n\n      if (gop.pts > align.pts) {\n        // this current gop starts after the current gop we want to align on, so increment\n        // align index\n        alignIndex++;\n        continue;\n      }\n\n      // current gop starts before the current gop we want to align on. so increment gop\n      // index\n      gopIndex++;\n      byteLength -= gop.byteLength;\n      nalCount -= gop.nalCount;\n      duration -= gop.duration;\n    }\n\n    if (gopIndex === 0) {\n      // no gops to trim\n      return gops;\n    }\n\n    if (gopIndex === gops.length) {\n      // all gops trimmed, skip appending all gops\n      return null;\n    }\n\n    alignedGops = gops.slice(gopIndex);\n    alignedGops.byteLength = byteLength;\n    alignedGops.duration = duration;\n    alignedGops.nalCount = nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n\n    return alignedGops;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the END of the list\n  this.alignGopsAtEnd_ = function(gops) {\n    var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n\n    alignIndex = gopsToAlignWith.length - 1;\n    gopIndex = gops.length - 1;\n    alignEndIndex = null;\n    matchFound = false;\n\n    while (alignIndex >= 0 && gopIndex >= 0) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        matchFound = true;\n        break;\n      }\n\n      if (align.pts > gop.pts) {\n        alignIndex--;\n        continue;\n      }\n\n      if (alignIndex === gopsToAlignWith.length - 1) {\n        // gop.pts is greater than the last alignment candidate. If no match is found\n        // by the end of this loop, we still want to append gops that come after this\n        // point\n        alignEndIndex = gopIndex;\n      }\n\n      gopIndex--;\n    }\n\n    if (!matchFound && alignEndIndex === null) {\n      return null;\n    }\n\n    var trimIndex;\n\n    if (matchFound) {\n      trimIndex = gopIndex;\n    } else {\n      trimIndex = alignEndIndex;\n    }\n\n    if (trimIndex === 0) {\n      return gops;\n    }\n\n    var alignedGops = gops.slice(trimIndex);\n    var metadata = alignedGops.reduce(function(total, gop) {\n      total.byteLength += gop.byteLength;\n      total.duration += gop.duration;\n      total.nalCount += gop.nalCount;\n      return total;\n    }, { byteLength: 0, duration: 0, nalCount: 0 });\n\n    alignedGops.byteLength = metadata.byteLength;\n    alignedGops.duration = metadata.duration;\n    alignedGops.nalCount = metadata.nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n\n    return alignedGops;\n  };\n\n  this.alignGopsWith = function(newGopsToAlignWith) {\n    gopsToAlignWith = newGopsToAlignWith;\n  };\n};\n\nVideoSegmentStream.prototype = new Stream();\n\n/**\n * A Stream that can combine multiple streams (ie. audio & video)\n * into a single output segment for MSE. Also supports audio-only\n * and video-only streams.\n * @param options {object} transmuxer options object\n * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at media timeline start.\n */\nCoalesceStream = function(options, metadataStream) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = metadataStream;\n\n  options = options || {};\n\n  if (typeof options.remux !== 'undefined') {\n    this.remuxTracks = !!options.remux;\n  } else {\n    this.remuxTracks = true;\n  }\n\n  if (typeof options.keepOriginalTimestamps === 'boolean') {\n    this.keepOriginalTimestamps = options.keepOriginalTimestamps;\n  }\n\n  this.pendingTracks = [];\n  this.videoTrack = null;\n  this.pendingBoxes = [];\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingBytes = 0;\n  this.emittedTracks = 0;\n\n  CoalesceStream.prototype.init.call(this);\n\n  // Take output from multiple\n  this.push = function(output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    }\n    // buffer incoming id3 tags until the final flush\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n\n    // Add this track to the list of pending tracks and store\n    // important information required for the construction of\n    // the final segment\n    this.pendingTracks.push(output.track);\n    this.pendingBoxes.push(output.boxes);\n    this.pendingBytes += output.boxes.byteLength;\n\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n    }\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n    }\n  };\n};\n\nCoalesceStream.prototype = new Stream();\nCoalesceStream.prototype.flush = function(flushSource) {\n  var\n    offset = 0,\n    event = {\n      captions: [],\n      captionStreams: {},\n      metadata: [],\n      info: {}\n    },\n    caption,\n    id3,\n    initSegment,\n    timelineStartPts = 0,\n    i;\n\n  if (this.pendingTracks.length < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' &&\n        flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.remuxTracks) {\n      // Return until we have enough tracks from the pipeline to remux (if we\n      // are remuxing audio and video into a single MP4)\n      return;\n    } else if (this.pendingTracks.length === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.emittedTracks++;\n\n      if (this.emittedTracks >= this.numberOfTracks) {\n        this.trigger('done');\n        this.emittedTracks = 0;\n      }\n      return;\n    }\n  }\n\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n    VIDEO_PROPERTIES.forEach(function(prop) {\n      event.info[prop] = this.videoTrack[prop];\n    }, this);\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n    AUDIO_PROPERTIES.forEach(function(prop) {\n      event.info[prop] = this.audioTrack[prop];\n    }, this);\n  }\n\n  if (this.pendingTracks.length === 1) {\n    event.type = this.pendingTracks[0].type;\n  } else {\n    event.type = 'combined';\n  }\n\n  this.emittedTracks += this.pendingTracks.length;\n\n  initSegment = mp4.initSegment(this.pendingTracks);\n\n  // Create a new typed array to hold the init segment\n  event.initSegment = new Uint8Array(initSegment.byteLength);\n\n  // Create an init segment containing a moov\n  // and track definitions\n  event.initSegment.set(initSegment);\n\n  // Create a new typed array to hold the moof+mdats\n  event.data = new Uint8Array(this.pendingBytes);\n\n  // Append each moof+mdat (one per track) together\n  for (i = 0; i < this.pendingBoxes.length; i++) {\n    event.data.set(this.pendingBoxes[i], offset);\n    offset += this.pendingBoxes[i].byteLength;\n  }\n\n  // Translate caption PTS times into second offsets to match the\n  // video timeline for the segment, and add track info\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n\n    caption.startTime = caption.startPts;\n    if (!this.keepOriginalTimestamps) {\n      caption.startTime -= timelineStartPts;\n    }\n    caption.startTime /= 90e3;\n\n    caption.endTime = caption.endPts;\n    if (!this.keepOriginalTimestamps) {\n      caption.endTime -= timelineStartPts;\n    }\n    caption.endTime /= 90e3;\n\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  }\n\n  // Translate ID3 frame PTS times into second offsets to match the\n  // video timeline for the segment\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n\n    id3.cueTime = id3.pts;\n    if (!this.keepOriginalTimestamps) {\n      id3.cueTime -= timelineStartPts;\n    }\n    id3.cueTime /= 90e3;\n\n    event.metadata.push(id3);\n  }\n\n  // We add this to every single emitted segment even though we only need\n  // it for the first\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n  // Reset stream state\n  this.pendingTracks.length = 0;\n  this.videoTrack = null;\n  this.pendingBoxes.length = 0;\n  this.pendingCaptions.length = 0;\n  this.pendingBytes = 0;\n  this.pendingMetadata.length = 0;\n\n  // Emit the built segment\n  this.trigger('data', event);\n\n  // Only emit `done` if all tracks have been flushed and emitted\n  if (this.emittedTracks >= this.numberOfTracks) {\n    this.trigger('done');\n    this.emittedTracks = 0;\n  }\n};\n/**\n * A Stream that expects MP2T binary data as input and produces\n * corresponding media segments, suitable for use with Media Source\n * Extension (MSE) implementations that support the ISO BMFF byte\n * stream format, like Chrome.\n */\nTransmuxer = function(options) {\n  var\n    self = this,\n    hasFlushed = true,\n    videoTrack,\n    audioTrack;\n\n  Transmuxer.prototype.init.call(this);\n\n  options = options || {};\n  this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n  this.transmuxPipeline_ = {};\n\n  this.setupAacPipeline = function() {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n\n    pipeline.type = 'aac';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.aacStream = new AacStream();\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.aacStream;\n\n    pipeline.aacStream\n      .pipe(pipeline.audioTimestampRolloverStream)\n      .pipe(pipeline.adtsStream);\n    pipeline.aacStream\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\n      .pipe(pipeline.metadataStream)\n      .pipe(pipeline.coalesceStream);\n\n    pipeline.metadataStream.on('timestamp', function(frame) {\n      pipeline.aacStream.setTimestamp(frame.timeStamp);\n    });\n\n    pipeline.aacStream.on('data', function(data) {\n      if (data.type === 'timed-metadata' && !pipeline.audioSegmentStream) {\n        audioTrack = audioTrack || {\n          timelineStartInfo: {\n            baseMediaDecodeTime: self.baseMediaDecodeTime\n          },\n          codec: 'adts',\n          type: 'audio'\n        };\n        // hook up the audio segment stream to the first track with aac data\n        pipeline.coalesceStream.numberOfTracks++;\n        pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);\n        // Set up the final part of the audio pipeline\n        pipeline.adtsStream\n          .pipe(pipeline.audioSegmentStream)\n          .pipe(pipeline.coalesceStream);\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n\n  this.setupTsPipeline = function() {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n\n    pipeline.type = 'ts';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.packetStream = new m2ts.TransportPacketStream();\n    pipeline.parseStream = new m2ts.TransportParseStream();\n    pipeline.elementaryStream = new m2ts.ElementaryStream();\n    pipeline.videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.h264Stream = new H264Stream();\n    pipeline.captionStream = new m2ts.CaptionStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.packetStream;\n\n    // disassemble MPEG2-TS packets into elementary streams\n    pipeline.packetStream\n      .pipe(pipeline.parseStream)\n      .pipe(pipeline.elementaryStream);\n\n    // !!THIS ORDER IS IMPORTANT!!\n    // demux the streams\n    pipeline.elementaryStream\n      .pipe(pipeline.videoTimestampRolloverStream)\n      .pipe(pipeline.h264Stream);\n    pipeline.elementaryStream\n      .pipe(pipeline.audioTimestampRolloverStream)\n      .pipe(pipeline.adtsStream);\n\n    pipeline.elementaryStream\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\n      .pipe(pipeline.metadataStream)\n      .pipe(pipeline.coalesceStream);\n\n    // Hook up CEA-608/708 caption stream\n    pipeline.h264Stream.pipe(pipeline.captionStream)\n      .pipe(pipeline.coalesceStream);\n\n    pipeline.elementaryStream.on('data', function(data) {\n      var i;\n\n      if (data.type === 'metadata') {\n        i = data.tracks.length;\n\n        // scan the tracks listed in the metadata\n        while (i--) {\n          if (!videoTrack && data.tracks[i].type === 'video') {\n            videoTrack = data.tracks[i];\n            videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          } else if (!audioTrack && data.tracks[i].type === 'audio') {\n            audioTrack = data.tracks[i];\n            audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          }\n        }\n\n        // hook up the video segment stream to the first track with h264 data\n        if (videoTrack && !pipeline.videoSegmentStream) {\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);\n\n          pipeline.videoSegmentStream.on('timelineStartInfo', function(timelineStartInfo) {\n          // When video emits timelineStartInfo data after a flush, we forward that\n          // info to the AudioSegmentStream, if it exists, because video timeline\n          // data takes precedence.\n            if (audioTrack) {\n              audioTrack.timelineStartInfo = timelineStartInfo;\n              // On the first segment we trim AAC frames that exist before the\n              // very earliest DTS we have seen in video because Chrome will\n              // interpret any video track with a baseMediaDecodeTime that is\n              // non-zero as a gap.\n              pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts);\n            }\n          });\n\n          pipeline.videoSegmentStream.on('processedGopsInfo',\n            self.trigger.bind(self, 'gopInfo'));\n          pipeline.videoSegmentStream.on('segmentTimingInfo',\n            self.trigger.bind(self, 'videoSegmentTimingInfo'));\n\n          pipeline.videoSegmentStream.on('baseMediaDecodeTime', function(baseMediaDecodeTime) {\n            if (audioTrack) {\n              pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n            }\n          });\n\n          // Set up the final part of the video pipeline\n          pipeline.h264Stream\n            .pipe(pipeline.videoSegmentStream)\n            .pipe(pipeline.coalesceStream);\n        }\n\n        if (audioTrack && !pipeline.audioSegmentStream) {\n          // hook up the audio segment stream to the first track with aac data\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);\n\n          // Set up the final part of the audio pipeline\n          pipeline.adtsStream\n            .pipe(pipeline.audioSegmentStream)\n            .pipe(pipeline.coalesceStream);\n        }\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n\n  // hook up the segment streams once track metadata is delivered\n  this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {\n    var pipeline = this.transmuxPipeline_;\n\n    if (!options.keepOriginalTimestamps) {\n      this.baseMediaDecodeTime = baseMediaDecodeTime;\n    }\n\n    if (audioTrack) {\n      audioTrack.timelineStartInfo.dts = undefined;\n      audioTrack.timelineStartInfo.pts = undefined;\n      trackDecodeInfo.clearDtsInfo(audioTrack);\n      if (!options.keepOriginalTimestamps) {\n        audioTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n      }\n      if (pipeline.audioTimestampRolloverStream) {\n        pipeline.audioTimestampRolloverStream.discontinuity();\n      }\n    }\n    if (videoTrack) {\n      if (pipeline.videoSegmentStream) {\n        pipeline.videoSegmentStream.gopCache_ = [];\n        pipeline.videoTimestampRolloverStream.discontinuity();\n      }\n      videoTrack.timelineStartInfo.dts = undefined;\n      videoTrack.timelineStartInfo.pts = undefined;\n      trackDecodeInfo.clearDtsInfo(videoTrack);\n      pipeline.captionStream.reset();\n      if (!options.keepOriginalTimestamps) {\n        videoTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n      }\n    }\n\n    if (pipeline.timedMetadataTimestampRolloverStream) {\n      pipeline.timedMetadataTimestampRolloverStream.discontinuity();\n    }\n  };\n\n  this.setAudioAppendStart = function(timestamp) {\n    if (audioTrack) {\n      this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n    }\n  };\n\n  this.alignGopsWith = function(gopsToAlignWith) {\n    if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n      this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n    }\n  };\n\n  // feed incoming data to the front of the parsing pipeline\n  this.push = function(data) {\n    if (hasFlushed) {\n      var isAac = isLikelyAacData(data);\n\n      if (isAac && this.transmuxPipeline_.type !== 'aac') {\n        this.setupAacPipeline();\n      } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n        this.setupTsPipeline();\n      }\n      hasFlushed = false;\n    }\n    this.transmuxPipeline_.headOfPipeline.push(data);\n  };\n\n  // flush any buffered data\n  this.flush = function() {\n      hasFlushed = true;\n    // Start at the top of the pipeline and flush all pending work\n    this.transmuxPipeline_.headOfPipeline.flush();\n  };\n\n  // Caption data has to be reset when seeking outside buffered range\n  this.resetCaptions = function() {\n    if (this.transmuxPipeline_.captionStream) {\n      this.transmuxPipeline_.captionStream.reset();\n    }\n  };\n\n};\nTransmuxer.prototype = new Stream();\n\nmodule.exports = {\n  Transmuxer: Transmuxer,\n  VideoSegmentStream: VideoSegmentStream,\n  AudioSegmentStream: AudioSegmentStream,\n  AUDIO_PROPERTIES: AUDIO_PROPERTIES,\n  VIDEO_PROPERTIES: VIDEO_PROPERTIES,\n  // exported for testing\n  generateVideoSegmentTimingInfo: generateVideoSegmentTimingInfo\n};\n","'use strict';\n\nvar ExpGolomb;\n\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n * scheme used by h264.\n */\nExpGolomb = function(workingData) {\n  var\n    // the number of bytes left to examine in workingData\n    workingBytesAvailable = workingData.byteLength,\n\n    // the current word being examined\n    workingWord = 0, // :uint\n\n    // the number of bits left to examine in the current word\n    workingBitsAvailable = 0; // :uint;\n\n  // ():uint\n  this.length = function() {\n    return (8 * workingBytesAvailable);\n  };\n\n  // ():uint\n  this.bitsAvailable = function() {\n    return (8 * workingBytesAvailable) + workingBitsAvailable;\n  };\n\n  // ():void\n  this.loadWord = function() {\n    var\n      position = workingData.byteLength - workingBytesAvailable,\n      workingBytes = new Uint8Array(4),\n      availableBytes = Math.min(4, workingBytesAvailable);\n\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n\n    workingBytes.set(workingData.subarray(position,\n                                          position + availableBytes));\n    workingWord = new DataView(workingBytes.buffer).getUint32(0);\n\n    // track the amount of workingData that has been processed\n    workingBitsAvailable = availableBytes * 8;\n    workingBytesAvailable -= availableBytes;\n  };\n\n  // (count:int):void\n  this.skipBits = function(count) {\n    var skipBytes; // :int\n    if (workingBitsAvailable > count) {\n      workingWord          <<= count;\n      workingBitsAvailable -= count;\n    } else {\n      count -= workingBitsAvailable;\n      skipBytes = Math.floor(count / 8);\n\n      count -= (skipBytes * 8);\n      workingBytesAvailable -= skipBytes;\n\n      this.loadWord();\n\n      workingWord <<= count;\n      workingBitsAvailable -= count;\n    }\n  };\n\n  // (size:int):uint\n  this.readBits = function(size) {\n    var\n      bits = Math.min(workingBitsAvailable, size), // :uint\n      valu = workingWord >>> (32 - bits); // :uint\n    // if size > 31, handle error\n    workingBitsAvailable -= bits;\n    if (workingBitsAvailable > 0) {\n      workingWord <<= bits;\n    } else if (workingBytesAvailable > 0) {\n      this.loadWord();\n    }\n\n    bits = size - bits;\n    if (bits > 0) {\n      return valu << bits | this.readBits(bits);\n    }\n    return valu;\n  };\n\n  // ():uint\n  this.skipLeadingZeros = function() {\n    var leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n      if ((workingWord & (0x80000000 >>> leadingZeroCount)) !== 0) {\n        // the first bit of working word is 1\n        workingWord <<= leadingZeroCount;\n        workingBitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n\n    // we exhausted workingWord and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLeadingZeros();\n  };\n\n  // ():void\n  this.skipUnsignedExpGolomb = function() {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():void\n  this.skipExpGolomb = function() {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():uint\n  this.readUnsignedExpGolomb = function() {\n    var clz = this.skipLeadingZeros(); // :uint\n    return this.readBits(clz + 1) - 1;\n  };\n\n  // ():int\n  this.readExpGolomb = function() {\n    var valu = this.readUnsignedExpGolomb(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return (1 + valu) >>> 1; // add 1 to make it even, and divide by 2\n    }\n    return -1 * (valu >>> 1); // divide by two then make it negative\n  };\n\n  // Some convenience functions\n  // :Boolean\n  this.readBoolean = function() {\n    return this.readBits(1) === 1;\n  };\n\n  // ():int\n  this.readUnsignedByte = function() {\n    return this.readBits(8);\n  };\n\n  this.loadWord();\n};\n\nmodule.exports = ExpGolomb;\n","var\n  ONE_SECOND_IN_TS = 90000, // 90kHz clock\n  secondsToVideoTs,\n  secondsToAudioTs,\n  videoTsToSeconds,\n  audioTsToSeconds,\n  audioTsToVideoTs,\n  videoTsToAudioTs;\n\nsecondsToVideoTs = function(seconds) {\n  return seconds * ONE_SECOND_IN_TS;\n};\n\nsecondsToAudioTs = function(seconds, sampleRate) {\n  return seconds * sampleRate;\n};\n\nvideoTsToSeconds = function(timestamp) {\n  return timestamp / ONE_SECOND_IN_TS;\n};\n\naudioTsToSeconds = function(timestamp, sampleRate) {\n  return timestamp / sampleRate;\n};\n\naudioTsToVideoTs = function(timestamp, sampleRate) {\n  return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n};\n\nvideoTsToAudioTs = function(timestamp, sampleRate) {\n  return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n};\n\nmodule.exports = {\n  secondsToVideoTs: secondsToVideoTs,\n  secondsToAudioTs: secondsToAudioTs,\n  videoTsToSeconds: videoTsToSeconds,\n  audioTsToSeconds: audioTsToSeconds,\n  audioTsToVideoTs: audioTsToVideoTs,\n  videoTsToAudioTs: videoTsToAudioTs\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about TS Segments.\n */\n'use strict';\n\nvar StreamTypes = require('./stream-types.js');\n\nvar parsePid = function(packet) {\n  var pid = packet[1] & 0x1f;\n  pid <<= 8;\n  pid |= packet[2];\n  return pid;\n};\n\nvar parsePayloadUnitStartIndicator = function(packet) {\n  return !!(packet[1] & 0x40);\n};\n\nvar parseAdaptionField = function(packet) {\n  var offset = 0;\n  // if an adaption field is present, its length is specified by the\n  // fifth byte of the TS packet header. The adaptation field is\n  // used to add stuffing to PES packets that don't fill a complete\n  // TS packet, and to specify some forms of timing and control data\n  // that we do not currently use.\n  if (((packet[3] & 0x30) >>> 4) > 0x01) {\n    offset += packet[4] + 1;\n  }\n  return offset;\n};\n\nvar parseType = function(packet, pmtPid) {\n  var pid = parsePid(packet);\n  if (pid === 0) {\n    return 'pat';\n  } else if (pid === pmtPid) {\n    return 'pmt';\n  } else if (pmtPid) {\n    return 'pes';\n  }\n  return null;\n};\n\nvar parsePat = function(packet) {\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  var offset = 4 + parseAdaptionField(packet);\n\n  if (pusi) {\n    offset += packet[offset] + 1;\n  }\n\n  return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];\n};\n\nvar parsePmt = function(packet) {\n  var programMapTable = {};\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  var payloadOffset = 4 + parseAdaptionField(packet);\n\n  if (pusi) {\n    payloadOffset += packet[payloadOffset] + 1;\n  }\n\n  // PMTs can be sent ahead of the time when they should actually\n  // take effect. We don't believe this should ever be the case\n  // for HLS but we'll ignore \"forward\" PMT declarations if we see\n  // them. Future PMT declarations have the current_next_indicator\n  // set to zero.\n  if (!(packet[payloadOffset + 5] & 0x01)) {\n    return;\n  }\n\n  var sectionLength, tableEnd, programInfoLength;\n  // the mapping table ends at the end of the current section\n  sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];\n  tableEnd = 3 + sectionLength - 4;\n\n  // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n  programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11];\n\n  // advance the offset to the first entry in the mapping table\n  var offset = 12 + programInfoLength;\n  while (offset < tableEnd) {\n    var i = payloadOffset + offset;\n    // add an entry that maps the elementary_pid to the stream_type\n    programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i];\n\n    // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n    offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;\n  }\n  return programMapTable;\n};\n\nvar parsePesType = function(packet, programMapTable) {\n  var pid = parsePid(packet);\n  var type = programMapTable[pid];\n  switch (type) {\n    case StreamTypes.H264_STREAM_TYPE:\n      return 'video';\n    case StreamTypes.ADTS_STREAM_TYPE:\n      return 'audio';\n    case StreamTypes.METADATA_STREAM_TYPE:\n      return 'timed-metadata';\n    default:\n      return null;\n  }\n};\n\nvar parsePesTime = function(packet) {\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  if (!pusi) {\n    return null;\n  }\n\n  var offset = 4 + parseAdaptionField(packet);\n\n  if (offset >= packet.byteLength) {\n    // From the H 222.0 MPEG-TS spec\n    // \"For transport stream packets carrying PES packets, stuffing is needed when there\n    //  is insufficient PES packet data to completely fill the transport stream packet\n    //  payload bytes. Stuffing is accomplished by defining an adaptation field longer than\n    //  the sum of the lengths of the data elements in it, so that the payload bytes\n    //  remaining after the adaptation field exactly accommodates the available PES packet\n    //  data.\"\n    //\n    // If the offset is >= the length of the packet, then the packet contains no data\n    // and instead is just adaption field stuffing bytes\n    return null;\n  }\n\n  var pes = null;\n  var ptsDtsFlags;\n\n  // PES packets may be annotated with a PTS value, or a PTS value\n  // and a DTS value. Determine what combination of values is\n  // available to work with.\n  ptsDtsFlags = packet[offset + 7];\n\n  // PTS and DTS are normally stored as a 33-bit number.  Javascript\n  // performs all bitwise operations on 32-bit integers but javascript\n  // supports a much greater range (52-bits) of integer using standard\n  // mathematical operations.\n  // We construct a 31-bit value using bitwise operators over the 31\n  // most significant bits and then multiply by 4 (equal to a left-shift\n  // of 2) before we add the final 2 least significant bits of the\n  // timestamp (equal to an OR.)\n  if (ptsDtsFlags & 0xC0) {\n    pes = {};\n    // the PTS and DTS are not written out directly. For information\n    // on how they are encoded, see\n    // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n    pes.pts = (packet[offset + 9] & 0x0E) << 27 |\n      (packet[offset + 10] & 0xFF) << 20 |\n      (packet[offset + 11] & 0xFE) << 12 |\n      (packet[offset + 12] & 0xFF) <<  5 |\n      (packet[offset + 13] & 0xFE) >>>  3;\n    pes.pts *= 4; // Left shift by 2\n    pes.pts += (packet[offset + 13] & 0x06) >>> 1; // OR by the two LSBs\n    pes.dts = pes.pts;\n    if (ptsDtsFlags & 0x40) {\n      pes.dts = (packet[offset + 14] & 0x0E) << 27 |\n        (packet[offset + 15] & 0xFF) << 20 |\n        (packet[offset + 16] & 0xFE) << 12 |\n        (packet[offset + 17] & 0xFF) << 5 |\n        (packet[offset + 18] & 0xFE) >>> 3;\n      pes.dts *= 4; // Left shift by 2\n      pes.dts += (packet[offset + 18] & 0x06) >>> 1; // OR by the two LSBs\n    }\n  }\n  return pes;\n};\n\nvar parseNalUnitType = function(type) {\n  switch (type) {\n    case 0x05:\n      return 'slice_layer_without_partitioning_rbsp_idr';\n    case 0x06:\n      return 'sei_rbsp';\n    case 0x07:\n      return 'seq_parameter_set_rbsp';\n    case 0x08:\n      return 'pic_parameter_set_rbsp';\n    case 0x09:\n      return 'access_unit_delimiter_rbsp';\n    default:\n      return null;\n  }\n};\n\nvar videoPacketContainsKeyFrame = function(packet) {\n  var offset = 4 + parseAdaptionField(packet);\n  var frameBuffer = packet.subarray(offset);\n  var frameI = 0;\n  var frameSyncPoint = 0;\n  var foundKeyFrame = false;\n  var nalType;\n\n  // advance the sync point to a NAL start, if necessary\n  for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {\n    if (frameBuffer[frameSyncPoint + 2] === 1) {\n      // the sync point is properly aligned\n      frameI = frameSyncPoint + 5;\n      break;\n    }\n  }\n\n  while (frameI < frameBuffer.byteLength) {\n    // look at the current byte to determine if we've hit the end of\n    // a NAL unit boundary\n    switch (frameBuffer[frameI]) {\n    case 0:\n      // skip past non-sync sequences\n      if (frameBuffer[frameI - 1] !== 0) {\n        frameI += 2;\n        break;\n      } else if (frameBuffer[frameI - 2] !== 0) {\n        frameI++;\n        break;\n      }\n\n      if (frameSyncPoint + 3 !== frameI - 2) {\n        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n        if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n          foundKeyFrame = true;\n        }\n      }\n\n      // drop trailing zeroes\n      do {\n        frameI++;\n      } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);\n      frameSyncPoint = frameI - 2;\n      frameI += 3;\n      break;\n    case 1:\n      // skip past non-sync sequences\n      if (frameBuffer[frameI - 1] !== 0 ||\n          frameBuffer[frameI - 2] !== 0) {\n        frameI += 3;\n        break;\n      }\n\n      nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n      if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n        foundKeyFrame = true;\n      }\n      frameSyncPoint = frameI - 2;\n      frameI += 3;\n      break;\n    default:\n      // the current byte isn't a one or zero, so it cannot be part\n      // of a sync sequence\n      frameI += 3;\n      break;\n    }\n  }\n  frameBuffer = frameBuffer.subarray(frameSyncPoint);\n  frameI -= frameSyncPoint;\n  frameSyncPoint = 0;\n  // parse the final nal\n  if (frameBuffer && frameBuffer.byteLength > 3) {\n    nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n    if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n      foundKeyFrame = true;\n    }\n  }\n\n  return foundKeyFrame;\n};\n\n\nmodule.exports = {\n  parseType: parseType,\n  parsePat: parsePat,\n  parsePmt: parsePmt,\n  parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,\n  parsePesType: parsePesType,\n  parsePesTime: parsePesTime,\n  videoPacketContainsKeyFrame: videoPacketContainsKeyFrame\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2014 Brightcove\n * All rights reserved.\n *\n * A lightweight readable stream implemention that handles event dispatching.\n * Objects that inherit from streams should call init in their constructors.\n */\n'use strict';\n\nvar Stream = function() {\n  this.init = function() {\n    var listeners = {};\n    /**\n     * Add a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} the callback to be invoked when an event of\n     * the specified type occurs\n     */\n    this.on = function(type, listener) {\n      if (!listeners[type]) {\n        listeners[type] = [];\n      }\n      listeners[type] = listeners[type].concat(listener);\n    };\n    /**\n     * Remove a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} a function previously registered for this\n     * type of event through `on`\n     */\n    this.off = function(type, listener) {\n      var index;\n      if (!listeners[type]) {\n        return false;\n      }\n      index = listeners[type].indexOf(listener);\n      listeners[type] = listeners[type].slice();\n      listeners[type].splice(index, 1);\n      return index > -1;\n    };\n    /**\n     * Trigger an event of the specified type on this stream. Any additional\n     * arguments to this function are passed as parameters to event listeners.\n     * @param type {string} the event name\n     */\n    this.trigger = function(type) {\n      var callbacks, i, length, args;\n      callbacks = listeners[type];\n      if (!callbacks) {\n        return;\n      }\n      // Slicing the arguments on every invocation of this method\n      // can add a significant amount of overhead. Avoid the\n      // intermediate object creation for the common case of a\n      // single callback argument\n      if (arguments.length === 2) {\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].call(this, arguments[1]);\n        }\n      } else {\n        args = [];\n        i = arguments.length;\n        for (i = 1; i < arguments.length; ++i) {\n          args.push(arguments[i]);\n        }\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n    };\n    /**\n     * Destroys the stream and cleans up.\n     */\n    this.dispose = function() {\n      listeners = {};\n    };\n  };\n};\n\n/**\n * Forwards all `data` events on this stream to the destination stream. The\n * destination stream should provide a method `push` to receive the data\n * events as they arrive.\n * @param destination {stream} the stream that will receive all `data` events\n * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n *                            when the current stream emits a 'done' event\n * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n */\nStream.prototype.pipe = function(destination) {\n  this.on('data', function(data) {\n    destination.push(data);\n  });\n\n  this.on('done', function(flushSource) {\n    destination.flush(flushSource);\n  });\n\n  return destination;\n};\n\n// Default stream functions that are expected to be overridden to perform\n// actual work. These are provided by the prototype as a sort of no-op\n// implementation so that we don't have to check for their existence in the\n// `pipe` function above.\nStream.prototype.push = function(data) {\n  this.trigger('data', data);\n};\n\nStream.prototype.flush = function(flushSource) {\n  this.trigger('done', flushSource);\n};\n\nmodule.exports = Stream;\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n\n'use strict';\n\n// -----------------\n// Link To Transport\n// -----------------\n\nvar Stream = require('../utils/stream');\nvar cea708Parser = require('../tools/caption-packet-parser');\n\nvar CaptionStream = function() {\n\n  CaptionStream.prototype.init.call(this);\n\n  this.captionPackets_ = [];\n\n  this.ccStreams_ = [\n    new Cea608Stream(0, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(0, 1), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n  ];\n\n  this.reset();\n\n  // forward data and done events from CCs to this CaptionStream\n  this.ccStreams_.forEach(function(cc) {\n    cc.on('data', this.trigger.bind(this, 'data'));\n    cc.on('done', this.trigger.bind(this, 'done'));\n  }, this);\n\n};\n\nCaptionStream.prototype = new Stream();\nCaptionStream.prototype.push = function(event) {\n  var sei, userData, newCaptionPackets;\n\n  // only examine SEI NALs\n  if (event.nalUnitType !== 'sei_rbsp') {\n    return;\n  }\n\n  // parse the sei\n  sei = cea708Parser.parseSei(event.escapedRBSP);\n\n  // ignore everything but user_data_registered_itu_t_t35\n  if (sei.payloadType !== cea708Parser.USER_DATA_REGISTERED_ITU_T_T35) {\n    return;\n  }\n\n  // parse out the user data payload\n  userData = cea708Parser.parseUserData(sei);\n\n  // ignore unrecognized userData\n  if (!userData) {\n    return;\n  }\n\n  // Sometimes, the same segment # will be downloaded twice. To stop the\n  // caption data from being processed twice, we track the latest dts we've\n  // received and ignore everything with a dts before that. However, since\n  // data for a specific dts can be split across packets on either side of\n  // a segment boundary, we need to make sure we *don't* ignore the packets\n  // from the *next* segment that have dts === this.latestDts_. By constantly\n  // tracking the number of packets received with dts === this.latestDts_, we\n  // know how many should be ignored once we start receiving duplicates.\n  if (event.dts < this.latestDts_) {\n    // We've started getting older data, so set the flag.\n    this.ignoreNextEqualDts_ = true;\n    return;\n  } else if ((event.dts === this.latestDts_) && (this.ignoreNextEqualDts_)) {\n    this.numSameDts_--;\n    if (!this.numSameDts_) {\n      // We've received the last duplicate packet, time to start processing again\n      this.ignoreNextEqualDts_ = false;\n    }\n    return;\n  }\n\n  // parse out CC data packets and save them for later\n  newCaptionPackets = cea708Parser.parseCaptionPackets(event.pts, userData);\n  this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);\n  if (this.latestDts_ !== event.dts) {\n    this.numSameDts_ = 0;\n  }\n  this.numSameDts_++;\n  this.latestDts_ = event.dts;\n};\n\nCaptionStream.prototype.flush = function() {\n  // make sure we actually parsed captions before proceeding\n  if (!this.captionPackets_.length) {\n    this.ccStreams_.forEach(function(cc) {\n      cc.flush();\n    }, this);\n    return;\n  }\n\n  // In Chrome, the Array#sort function is not stable so add a\n  // presortIndex that we can use to ensure we get a stable-sort\n  this.captionPackets_.forEach(function(elem, idx) {\n    elem.presortIndex = idx;\n  });\n\n  // sort caption byte-pairs based on their PTS values\n  this.captionPackets_.sort(function(a, b) {\n    if (a.pts === b.pts) {\n      return a.presortIndex - b.presortIndex;\n    }\n    return a.pts - b.pts;\n  });\n\n  this.captionPackets_.forEach(function(packet) {\n    if (packet.type < 2) {\n      // Dispatch packet to the right Cea608Stream\n      this.dispatchCea608Packet(packet);\n    }\n    // this is where an 'else' would go for a dispatching packets\n    // to a theoretical Cea708Stream that handles SERVICEn data\n  }, this);\n\n  this.captionPackets_.length = 0;\n  this.ccStreams_.forEach(function(cc) {\n    cc.flush();\n  }, this);\n  return;\n};\n\nCaptionStream.prototype.reset = function() {\n  this.latestDts_ = null;\n  this.ignoreNextEqualDts_ = false;\n  this.numSameDts_ = 0;\n  this.activeCea608Channel_ = [null, null];\n  this.ccStreams_.forEach(function(ccStream) {\n    ccStream.reset();\n  });\n};\n\nCaptionStream.prototype.dispatchCea608Packet = function(packet) {\n  // NOTE: packet.type is the CEA608 field\n  if (this.setsChannel1Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 0;\n  } else if (this.setsChannel2Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 1;\n  }\n  if (this.activeCea608Channel_[packet.type] === null) {\n    // If we haven't received anything to set the active channel, discard the\n    // data; we don't want jumbled captions\n    return;\n  }\n  this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n};\n\nCaptionStream.prototype.setsChannel1Active = function(packet) {\n  return ((packet.ccData & 0x7800) === 0x1000);\n};\nCaptionStream.prototype.setsChannel2Active = function(packet) {\n  return ((packet.ccData & 0x7800) === 0x1800);\n};\n\n// ----------------------\n// Session to Application\n// ----------------------\n\n// This hash maps non-ASCII, special, and extended character codes to their\n// proper Unicode equivalent. The first keys that are only a single byte\n// are the non-standard ASCII characters, which simply map the CEA608 byte\n// to the standard ASCII/Unicode. The two-byte keys that follow are the CEA608\n// character codes, but have their MSB bitmasked with 0x03 so that a lookup\n// can be performed regardless of the field and data channel on which the\n// character code was received.\nvar CHARACTER_TRANSLATION = {\n  0x2a: 0xe1,     // á\n  0x5c: 0xe9,     // é\n  0x5e: 0xed,     // í\n  0x5f: 0xf3,     // ó\n  0x60: 0xfa,     // ú\n  0x7b: 0xe7,     // ç\n  0x7c: 0xf7,     // ÷\n  0x7d: 0xd1,     // Ñ\n  0x7e: 0xf1,     // ñ\n  0x7f: 0x2588,   // █\n  0x0130: 0xae,   // ®\n  0x0131: 0xb0,   // °\n  0x0132: 0xbd,   // ½\n  0x0133: 0xbf,   // ¿\n  0x0134: 0x2122, // ™\n  0x0135: 0xa2,   // ¢\n  0x0136: 0xa3,   // £\n  0x0137: 0x266a, // ♪\n  0x0138: 0xe0,   // à\n  0x0139: 0xa0,   //\n  0x013a: 0xe8,   // è\n  0x013b: 0xe2,   // â\n  0x013c: 0xea,   // ê\n  0x013d: 0xee,   // î\n  0x013e: 0xf4,   // ô\n  0x013f: 0xfb,   // û\n  0x0220: 0xc1,   // Á\n  0x0221: 0xc9,   // É\n  0x0222: 0xd3,   // Ó\n  0x0223: 0xda,   // Ú\n  0x0224: 0xdc,   // Ü\n  0x0225: 0xfc,   // ü\n  0x0226: 0x2018, // ‘\n  0x0227: 0xa1,   // ¡\n  0x0228: 0x2a,   // *\n  0x0229: 0x27,   // '\n  0x022a: 0x2014, // —\n  0x022b: 0xa9,   // ©\n  0x022c: 0x2120, // ℠\n  0x022d: 0x2022, // •\n  0x022e: 0x201c, // “\n  0x022f: 0x201d, // ”\n  0x0230: 0xc0,   // À\n  0x0231: 0xc2,   // Â\n  0x0232: 0xc7,   // Ç\n  0x0233: 0xc8,   // È\n  0x0234: 0xca,   // Ê\n  0x0235: 0xcb,   // Ë\n  0x0236: 0xeb,   // ë\n  0x0237: 0xce,   // Î\n  0x0238: 0xcf,   // Ï\n  0x0239: 0xef,   // ï\n  0x023a: 0xd4,   // Ô\n  0x023b: 0xd9,   // Ù\n  0x023c: 0xf9,   // ù\n  0x023d: 0xdb,   // Û\n  0x023e: 0xab,   // «\n  0x023f: 0xbb,   // »\n  0x0320: 0xc3,   // Ã\n  0x0321: 0xe3,   // ã\n  0x0322: 0xcd,   // Í\n  0x0323: 0xcc,   // Ì\n  0x0324: 0xec,   // ì\n  0x0325: 0xd2,   // Ò\n  0x0326: 0xf2,   // ò\n  0x0327: 0xd5,   // Õ\n  0x0328: 0xf5,   // õ\n  0x0329: 0x7b,   // {\n  0x032a: 0x7d,   // }\n  0x032b: 0x5c,   // \\\n  0x032c: 0x5e,   // ^\n  0x032d: 0x5f,   // _\n  0x032e: 0x7c,   // |\n  0x032f: 0x7e,   // ~\n  0x0330: 0xc4,   // Ä\n  0x0331: 0xe4,   // ä\n  0x0332: 0xd6,   // Ö\n  0x0333: 0xf6,   // ö\n  0x0334: 0xdf,   // ß\n  0x0335: 0xa5,   // ¥\n  0x0336: 0xa4,   // ¤\n  0x0337: 0x2502, // │\n  0x0338: 0xc5,   // Å\n  0x0339: 0xe5,   // å\n  0x033a: 0xd8,   // Ø\n  0x033b: 0xf8,   // ø\n  0x033c: 0x250c, // ┌\n  0x033d: 0x2510, // ┐\n  0x033e: 0x2514, // └\n  0x033f: 0x2518  // ┘\n};\n\nvar getCharFromCode = function(code) {\n  if (code === null) {\n    return '';\n  }\n  code = CHARACTER_TRANSLATION[code] || code;\n  return String.fromCharCode(code);\n};\n\n// the index of the last row in a CEA-608 display buffer\nvar BOTTOM_ROW = 14;\n\n// This array is used for mapping PACs -> row #, since there's no way of\n// getting it through bit logic.\nvar ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620,\n            0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420];\n\n// CEA-608 captions are rendered onto a 34x15 matrix of character\n// cells. The \"bottom\" row is the last element in the outer array.\nvar createDisplayBuffer = function() {\n  var result = [], i = BOTTOM_ROW + 1;\n  while (i--) {\n    result.push('');\n  }\n  return result;\n};\n\nvar Cea608Stream = function(field, dataChannel) {\n  Cea608Stream.prototype.init.call(this);\n\n  this.field_ = field || 0;\n  this.dataChannel_ = dataChannel || 0;\n\n  this.name_ = 'CC' + (((this.field_ << 1) | this.dataChannel_) + 1);\n\n  this.setConstants();\n  this.reset();\n\n  this.push = function(packet) {\n    var data, swap, char0, char1, text;\n    // remove the parity bits\n    data = packet.ccData & 0x7f7f;\n\n    // ignore duplicate control codes; the spec demands they're sent twice\n    if (data === this.lastControlCode_) {\n      this.lastControlCode_ = null;\n      return;\n    }\n\n    // Store control codes\n    if ((data & 0xf000) === 0x1000) {\n      this.lastControlCode_ = data;\n    } else if (data !== this.PADDING_) {\n      this.lastControlCode_ = null;\n    }\n\n    char0 = data >>> 8;\n    char1 = data & 0xff;\n\n    if (data === this.PADDING_) {\n      return;\n\n    } else if (data === this.RESUME_CAPTION_LOADING_) {\n      this.mode_ = 'popOn';\n\n    } else if (data === this.END_OF_CAPTION_) {\n      // If an EOC is received while in paint-on mode, the displayed caption\n      // text should be swapped to non-displayed memory as if it was a pop-on\n      // caption. Because of that, we should explicitly switch back to pop-on\n      // mode\n      this.mode_ = 'popOn';\n      this.clearFormatting(packet.pts);\n      // if a caption was being displayed, it's gone now\n      this.flushDisplayed(packet.pts);\n\n      // flip memory\n      swap = this.displayed_;\n      this.displayed_ = this.nonDisplayed_;\n      this.nonDisplayed_ = swap;\n\n      // start measuring the time to display the caption\n      this.startPts_ = packet.pts;\n\n    } else if (data === this.ROLL_UP_2_ROWS_) {\n      this.rollUpRows_ = 2;\n      this.setRollUp(packet.pts);\n    } else if (data === this.ROLL_UP_3_ROWS_) {\n      this.rollUpRows_ = 3;\n      this.setRollUp(packet.pts);\n    } else if (data === this.ROLL_UP_4_ROWS_) {\n      this.rollUpRows_ = 4;\n      this.setRollUp(packet.pts);\n    } else if (data === this.CARRIAGE_RETURN_) {\n      this.clearFormatting(packet.pts);\n      this.flushDisplayed(packet.pts);\n      this.shiftRowsUp_();\n      this.startPts_ = packet.pts;\n\n    } else if (data === this.BACKSPACE_) {\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n      } else {\n        this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n      }\n    } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n      this.flushDisplayed(packet.pts);\n      this.displayed_ = createDisplayBuffer();\n    } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n      this.nonDisplayed_ = createDisplayBuffer();\n\n    } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n      if (this.mode_ !== 'paintOn') {\n        // NOTE: This should be removed when proper caption positioning is\n        // implemented\n        this.flushDisplayed(packet.pts);\n        this.displayed_ = createDisplayBuffer();\n      }\n      this.mode_ = 'paintOn';\n      this.startPts_ = packet.pts;\n\n    // Append special characters to caption text\n    } else if (this.isSpecialCharacter(char0, char1)) {\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n    // Append extended characters to caption text\n    } else if (this.isExtCharacter(char0, char1)) {\n      // Extended characters always follow their \"non-extended\" equivalents.\n      // IE if a \"è\" is desired, you'll always receive \"eè\"; non-compliant\n      // decoders are supposed to drop the \"è\", while compliant decoders\n      // backspace the \"e\" and insert \"è\".\n\n      // Delete the previous character\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n      } else {\n        this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n      }\n\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n    // Process mid-row codes\n    } else if (this.isMidRowCode(char0, char1)) {\n      // Attributes are not additive, so clear all formatting\n      this.clearFormatting(packet.pts);\n\n      // According to the standard, mid-row codes\n      // should be replaced with spaces, so add one now\n      this[this.mode_](packet.pts, ' ');\n      this.column_++;\n\n      if ((char1 & 0xe) === 0xe) {\n        this.addFormatting(packet.pts, ['i']);\n      }\n\n      if ((char1 & 0x1) === 0x1) {\n        this.addFormatting(packet.pts, ['u']);\n      }\n\n    // Detect offset control codes and adjust cursor\n    } else if (this.isOffsetControlCode(char0, char1)) {\n      // Cursor position is set by indent PAC (see below) in 4-column\n      // increments, with an additional offset code of 1-3 to reach any\n      // of the 32 columns specified by CEA-608. So all we need to do\n      // here is increment the column cursor by the given offset.\n      this.column_ += (char1 & 0x03);\n\n    // Detect PACs (Preamble Address Codes)\n    } else if (this.isPAC(char0, char1)) {\n\n      // There's no logic for PAC -> row mapping, so we have to just\n      // find the row code in an array and use its index :(\n      var row = ROWS.indexOf(data & 0x1f20);\n\n      // Configure the caption window if we're in roll-up mode\n      if (this.mode_ === 'rollUp') {\n        // This implies that the base row is incorrectly set.\n        // As per the recommendation in CEA-608(Base Row Implementation), defer to the number\n        // of roll-up rows set.\n        if (row - this.rollUpRows_ + 1 < 0) {\n          row = this.rollUpRows_ - 1;\n        }\n\n        this.setRollUp(packet.pts, row);\n      }\n\n      if (row !== this.row_) {\n        // formatting is only persistent for current row\n        this.clearFormatting(packet.pts);\n        this.row_ = row;\n      }\n      // All PACs can apply underline, so detect and apply\n      // (All odd-numbered second bytes set underline)\n      if ((char1 & 0x1) && (this.formatting_.indexOf('u') === -1)) {\n          this.addFormatting(packet.pts, ['u']);\n      }\n\n      if ((data & 0x10) === 0x10) {\n        // We've got an indent level code. Each successive even number\n        // increments the column cursor by 4, so we can get the desired\n        // column position by bit-shifting to the right (to get n/2)\n        // and multiplying by 4.\n        this.column_ = ((data & 0xe) >> 1) * 4;\n      }\n\n      if (this.isColorPAC(char1)) {\n        // it's a color code, though we only support white, which\n        // can be either normal or italicized. white italics can be\n        // either 0x4e or 0x6e depending on the row, so we just\n        // bitwise-and with 0xe to see if italics should be turned on\n        if ((char1 & 0xe) === 0xe) {\n          this.addFormatting(packet.pts, ['i']);\n        }\n      }\n\n    // We have a normal character in char0, and possibly one in char1\n    } else if (this.isNormalChar(char0)) {\n      if (char1 === 0x00) {\n        char1 = null;\n      }\n      text = getCharFromCode(char0);\n      text += getCharFromCode(char1);\n      this[this.mode_](packet.pts, text);\n      this.column_ += text.length;\n\n    } // finish data processing\n\n  };\n};\nCea608Stream.prototype = new Stream();\n// Trigger a cue point that captures the current state of the\n// display buffer\nCea608Stream.prototype.flushDisplayed = function(pts) {\n  var content = this.displayed_\n    // remove spaces from the start and end of the string\n    .map(function(row) {\n      try {\n        return row.trim();\n      } catch (e) {\n        // Ordinarily, this shouldn't happen. However, caption\n        // parsing errors should not throw exceptions and\n        // break playback.\n        // eslint-disable-next-line no-console\n        console.error('Skipping malformed caption.');\n        return '';\n      }\n    })\n    // combine all text rows to display in one cue\n    .join('\\n')\n    // and remove blank rows from the start and end, but not the middle\n    .replace(/^\\n+|\\n+$/g, '');\n\n  if (content.length) {\n    this.trigger('data', {\n      startPts: this.startPts_,\n      endPts: pts,\n      text: content,\n      stream: this.name_\n    });\n  }\n};\n\n/**\n * Zero out the data, used for startup and on seek\n */\nCea608Stream.prototype.reset = function() {\n  this.mode_ = 'popOn';\n  // When in roll-up mode, the index of the last row that will\n  // actually display captions. If a caption is shifted to a row\n  // with a lower index than this, it is cleared from the display\n  // buffer\n  this.topRow_ = 0;\n  this.startPts_ = 0;\n  this.displayed_ = createDisplayBuffer();\n  this.nonDisplayed_ = createDisplayBuffer();\n  this.lastControlCode_ = null;\n\n  // Track row and column for proper line-breaking and spacing\n  this.column_ = 0;\n  this.row_ = BOTTOM_ROW;\n  this.rollUpRows_ = 2;\n\n  // This variable holds currently-applied formatting\n  this.formatting_ = [];\n};\n\n/**\n * Sets up control code and related constants for this instance\n */\nCea608Stream.prototype.setConstants = function() {\n  // The following attributes have these uses:\n  // ext_ :    char0 for mid-row codes, and the base for extended\n  //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n  //           extended codes)\n  // control_: char0 for control codes, except byte-shifted to the\n  //           left so that we can do this.control_ | CONTROL_CODE\n  // offset_:  char0 for tab offset codes\n  //\n  // It's also worth noting that control codes, and _only_ control codes,\n  // differ between field 1 and field2. Field 2 control codes are always\n  // their field 1 value plus 1. That's why there's the \"| field\" on the\n  // control value.\n  if (this.dataChannel_ === 0) {\n    this.BASE_     = 0x10;\n    this.EXT_      = 0x11;\n    this.CONTROL_  = (0x14 | this.field_) << 8;\n    this.OFFSET_   = 0x17;\n  } else if (this.dataChannel_ === 1) {\n    this.BASE_     = 0x18;\n    this.EXT_      = 0x19;\n    this.CONTROL_  = (0x1c | this.field_) << 8;\n    this.OFFSET_   = 0x1f;\n  }\n\n  // Constants for the LSByte command codes recognized by Cea608Stream. This\n  // list is not exhaustive. For a more comprehensive listing and semantics see\n  // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n  // Padding\n  this.PADDING_                    = 0x0000;\n  // Pop-on Mode\n  this.RESUME_CAPTION_LOADING_     = this.CONTROL_ | 0x20;\n  this.END_OF_CAPTION_             = this.CONTROL_ | 0x2f;\n  // Roll-up Mode\n  this.ROLL_UP_2_ROWS_             = this.CONTROL_ | 0x25;\n  this.ROLL_UP_3_ROWS_             = this.CONTROL_ | 0x26;\n  this.ROLL_UP_4_ROWS_             = this.CONTROL_ | 0x27;\n  this.CARRIAGE_RETURN_            = this.CONTROL_ | 0x2d;\n  // paint-on mode\n  this.RESUME_DIRECT_CAPTIONING_   = this.CONTROL_ | 0x29;\n  // Erasure\n  this.BACKSPACE_                  = this.CONTROL_ | 0x21;\n  this.ERASE_DISPLAYED_MEMORY_     = this.CONTROL_ | 0x2c;\n  this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n};\n\n/**\n * Detects if the 2-byte packet data is a special character\n *\n * Special characters have a second byte in the range 0x30 to 0x3f,\n * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an special character\n */\nCea608Stream.prototype.isSpecialCharacter = function(char0, char1) {\n  return (char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f);\n};\n\n/**\n * Detects if the 2-byte packet data is an extended character\n *\n * Extended characters have a second byte in the range 0x20 to 0x3f,\n * with the first byte being 0x12 or 0x13 (for data channel 1) or\n * 0x1a or 0x1b (for data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an extended character\n */\nCea608Stream.prototype.isExtCharacter = function(char0, char1) {\n  return ((char0 === (this.EXT_ + 1) || char0 === (this.EXT_ + 2)) &&\n    (char1 >= 0x20 && char1 <= 0x3f));\n};\n\n/**\n * Detects if the 2-byte packet is a mid-row code\n *\n * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n * channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a mid-row code\n */\nCea608Stream.prototype.isMidRowCode = function(char0, char1) {\n  return (char0 === this.EXT_ && (char1 >= 0x20 && char1 <= 0x2f));\n};\n\n/**\n * Detects if the 2-byte packet is an offset control code\n *\n * Offset control codes have a second byte in the range 0x21 to 0x23,\n * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an offset control code\n */\nCea608Stream.prototype.isOffsetControlCode = function(char0, char1) {\n  return (char0 === this.OFFSET_ && (char1 >= 0x21 && char1 <= 0x23));\n};\n\n/**\n * Detects if the 2-byte packet is a Preamble Address Code\n *\n * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n * range 0x40 to 0x7f.\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a PAC\n */\nCea608Stream.prototype.isPAC = function(char0, char1) {\n  return (char0 >= this.BASE_ && char0 < (this.BASE_ + 8) &&\n    (char1 >= 0x40 && char1 <= 0x7f));\n};\n\n/**\n * Detects if a packet's second byte is in the range of a PAC color code\n *\n * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n * 0x60 to 0x6f.\n *\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the byte is a color PAC\n */\nCea608Stream.prototype.isColorPAC = function(char1) {\n  return ((char1 >= 0x40 && char1 <= 0x4f) || (char1 >= 0x60 && char1 <= 0x7f));\n};\n\n/**\n * Detects if a single byte is in the range of a normal character\n *\n * Normal text bytes are in the range 0x20 to 0x7f.\n *\n * @param  {Integer} char  The byte\n * @return {Boolean}       Whether the byte is a normal character\n */\nCea608Stream.prototype.isNormalChar = function(char) {\n  return (char >= 0x20 && char <= 0x7f);\n};\n\n/**\n * Configures roll-up\n *\n * @param  {Integer} pts         Current PTS\n * @param  {Integer} newBaseRow  Used by PACs to slide the current window to\n *                               a new position\n */\nCea608Stream.prototype.setRollUp = function(pts, newBaseRow) {\n  // Reset the base row to the bottom row when switching modes\n  if (this.mode_ !== 'rollUp') {\n    this.row_ = BOTTOM_ROW;\n    this.mode_ = 'rollUp';\n    // Spec says to wipe memories when switching to roll-up\n    this.flushDisplayed(pts);\n    this.nonDisplayed_ = createDisplayBuffer();\n    this.displayed_ = createDisplayBuffer();\n  }\n\n  if (newBaseRow !== undefined && newBaseRow !== this.row_) {\n    // move currently displayed captions (up or down) to the new base row\n    for (var i = 0; i < this.rollUpRows_; i++) {\n      this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];\n      this.displayed_[this.row_ - i] = '';\n    }\n  }\n\n  if (newBaseRow === undefined) {\n    newBaseRow = this.row_;\n  }\n\n  this.topRow_ = newBaseRow - this.rollUpRows_ + 1;\n};\n\n// Adds the opening HTML tag for the passed character to the caption text,\n// and keeps track of it for later closing\nCea608Stream.prototype.addFormatting = function(pts, format) {\n  this.formatting_ = this.formatting_.concat(format);\n  var text = format.reduce(function(text, format) {\n    return text + '<' + format + '>';\n  }, '');\n  this[this.mode_](pts, text);\n};\n\n// Adds HTML closing tags for current formatting to caption text and\n// clears remembered formatting\nCea608Stream.prototype.clearFormatting = function(pts) {\n  if (!this.formatting_.length) {\n    return;\n  }\n  var text = this.formatting_.reverse().reduce(function(text, format) {\n    return text + '</' + format + '>';\n  }, '');\n  this.formatting_ = [];\n  this[this.mode_](pts, text);\n};\n\n// Mode Implementations\nCea608Stream.prototype.popOn = function(pts, text) {\n  var baseRow = this.nonDisplayed_[this.row_];\n\n  // buffer characters\n  baseRow += text;\n  this.nonDisplayed_[this.row_] = baseRow;\n};\n\nCea608Stream.prototype.rollUp = function(pts, text) {\n  var baseRow = this.displayed_[this.row_];\n\n  baseRow += text;\n  this.displayed_[this.row_] = baseRow;\n\n};\n\nCea608Stream.prototype.shiftRowsUp_ = function() {\n  var i;\n  // clear out inactive rows\n  for (i = 0; i < this.topRow_; i++) {\n    this.displayed_[i] = '';\n  }\n  for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {\n    this.displayed_[i] = '';\n  }\n  // shift displayed rows up\n  for (i = this.topRow_; i < this.row_; i++) {\n    this.displayed_[i] = this.displayed_[i + 1];\n  }\n  // clear out the bottom row\n  this.displayed_[this.row_] = '';\n};\n\nCea608Stream.prototype.paintOn = function(pts, text) {\n  var baseRow = this.displayed_[this.row_];\n\n  baseRow += text;\n  this.displayed_[this.row_] = baseRow;\n};\n\n// exports\nmodule.exports = {\n  CaptionStream: CaptionStream,\n  Cea608Stream: Cea608Stream\n};\n","/**\r\n * Compiles a querystring\r\n * Returns string representation of the object\r\n *\r\n * @param {Object}\r\n * @api private\r\n */\r\n\r\nexports.encode = function (obj) {\r\n  var str = '';\r\n\r\n  for (var i in obj) {\r\n    if (obj.hasOwnProperty(i)) {\r\n      if (str.length) str += '&';\r\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\r\n    }\r\n  }\r\n\r\n  return str;\r\n};\r\n\r\n/**\r\n * Parses a simple querystring into an object\r\n *\r\n * @param {String} qs\r\n * @api private\r\n */\r\n\r\nexports.decode = function(qs){\r\n  var qry = {};\r\n  var pairs = qs.split('&');\r\n  for (var i = 0, l = pairs.length; i < l; i++) {\r\n    var pair = pairs[i].split('=');\r\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\r\n  }\r\n  return qry;\r\n};\r\n","'use strict';\n\nvar Stream = require('../utils/stream.js');\n\nvar AdtsStream;\n\nvar\n  ADTS_SAMPLING_FREQUENCIES = [\n    96000,\n    88200,\n    64000,\n    48000,\n    44100,\n    32000,\n    24000,\n    22050,\n    16000,\n    12000,\n    11025,\n    8000,\n    7350\n  ];\n\n/*\n * Accepts a ElementaryStream and emits data events with parsed\n * AAC Audio Frames of the individual packets. Input audio in ADTS\n * format is unpacked and re-emitted as AAC frames.\n *\n * @see http://wiki.multimedia.cx/index.php?title=ADTS\n * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n */\nAdtsStream = function() {\n  var buffer;\n\n  AdtsStream.prototype.init.call(this);\n\n  this.push = function(packet) {\n    var\n      i = 0,\n      frameNum = 0,\n      frameLength,\n      protectionSkipBytes,\n      frameEnd,\n      oldBuffer,\n      sampleCount,\n      adtsFrameDuration;\n\n    if (packet.type !== 'audio') {\n      // ignore non-audio data\n      return;\n    }\n\n    // Prepend any data in the buffer to the input data so that we can parse\n    // aac frames the cross a PES packet boundary\n    if (buffer) {\n      oldBuffer = buffer;\n      buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n      buffer.set(oldBuffer);\n      buffer.set(packet.data, oldBuffer.byteLength);\n    } else {\n      buffer = packet.data;\n    }\n\n    // unpack any ADTS frames which have been fully received\n    // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n    while (i + 5 < buffer.length) {\n\n      // Loook for the start of an ADTS header..\n      if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n        // If a valid header was not found,  jump one forward and attempt to\n        // find a valid ADTS header starting at the next byte\n        i++;\n        continue;\n      }\n\n      // The protection skip bit tells us if we have 2 bytes of CRC data at the\n      // end of the ADTS header\n      protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2;\n\n      // Frame length is a 13 bit integer starting 16 bits from the\n      // end of the sync sequence\n      frameLength = ((buffer[i + 3] & 0x03) << 11) |\n        (buffer[i + 4] << 3) |\n        ((buffer[i + 5] & 0xe0) >> 5);\n\n      sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n      adtsFrameDuration = (sampleCount * 90000) /\n        ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2];\n\n      frameEnd = i + frameLength;\n\n      // If we don't have enough data to actually finish this ADTS frame, return\n      // and wait for more data\n      if (buffer.byteLength < frameEnd) {\n        return;\n      }\n\n      // Otherwise, deliver the complete AAC frame\n      this.trigger('data', {\n        pts: packet.pts + (frameNum * adtsFrameDuration),\n        dts: packet.dts + (frameNum * adtsFrameDuration),\n        sampleCount: sampleCount,\n        audioobjecttype: ((buffer[i + 2] >>> 6) & 0x03) + 1,\n        channelcount: ((buffer[i + 2] & 1) << 2) |\n          ((buffer[i + 3] & 0xc0) >>> 6),\n        samplerate: ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2],\n        samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n        // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n        samplesize: 16,\n        data: buffer.subarray(i + 7 + protectionSkipBytes, frameEnd)\n      });\n\n      // If the buffer is empty, clear it and return\n      if (buffer.byteLength === frameEnd) {\n        buffer = undefined;\n        return;\n      }\n\n      frameNum++;\n\n      // Remove the finished frame from the buffer and start the process again\n      buffer = buffer.subarray(frameEnd);\n    }\n  };\n  this.flush = function() {\n    this.trigger('done');\n  };\n};\n\nAdtsStream.prototype = new Stream();\n\nmodule.exports = AdtsStream;\n","/**\r\n * Parses an URI\r\n *\r\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\r\n * @api private\r\n */\r\n\r\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\r\n\r\nvar parts = [\r\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\r\n];\r\n\r\nmodule.exports = function parseuri(str) {\r\n    var src = str,\r\n        b = str.indexOf('['),\r\n        e = str.indexOf(']');\r\n\r\n    if (b != -1 && e != -1) {\r\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\r\n    }\r\n\r\n    var m = re.exec(str || ''),\r\n        uri = {},\r\n        i = 14;\r\n\r\n    while (i--) {\r\n        uri[parts[i]] = m[i] || '';\r\n    }\r\n\r\n    if (b != -1 && e != -1) {\r\n        uri.source = src;\r\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\r\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\r\n        uri.ipv6uri = true;\r\n    }\r\n\r\n    return uri;\r\n};\r\n","/**\n * Accepts program elementary stream (PES) data events and parses out\n * ID3 metadata from them, if present.\n * @see http://id3.org/id3v2.3.0\n */\n'use strict';\nvar\n  Stream = require('../utils/stream'),\n  StreamTypes = require('./stream-types'),\n  // return a percent-encoded representation of the specified byte range\n  // @see http://en.wikipedia.org/wiki/Percent-encoding\n  percentEncode = function(bytes, start, end) {\n    var i, result = '';\n    for (i = start; i < end; i++) {\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n    }\n    return result;\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as UTf-8.\n  parseUtf8 = function(bytes, start, end) {\n    return decodeURIComponent(percentEncode(bytes, start, end));\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as ISO-8859-1.\n  parseIso88591 = function(bytes, start, end) {\n    return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n  },\n  parseSyncSafeInteger = function(data) {\n    return (data[0] << 21) |\n            (data[1] << 14) |\n            (data[2] << 7) |\n            (data[3]);\n  },\n  tagParsers = {\n    TXXX: function(tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the text fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          // do not include the null terminator in the tag value\n          tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\\0*$/, '');\n          break;\n        }\n      }\n      tag.data = tag.value;\n    },\n    WXXX: function(tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\n          break;\n        }\n      }\n    },\n    PRIV: function(tag) {\n      var i;\n\n      for (i = 0; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.owner = parseIso88591(tag.data, 0, i);\n          break;\n        }\n      }\n      tag.privateData = tag.data.subarray(i + 1);\n      tag.data = tag.privateData;\n    }\n  },\n  MetadataStream;\n\nMetadataStream = function(options) {\n  var\n    settings = {\n      debug: !!(options && options.debug),\n\n      // the bytes of the program-level descriptor field in MP2T\n      // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n      // program element descriptors\"\n      descriptor: options && options.descriptor\n    },\n    // the total size in bytes of the ID3 tag being parsed\n    tagSize = 0,\n    // tag data that is not complete enough to be parsed\n    buffer = [],\n    // the total number of bytes currently in the buffer\n    bufferSize = 0,\n    i;\n\n  MetadataStream.prototype.init.call(this);\n\n  // calculate the text track in-band metadata track dispatch type\n  // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n  this.dispatchType = StreamTypes.METADATA_STREAM_TYPE.toString(16);\n  if (settings.descriptor) {\n    for (i = 0; i < settings.descriptor.length; i++) {\n      this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n    }\n  }\n\n  this.push = function(chunk) {\n    var tag, frameStart, frameSize, frame, i, frameHeader;\n    if (chunk.type !== 'timed-metadata') {\n      return;\n    }\n\n    // if data_alignment_indicator is set in the PES header,\n    // we must have the start of a new ID3 tag. Assume anything\n    // remaining in the buffer was malformed and throw it out\n    if (chunk.dataAlignmentIndicator) {\n      bufferSize = 0;\n      buffer.length = 0;\n    }\n\n    // ignore events that don't look like ID3 data\n    if (buffer.length === 0 &&\n        (chunk.data.length < 10 ||\n          chunk.data[0] !== 'I'.charCodeAt(0) ||\n          chunk.data[1] !== 'D'.charCodeAt(0) ||\n          chunk.data[2] !== '3'.charCodeAt(0))) {\n      if (settings.debug) {\n        // eslint-disable-next-line no-console\n        console.log('Skipping unrecognized metadata packet');\n      }\n      return;\n    }\n\n    // add this chunk to the data we've collected so far\n\n    buffer.push(chunk);\n    bufferSize += chunk.data.byteLength;\n\n    // grab the size of the entire frame from the ID3 header\n    if (buffer.length === 1) {\n      // the frame size is transmitted as a 28-bit integer in the\n      // last four bytes of the ID3 header.\n      // The most significant bit of each byte is dropped and the\n      // results concatenated to recover the actual value.\n      tagSize = parseSyncSafeInteger(chunk.data.subarray(6, 10));\n\n      // ID3 reports the tag size excluding the header but it's more\n      // convenient for our comparisons to include it\n      tagSize += 10;\n    }\n\n    // if the entire frame has not arrived, wait for more data\n    if (bufferSize < tagSize) {\n      return;\n    }\n\n    // collect the entire frame so it can be parsed\n    tag = {\n      data: new Uint8Array(tagSize),\n      frames: [],\n      pts: buffer[0].pts,\n      dts: buffer[0].dts\n    };\n    for (i = 0; i < tagSize;) {\n      tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n      i += buffer[0].data.byteLength;\n      bufferSize -= buffer[0].data.byteLength;\n      buffer.shift();\n    }\n\n    // find the start of the first frame and the end of the tag\n    frameStart = 10;\n    if (tag.data[5] & 0x40) {\n      // advance the frame start past the extended header\n      frameStart += 4; // header size field\n      frameStart += parseSyncSafeInteger(tag.data.subarray(10, 14));\n\n      // clip any padding off the end\n      tagSize -= parseSyncSafeInteger(tag.data.subarray(16, 20));\n    }\n\n    // parse one or more ID3 frames\n    // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n    do {\n      // determine the number of bytes in this frame\n      frameSize = parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\n      if (frameSize < 1) {\n         // eslint-disable-next-line no-console\n        return console.log('Malformed ID3 frame encountered. Skipping metadata parsing.');\n      }\n      frameHeader = String.fromCharCode(tag.data[frameStart],\n                                        tag.data[frameStart + 1],\n                                        tag.data[frameStart + 2],\n                                        tag.data[frameStart + 3]);\n\n\n      frame = {\n        id: frameHeader,\n        data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n      };\n      frame.key = frame.id;\n      if (tagParsers[frame.id]) {\n        tagParsers[frame.id](frame);\n\n        // handle the special PRIV frame used to indicate the start\n        // time for raw AAC data\n        if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n          var\n            d = frame.data,\n            size = ((d[3] & 0x01)  << 30) |\n                   (d[4]  << 22) |\n                   (d[5] << 14) |\n                   (d[6] << 6) |\n                   (d[7] >>> 2);\n\n          size *= 4;\n          size += d[7] & 0x03;\n          frame.timeStamp = size;\n          // in raw AAC, all subsequent data will be timestamped based\n          // on the value of this frame\n          // we couldn't have known the appropriate pts and dts before\n          // parsing this ID3 tag so set those values now\n          if (tag.pts === undefined && tag.dts === undefined) {\n            tag.pts = frame.timeStamp;\n            tag.dts = frame.timeStamp;\n          }\n          this.trigger('timestamp', frame);\n        }\n      }\n      tag.frames.push(frame);\n\n      frameStart += 10; // advance past the frame header\n      frameStart += frameSize; // advance past the frame body\n    } while (frameStart < tagSize);\n    this.trigger('data', tag);\n  };\n};\nMetadataStream.prototype = new Stream();\n\nmodule.exports = MetadataStream;\n","'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar ExpGolomb = require('../utils/exp-golomb.js');\n\nvar H264Stream, NalByteStream;\nvar PROFILES_WITH_OPTIONAL_SPS_DATA;\n\n/**\n * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n */\nNalByteStream = function() {\n  var\n    syncPoint = 0,\n    i,\n    buffer;\n  NalByteStream.prototype.init.call(this);\n\n  /*\n   * Scans a byte stream and triggers a data event with the NAL units found.\n   * @param {Object} data Event received from H264Stream\n   * @param {Uint8Array} data.data The h264 byte stream to be scanned\n   *\n   * @see H264Stream.push\n   */\n  this.push = function(data) {\n    var swapBuffer;\n\n    if (!buffer) {\n      buffer = data.data;\n    } else {\n      swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n      swapBuffer.set(buffer);\n      swapBuffer.set(data.data, buffer.byteLength);\n      buffer = swapBuffer;\n    }\n\n    // Rec. ITU-T H.264, Annex B\n    // scan for NAL unit boundaries\n\n    // a match looks like this:\n    // 0 0 1 .. NAL .. 0 0 1\n    // ^ sync point        ^ i\n    // or this:\n    // 0 0 1 .. NAL .. 0 0 0\n    // ^ sync point        ^ i\n\n    // advance the sync point to a NAL start, if necessary\n    for (; syncPoint < buffer.byteLength - 3; syncPoint++) {\n      if (buffer[syncPoint + 2] === 1) {\n        // the sync point is properly aligned\n        i = syncPoint + 5;\n        break;\n      }\n    }\n\n    while (i < buffer.byteLength) {\n      // look at the current byte to determine if we've hit the end of\n      // a NAL unit boundary\n      switch (buffer[i]) {\n      case 0:\n        // skip past non-sync sequences\n        if (buffer[i - 1] !== 0) {\n          i += 2;\n          break;\n        } else if (buffer[i - 2] !== 0) {\n          i++;\n          break;\n        }\n\n        // deliver the NAL unit if it isn't empty\n        if (syncPoint + 3 !== i - 2) {\n          this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n        }\n\n        // drop trailing zeroes\n        do {\n          i++;\n        } while (buffer[i] !== 1 && i < buffer.length);\n        syncPoint = i - 2;\n        i += 3;\n        break;\n      case 1:\n        // skip past non-sync sequences\n        if (buffer[i - 1] !== 0 ||\n            buffer[i - 2] !== 0) {\n          i += 3;\n          break;\n        }\n\n        // deliver the NAL unit\n        this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n        syncPoint = i - 2;\n        i += 3;\n        break;\n      default:\n        // the current byte isn't a one or zero, so it cannot be part\n        // of a sync sequence\n        i += 3;\n        break;\n      }\n    }\n    // filter out the NAL units that were delivered\n    buffer = buffer.subarray(syncPoint);\n    i -= syncPoint;\n    syncPoint = 0;\n  };\n\n  this.flush = function() {\n    // deliver the last buffered NAL unit\n    if (buffer && buffer.byteLength > 3) {\n      this.trigger('data', buffer.subarray(syncPoint + 3));\n    }\n    // reset the stream state\n    buffer = null;\n    syncPoint = 0;\n    this.trigger('done');\n  };\n};\nNalByteStream.prototype = new Stream();\n\n// values of profile_idc that indicate additional fields are included in the SPS\n// see Recommendation ITU-T H.264 (4/2013),\n// 7.3.2.1.1 Sequence parameter set data syntax\nPROFILES_WITH_OPTIONAL_SPS_DATA = {\n  100: true,\n  110: true,\n  122: true,\n  244: true,\n  44: true,\n  83: true,\n  86: true,\n  118: true,\n  128: true,\n  138: true,\n  139: true,\n  134: true\n};\n\n/**\n * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n * events.\n */\nH264Stream = function() {\n  var\n    nalByteStream = new NalByteStream(),\n    self,\n    trackId,\n    currentPts,\n    currentDts,\n\n    discardEmulationPreventionBytes,\n    readSequenceParameterSet,\n    skipScalingList;\n\n  H264Stream.prototype.init.call(this);\n  self = this;\n\n  /*\n   * Pushes a packet from a stream onto the NalByteStream\n   *\n   * @param {Object} packet - A packet received from a stream\n   * @param {Uint8Array} packet.data - The raw bytes of the packet\n   * @param {Number} packet.dts - Decode timestamp of the packet\n   * @param {Number} packet.pts - Presentation timestamp of the packet\n   * @param {Number} packet.trackId - The id of the h264 track this packet came from\n   * @param {('video'|'audio')} packet.type - The type of packet\n   *\n   */\n  this.push = function(packet) {\n    if (packet.type !== 'video') {\n      return;\n    }\n    trackId = packet.trackId;\n    currentPts = packet.pts;\n    currentDts = packet.dts;\n\n    nalByteStream.push(packet);\n  };\n\n  /*\n   * Identify NAL unit types and pass on the NALU, trackId, presentation and decode timestamps\n   * for the NALUs to the next stream component.\n   * Also, preprocess caption and sequence parameter NALUs.\n   *\n   * @param {Uint8Array} data - A NAL unit identified by `NalByteStream.push`\n   * @see NalByteStream.push\n   */\n  nalByteStream.on('data', function(data) {\n    var\n      event = {\n        trackId: trackId,\n        pts: currentPts,\n        dts: currentDts,\n        data: data\n      };\n\n    switch (data[0] & 0x1f) {\n    case 0x05:\n      event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n      break;\n    case 0x06:\n      event.nalUnitType = 'sei_rbsp';\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n      break;\n    case 0x07:\n      event.nalUnitType = 'seq_parameter_set_rbsp';\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n      event.config = readSequenceParameterSet(event.escapedRBSP);\n      break;\n    case 0x08:\n      event.nalUnitType = 'pic_parameter_set_rbsp';\n      break;\n    case 0x09:\n      event.nalUnitType = 'access_unit_delimiter_rbsp';\n      break;\n\n    default:\n      break;\n    }\n    // This triggers data on the H264Stream\n    self.trigger('data', event);\n  });\n  nalByteStream.on('done', function() {\n    self.trigger('done');\n  });\n\n  this.flush = function() {\n    nalByteStream.flush();\n  };\n\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count {number} the number of entries in this scaling list\n   * @param expGolombDecoder {object} an ExpGolomb pointed to the\n   * start of a scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList = function(count, expGolombDecoder) {\n    var\n      lastScale = 8,\n      nextScale = 8,\n      j,\n      deltaScale;\n\n    for (j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = expGolombDecoder.readExpGolomb();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n\n      lastScale = (nextScale === 0) ? lastScale : nextScale;\n    }\n  };\n\n  /**\n   * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n   * Sequence Payload\"\n   * @param data {Uint8Array} the bytes of a RBSP from a NAL\n   * unit\n   * @return {Uint8Array} the RBSP without any Emulation\n   * Prevention Bytes\n   */\n  discardEmulationPreventionBytes = function(data) {\n    var\n      length = data.byteLength,\n      emulationPreventionBytesPositions = [],\n      i = 1,\n      newLength, newData;\n\n    // Find all `Emulation Prevention Bytes`\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    }\n\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (emulationPreventionBytesPositions.length === 0) {\n      return data;\n    }\n\n    // Create a new array to hold the NAL unit data\n    newLength = length - emulationPreventionBytesPositions.length;\n    newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        // Skip this byte\n        sourceIndex++;\n        // Remove this position index\n        emulationPreventionBytesPositions.shift();\n      }\n      newData[i] = data[sourceIndex];\n    }\n\n    return newData;\n  };\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @param data {Uint8Array} the bytes of a sequence parameter set\n   * @return {object} an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSequenceParameterSet = function(data) {\n    var\n      frameCropLeftOffset = 0,\n      frameCropRightOffset = 0,\n      frameCropTopOffset = 0,\n      frameCropBottomOffset = 0,\n      sarScale = 1,\n      expGolombDecoder, profileIdc, levelIdc, profileCompatibility,\n      chromaFormatIdc, picOrderCntType,\n      numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1,\n      picHeightInMapUnitsMinus1,\n      frameMbsOnlyFlag,\n      scalingListCount,\n      sarRatio,\n      aspectRatioIdc,\n      i;\n\n    expGolombDecoder = new ExpGolomb(data);\n    profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n    profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n    levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n    expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n\n    // some profiles have more optional data we don't need\n    if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n      chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n      if (chromaFormatIdc === 3) {\n        expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n      }\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n      expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (expGolombDecoder.readBoolean()) { // seq_scaling_matrix_present_flag\n        scalingListCount = (chromaFormatIdc !== 3) ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (expGolombDecoder.readBoolean()) { // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16, expGolombDecoder);\n            } else {\n              skipScalingList(64, expGolombDecoder);\n            }\n          }\n        }\n      }\n    }\n\n    expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n    picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n\n    if (picOrderCntType === 0) {\n      expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n      expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n      expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n      }\n    }\n\n    expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n    expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n    picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n    picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n\n    frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n    }\n\n    expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n    if (expGolombDecoder.readBoolean()) { // frame_cropping_flag\n      frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n    }\n    if (expGolombDecoder.readBoolean()) {\n      // vui_parameters_present_flag\n      if (expGolombDecoder.readBoolean()) {\n        // aspect_ratio_info_present_flag\n        aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n        switch (aspectRatioIdc) {\n          case 1: sarRatio = [1, 1]; break;\n          case 2: sarRatio = [12, 11]; break;\n          case 3: sarRatio = [10, 11]; break;\n          case 4: sarRatio = [16, 11]; break;\n          case 5: sarRatio = [40, 33]; break;\n          case 6: sarRatio = [24, 11]; break;\n          case 7: sarRatio = [20, 11]; break;\n          case 8: sarRatio = [32, 11]; break;\n          case 9: sarRatio = [80, 33]; break;\n          case 10: sarRatio = [18, 11]; break;\n          case 11: sarRatio = [15, 11]; break;\n          case 12: sarRatio = [64, 33]; break;\n          case 13: sarRatio = [160, 99]; break;\n          case 14: sarRatio = [4, 3]; break;\n          case 15: sarRatio = [3, 2]; break;\n          case 16: sarRatio = [2, 1]; break;\n          case 255: {\n            sarRatio = [expGolombDecoder.readUnsignedByte() << 8 |\n                        expGolombDecoder.readUnsignedByte(),\n                        expGolombDecoder.readUnsignedByte() << 8 |\n                        expGolombDecoder.readUnsignedByte() ];\n            break;\n          }\n        }\n        if (sarRatio) {\n          sarScale = sarRatio[0] / sarRatio[1];\n        }\n      }\n    }\n    return {\n      profileIdc: profileIdc,\n      levelIdc: levelIdc,\n      profileCompatibility: profileCompatibility,\n      width: Math.ceil((((picWidthInMbsMinus1 + 1) * 16) - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),\n      height: ((2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16) - (frameCropTopOffset * 2) - (frameCropBottomOffset * 2)\n    };\n  };\n\n};\nH264Stream.prototype = new Stream();\n\nmodule.exports = {\n  H264Stream: H264Stream,\n  NalByteStream: NalByteStream\n};\n","var trim = require('string.prototype.trim')\n  , forEach = require('for-each')\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  forEach(\n      trim(headers).split('\\n')\n    , function (row) {\n        var index = row.indexOf(':')\n          , key = trim(row.slice(0, index)).toLowerCase()\n          , value = trim(row.slice(index + 1))\n\n        if (typeof(result[key]) === 'undefined') {\n          result[key] = value\n        } else if (isArray(result[key])) {\n          result[key].push(value)\n        } else {\n          result[key] = [ result[key], value ]\n        }\n      }\n  )\n\n  return result\n}\n","var highPrefix = [33, 16, 5, 32, 164, 27];\nvar lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\nvar zeroFill = function(count) {\n  var a = [];\n  while (count--) {\n    a.push(0);\n  }\n  return a;\n};\n\nvar makeTable = function(metaTable) {\n  return Object.keys(metaTable).reduce(function(obj, key) {\n    obj[key] = new Uint8Array(metaTable[key].reduce(function(arr, part) {\n      return arr.concat(part);\n    }, []));\n    return obj;\n  }, {});\n};\n\n// Frames-of-silence to use for filling in missing AAC frames\nvar coneOfSilence = {\n  96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n  88200: [highPrefix, [231], zeroFill(170), [56]],\n  64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n  48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n  44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n  32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n  24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n  16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n  12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n  11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n  8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n};\n\nmodule.exports = makeTable(coneOfSilence);\n","var toUnsigned = function(value) {\n  return value >>> 0;\n};\n\nmodule.exports = {\n  toUnsigned: toUnsigned\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Parse the internal MP4 structure into an equivalent javascript\n * object.\n */\n'use strict';\n\nvar\n  inspectMp4,\n  textifyMp4,\n\n  parseType = require('../mp4/probe').parseType,\n  parseMp4Date = function(seconds) {\n    return new Date(seconds * 1000 - 2082844800000);\n  },\n  parseSampleFlags = function(flags) {\n    return {\n      isLeading: (flags[0] & 0x0c) >>> 2,\n      dependsOn: flags[0] & 0x03,\n      isDependedOn: (flags[1] & 0xc0) >>> 6,\n      hasRedundancy: (flags[1] & 0x30) >>> 4,\n      paddingValue: (flags[1] & 0x0e) >>> 1,\n      isNonSyncSample: flags[1] & 0x01,\n      degradationPriority: (flags[2] << 8) | flags[3]\n    };\n  },\n  nalParse = function(avcStream) {\n    var\n      avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n      result = [],\n      i,\n      length;\n    for (i = 0; i + 4 < avcStream.length; i += length) {\n      length = avcView.getUint32(i);\n      i += 4;\n\n      // bail if this doesn't appear to be an H264 stream\n      if (length <= 0) {\n        result.push('<span style=\\'color:red;\\'>MALFORMED DATA</span>');\n        continue;\n      }\n\n      switch (avcStream[i] & 0x1F) {\n      case 0x01:\n        result.push('slice_layer_without_partitioning_rbsp');\n        break;\n      case 0x05:\n        result.push('slice_layer_without_partitioning_rbsp_idr');\n        break;\n      case 0x06:\n        result.push('sei_rbsp');\n        break;\n      case 0x07:\n        result.push('seq_parameter_set_rbsp');\n        break;\n      case 0x08:\n        result.push('pic_parameter_set_rbsp');\n        break;\n      case 0x09:\n        result.push('access_unit_delimiter_rbsp');\n        break;\n      default:\n        result.push('UNKNOWN NAL - ' + avcStream[i] & 0x1F);\n        break;\n      }\n    }\n    return result;\n  },\n\n  // registry of handlers for individual mp4 box types\n  parse = {\n    // codingname, not a first-class box type. stsd entries share the\n    // same format as real boxes so the parsing infrastructure can be\n    // shared\n    avc1: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        dataReferenceIndex: view.getUint16(6),\n        width: view.getUint16(24),\n        height: view.getUint16(26),\n        horizresolution: view.getUint16(28) + (view.getUint16(30) / 16),\n        vertresolution: view.getUint16(32) + (view.getUint16(34) / 16),\n        frameCount: view.getUint16(40),\n        depth: view.getUint16(74),\n        config: inspectMp4(data.subarray(78, data.byteLength))\n      };\n    },\n    avcC: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          configurationVersion: data[0],\n          avcProfileIndication: data[1],\n          profileCompatibility: data[2],\n          avcLevelIndication: data[3],\n          lengthSizeMinusOne: data[4] & 0x03,\n          sps: [],\n          pps: []\n        },\n        numOfSequenceParameterSets = data[5] & 0x1f,\n        numOfPictureParameterSets,\n        nalSize,\n        offset,\n        i;\n\n      // iterate past any SPSs\n      offset = 6;\n      for (i = 0; i < numOfSequenceParameterSets; i++) {\n        nalSize = view.getUint16(offset);\n        offset += 2;\n        result.sps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n        offset += nalSize;\n      }\n      // iterate past any PPSs\n      numOfPictureParameterSets = data[offset];\n      offset++;\n      for (i = 0; i < numOfPictureParameterSets; i++) {\n        nalSize = view.getUint16(offset);\n        offset += 2;\n        result.pps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n        offset += nalSize;\n      }\n      return result;\n    },\n    btrt: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        bufferSizeDB: view.getUint32(0),\n        maxBitrate: view.getUint32(4),\n        avgBitrate: view.getUint32(8)\n      };\n    },\n    esds: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        esId: (data[6] << 8) | data[7],\n        streamPriority: data[8] & 0x1f,\n        decoderConfig: {\n          objectProfileIndication: data[11],\n          streamType: (data[12] >>> 2) & 0x3f,\n          bufferSize: (data[13] << 16) | (data[14] << 8) | data[15],\n          maxBitrate: (data[16] << 24) |\n            (data[17] << 16) |\n            (data[18] <<  8) |\n            data[19],\n          avgBitrate: (data[20] << 24) |\n            (data[21] << 16) |\n            (data[22] <<  8) |\n            data[23],\n          decoderConfigDescriptor: {\n            tag: data[24],\n            length: data[25],\n            audioObjectType: (data[26] >>> 3) & 0x1f,\n            samplingFrequencyIndex: ((data[26] & 0x07) << 1) |\n              ((data[27] >>> 7) & 0x01),\n            channelConfiguration: (data[27] >>> 3) & 0x0f\n          }\n        }\n      };\n    },\n    ftyp: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          majorBrand: parseType(data.subarray(0, 4)),\n          minorVersion: view.getUint32(4),\n          compatibleBrands: []\n        },\n        i = 8;\n      while (i < data.byteLength) {\n        result.compatibleBrands.push(parseType(data.subarray(i, i + 4)));\n        i += 4;\n      }\n      return result;\n    },\n    dinf: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    dref: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        dataReferences: inspectMp4(data.subarray(8))\n      };\n    },\n    hdlr: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: view.getUint8(0),\n          flags: new Uint8Array(data.subarray(1, 4)),\n          handlerType: parseType(data.subarray(8, 12)),\n          name: ''\n        },\n        i = 8;\n\n      // parse out the name field\n      for (i = 24; i < data.byteLength; i++) {\n        if (data[i] === 0x00) {\n          // the name field is null-terminated\n          i++;\n          break;\n        }\n        result.name += String.fromCharCode(data[i]);\n      }\n      // decode UTF-8 to javascript's internal representation\n      // see http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\n      result.name = decodeURIComponent(escape(result.name));\n\n      return result;\n    },\n    mdat: function(data) {\n      return {\n        byteLength: data.byteLength,\n        nals: nalParse(data)\n      };\n    },\n    mdhd: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        language,\n        result = {\n          version: view.getUint8(0),\n          flags: new Uint8Array(data.subarray(1, 4)),\n          language: ''\n        };\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n      i += 4;\n      // language is stored as an ISO-639-2/T code in an array of three 5-bit fields\n      // each field is the packed difference between its ASCII value and 0x60\n      language = view.getUint16(i);\n      result.language += String.fromCharCode((language >> 10) + 0x60);\n      result.language += String.fromCharCode(((language & 0x03e0) >> 5) + 0x60);\n      result.language += String.fromCharCode((language & 0x1f) + 0x60);\n\n      return result;\n    },\n    mdia: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mfhd: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sequenceNumber: (data[4] << 24) |\n          (data[5] << 16) |\n          (data[6] << 8) |\n          (data[7])\n      };\n    },\n    minf: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    // codingname, not a first-class box type. stsd entries share the\n    // same format as real boxes so the parsing infrastructure can be\n    // shared\n    mp4a: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          // 6 bytes reserved\n          dataReferenceIndex: view.getUint16(6),\n          // 4 + 4 bytes reserved\n          channelcount: view.getUint16(16),\n          samplesize: view.getUint16(18),\n          // 2 bytes pre_defined\n          // 2 bytes reserved\n          samplerate: view.getUint16(24) + (view.getUint16(26) / 65536)\n        };\n\n      // if there are more bytes to process, assume this is an ISO/IEC\n      // 14496-14 MP4AudioSampleEntry and parse the ESDBox\n      if (data.byteLength > 28) {\n        result.streamDescriptor = inspectMp4(data.subarray(28))[0];\n      }\n      return result;\n    },\n    moof: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    moov: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mvex: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mvhd: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        result = {\n          version: view.getUint8(0),\n          flags: new Uint8Array(data.subarray(1, 4))\n        };\n\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n      i += 4;\n\n      // convert fixed-point, base 16 back to a number\n      result.rate = view.getUint16(i) + (view.getUint16(i + 2) / 16);\n      i += 4;\n      result.volume = view.getUint8(i) + (view.getUint8(i + 1) / 8);\n      i += 2;\n      i += 2;\n      i += 2 * 4;\n      result.matrix = new Uint32Array(data.subarray(i, i + (9 * 4)));\n      i += 9 * 4;\n      i += 6 * 4;\n      result.nextTrackId = view.getUint32(i);\n      return result;\n    },\n    pdin: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        rate: view.getUint32(4),\n        initialDelay: view.getUint32(8)\n      };\n    },\n    sdtp: function(data) {\n      var\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          samples: []\n        }, i;\n\n      for (i = 4; i < data.byteLength; i++) {\n        result.samples.push({\n          dependsOn: (data[i] & 0x30) >> 4,\n          isDependedOn: (data[i] & 0x0c) >> 2,\n          hasRedundancy: data[i] & 0x03\n        });\n      }\n      return result;\n    },\n    sidx: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n            version: data[0],\n            flags: new Uint8Array(data.subarray(1, 4)),\n            references: [],\n            referenceId: view.getUint32(4),\n            timescale: view.getUint32(8),\n            earliestPresentationTime: view.getUint32(12),\n            firstOffset: view.getUint32(16)\n          },\n          referenceCount = view.getUint16(22),\n          i;\n\n      for (i = 24; referenceCount; i += 12, referenceCount--) {\n        result.references.push({\n          referenceType: (data[i] & 0x80) >>> 7,\n          referencedSize: view.getUint32(i) & 0x7FFFFFFF,\n          subsegmentDuration: view.getUint32(i + 4),\n          startsWithSap: !!(data[i + 8] & 0x80),\n          sapType: (data[i + 8] & 0x70) >>> 4,\n          sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF\n        });\n      }\n\n      return result;\n    },\n    smhd: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        balance: data[4] + (data[5] / 256)\n      };\n    },\n    stbl: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    stco: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          chunkOffsets: []\n        },\n        entryCount = view.getUint32(4),\n        i;\n      for (i = 8; entryCount; i += 4, entryCount--) {\n        result.chunkOffsets.push(view.getUint32(i));\n      }\n      return result;\n    },\n    stsc: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        entryCount = view.getUint32(4),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          sampleToChunks: []\n        },\n        i;\n      for (i = 8; entryCount; i += 12, entryCount--) {\n        result.sampleToChunks.push({\n          firstChunk: view.getUint32(i),\n          samplesPerChunk: view.getUint32(i + 4),\n          sampleDescriptionIndex: view.getUint32(i + 8)\n        });\n      }\n      return result;\n    },\n    stsd: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sampleDescriptions: inspectMp4(data.subarray(8))\n      };\n    },\n    stsz: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          sampleSize: view.getUint32(4),\n          entries: []\n        },\n        i;\n      for (i = 12; i < data.byteLength; i += 4) {\n        result.entries.push(view.getUint32(i));\n      }\n      return result;\n    },\n    stts: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          timeToSamples: []\n        },\n        entryCount = view.getUint32(4),\n        i;\n\n      for (i = 8; entryCount; i += 8, entryCount--) {\n        result.timeToSamples.push({\n          sampleCount: view.getUint32(i),\n          sampleDelta: view.getUint32(i + 4)\n        });\n      }\n      return result;\n    },\n    styp: function(data) {\n      return parse.ftyp(data);\n    },\n    tfdt: function(data) {\n      var result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        baseMediaDecodeTime: data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]\n      };\n      if (result.version === 1) {\n        result.baseMediaDecodeTime *= Math.pow(2, 32);\n        result.baseMediaDecodeTime += data[8] << 24 | data[9] << 16 | data[10] << 8 | data[11];\n      }\n      return result;\n    },\n    tfhd: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          trackId: view.getUint32(4)\n        },\n        baseDataOffsetPresent = result.flags[2] & 0x01,\n        sampleDescriptionIndexPresent = result.flags[2] & 0x02,\n        defaultSampleDurationPresent = result.flags[2] & 0x08,\n        defaultSampleSizePresent = result.flags[2] & 0x10,\n        defaultSampleFlagsPresent = result.flags[2] & 0x20,\n        durationIsEmpty = result.flags[0] & 0x010000,\n        defaultBaseIsMoof =  result.flags[0] & 0x020000,\n        i;\n\n      i = 8;\n      if (baseDataOffsetPresent) {\n        i += 4; // truncate top 4 bytes\n        // FIXME: should we read the full 64 bits?\n        result.baseDataOffset = view.getUint32(12);\n        i += 4;\n      }\n      if (sampleDescriptionIndexPresent) {\n        result.sampleDescriptionIndex = view.getUint32(i);\n        i += 4;\n      }\n      if (defaultSampleDurationPresent) {\n        result.defaultSampleDuration = view.getUint32(i);\n        i += 4;\n      }\n      if (defaultSampleSizePresent) {\n        result.defaultSampleSize = view.getUint32(i);\n        i += 4;\n      }\n      if (defaultSampleFlagsPresent) {\n        result.defaultSampleFlags = view.getUint32(i);\n      }\n      if (durationIsEmpty) {\n        result.durationIsEmpty = true;\n      }\n      if (!baseDataOffsetPresent && defaultBaseIsMoof) {\n        result.baseDataOffsetIsMoof = true;\n      }\n      return result;\n    },\n    tkhd: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        result = {\n          version: view.getUint8(0),\n          flags: new Uint8Array(data.subarray(1, 4))\n        };\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 4;\n        result.trackId = view.getUint32(i);\n        i += 4;\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.trackId = view.getUint32(i);\n        i += 4;\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n      i += 4;\n      i += 2 * 4;\n      result.layer = view.getUint16(i);\n      i += 2;\n      result.alternateGroup = view.getUint16(i);\n      i += 2;\n      // convert fixed-point, base 16 back to a number\n      result.volume = view.getUint8(i) + (view.getUint8(i + 1) / 8);\n      i += 2;\n      i += 2;\n      result.matrix = new Uint32Array(data.subarray(i, i + (9 * 4)));\n      i += 9 * 4;\n      result.width = view.getUint16(i) + (view.getUint16(i + 2) / 16);\n      i += 4;\n      result.height = view.getUint16(i) + (view.getUint16(i + 2) / 16);\n      return result;\n    },\n    traf: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    trak: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    trex: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        trackId: view.getUint32(4),\n        defaultSampleDescriptionIndex: view.getUint32(8),\n        defaultSampleDuration: view.getUint32(12),\n        defaultSampleSize: view.getUint32(16),\n        sampleDependsOn: data[20] & 0x03,\n        sampleIsDependedOn: (data[21] & 0xc0) >> 6,\n        sampleHasRedundancy: (data[21] & 0x30) >> 4,\n        samplePaddingValue: (data[21] & 0x0e) >> 1,\n        sampleIsDifferenceSample: !!(data[21] & 0x01),\n        sampleDegradationPriority: view.getUint16(22)\n      };\n    },\n    trun: function(data) {\n      var\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          samples: []\n        },\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        // Flag interpretation\n        dataOffsetPresent = result.flags[2] & 0x01, // compare with 2nd byte of 0x1\n        firstSampleFlagsPresent = result.flags[2] & 0x04, // compare with 2nd byte of 0x4\n        sampleDurationPresent = result.flags[1] & 0x01, // compare with 2nd byte of 0x100\n        sampleSizePresent = result.flags[1] & 0x02, // compare with 2nd byte of 0x200\n        sampleFlagsPresent = result.flags[1] & 0x04, // compare with 2nd byte of 0x400\n        sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08, // compare with 2nd byte of 0x800\n        sampleCount = view.getUint32(4),\n        offset = 8,\n        sample;\n\n      if (dataOffsetPresent) {\n        // 32 bit signed integer\n        result.dataOffset = view.getInt32(offset);\n        offset += 4;\n      }\n\n      // Overrides the flags for the first sample only. The order of\n      // optional values will be: duration, size, compositionTimeOffset\n      if (firstSampleFlagsPresent && sampleCount) {\n        sample = {\n          flags: parseSampleFlags(data.subarray(offset, offset + 4))\n        };\n        offset += 4;\n        if (sampleDurationPresent) {\n          sample.duration = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleSizePresent) {\n          sample.size = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          // Note: this should be a signed int if version is 1\n          sample.compositionTimeOffset = view.getUint32(offset);\n          offset += 4;\n        }\n        result.samples.push(sample);\n        sampleCount--;\n      }\n\n      while (sampleCount--) {\n        sample = {};\n        if (sampleDurationPresent) {\n          sample.duration = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleSizePresent) {\n          sample.size = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleFlagsPresent) {\n          sample.flags = parseSampleFlags(data.subarray(offset, offset + 4));\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          // Note: this should be a signed int if version is 1\n          sample.compositionTimeOffset = view.getUint32(offset);\n          offset += 4;\n        }\n        result.samples.push(sample);\n      }\n      return result;\n    },\n    'url ': function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4))\n      };\n    },\n    vmhd: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        graphicsmode: view.getUint16(4),\n        opcolor: new Uint16Array([view.getUint16(6),\n                                  view.getUint16(8),\n                                  view.getUint16(10)])\n      };\n    }\n  };\n\n\n/**\n * Return a javascript array of box objects parsed from an ISO base\n * media file.\n * @param data {Uint8Array} the binary data of the media to be inspected\n * @return {array} a javascript array of potentially nested box objects\n */\ninspectMp4 = function(data) {\n  var\n    i = 0,\n    result = [],\n    view,\n    size,\n    type,\n    end,\n    box;\n\n  // Convert data from Uint8Array to ArrayBuffer, to follow Dataview API\n  var ab = new ArrayBuffer(data.length);\n  var v = new Uint8Array(ab);\n  for (var z = 0; z < data.length; ++z) {\n      v[z] = data[z];\n  }\n  view = new DataView(ab);\n\n  while (i < data.byteLength) {\n    // parse box data\n    size = view.getUint32(i);\n    type =  parseType(data.subarray(i + 4, i + 8));\n    end = size > 1 ? i + size : data.byteLength;\n\n    // parse type-specific data\n    box = (parse[type] || function(data) {\n      return {\n        data: data\n      };\n    })(data.subarray(i + 8, end));\n    box.size = size;\n    box.type = type;\n\n    // store this box and move to the next\n    result.push(box);\n    i = end;\n  }\n  return result;\n};\n\n/**\n * Returns a textual representation of the javascript represtentation\n * of an MP4 file. You can use it as an alternative to\n * JSON.stringify() to compare inspected MP4s.\n * @param inspectedMp4 {array} the parsed array of boxes in an MP4\n * file\n * @param depth {number} (optional) the number of ancestor boxes of\n * the elements of inspectedMp4. Assumed to be zero if unspecified.\n * @return {string} a text representation of the parsed MP4\n */\ntextifyMp4 = function(inspectedMp4, depth) {\n  var indent;\n  depth = depth || 0;\n  indent = new Array(depth * 2 + 1).join(' ');\n\n  // iterate over all the boxes\n  return inspectedMp4.map(function(box, index) {\n\n    // list the box type first at the current indentation level\n    return indent + box.type + '\\n' +\n\n      // the type is already included and handle child boxes separately\n      Object.keys(box).filter(function(key) {\n        return key !== 'type' && key !== 'boxes';\n\n      // output all the box properties\n      }).map(function(key) {\n        var prefix = indent + '  ' + key + ': ',\n            value = box[key];\n\n        // print out raw bytes as hexademical\n        if (value instanceof Uint8Array || value instanceof Uint32Array) {\n          var bytes = Array.prototype.slice.call(new Uint8Array(value.buffer, value.byteOffset, value.byteLength))\n              .map(function(byte) {\n                return ' ' + ('00' + byte.toString(16)).slice(-2);\n              }).join('').match(/.{1,24}/g);\n          if (!bytes) {\n            return prefix + '<>';\n          }\n          if (bytes.length === 1) {\n            return prefix + '<' + bytes.join('').slice(1) + '>';\n          }\n          return prefix + '<\\n' + bytes.map(function(line) {\n            return indent + '  ' + line;\n          }).join('\\n') + '\\n' + indent + '  >';\n        }\n\n        // stringify generic objects\n        return prefix +\n            JSON.stringify(value, null, 2)\n              .split('\\n').map(function(line, index) {\n                if (index === 0) {\n                  return line;\n                }\n                return indent + '  ' + line;\n              }).join('\\n');\n      }).join('\\n') +\n\n    // recursively textify the child boxes\n    (box.boxes ? '\\n' + textifyMp4(box.boxes, depth + 1) : '');\n  }).join('\\n');\n};\n\nmodule.exports = {\n  inspect: inspectMp4,\n  textify: textifyMp4,\n  parseTfdt: parse.tfdt,\n  parseHdlr: parse.hdlr,\n  parseTfhd: parse.tfhd,\n  parseTrun: parse.trun,\n  parseSidx: parse.sidx\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * A stream-based aac to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\nvar Stream = require('../utils/stream.js');\nvar aacUtils = require('./utils');\n\n// Constants\nvar AacStream;\n\n/**\n * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n */\n\nAacStream = function() {\n  var\n    everything = new Uint8Array(),\n    timeStamp = 0;\n\n  AacStream.prototype.init.call(this);\n\n  this.setTimestamp = function(timestamp) {\n    timeStamp = timestamp;\n  };\n\n  this.push = function(bytes) {\n    var\n      frameSize = 0,\n      byteIndex = 0,\n      bytesLeft,\n      chunk,\n      packet,\n      tempLength;\n\n    // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n    if (everything.length) {\n      tempLength = everything.length;\n      everything = new Uint8Array(bytes.byteLength + tempLength);\n      everything.set(everything.subarray(0, tempLength));\n      everything.set(bytes, tempLength);\n    } else {\n      everything = bytes;\n    }\n\n    while (everything.length - byteIndex >= 3) {\n      if ((everything[byteIndex] === 'I'.charCodeAt(0)) &&\n          (everything[byteIndex + 1] === 'D'.charCodeAt(0)) &&\n          (everything[byteIndex + 2] === '3'.charCodeAt(0))) {\n\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (everything.length - byteIndex < 10) {\n          break;\n        }\n\n        // check framesize\n        frameSize = aacUtils.parseId3TagSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        // Add to byteIndex to support multiple ID3 tags in sequence\n        if (byteIndex + frameSize > everything.length) {\n          break;\n        }\n        chunk = {\n          type: 'timed-metadata',\n          data: everything.subarray(byteIndex, byteIndex + frameSize)\n        };\n        this.trigger('data', chunk);\n        byteIndex += frameSize;\n        continue;\n      } else if (((everything[byteIndex] & 0xff) === 0xff) &&\n                 ((everything[byteIndex + 1] & 0xf0) === 0xf0)) {\n\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (everything.length - byteIndex < 7) {\n          break;\n        }\n\n        frameSize = aacUtils.parseAdtsSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (byteIndex + frameSize > everything.length) {\n          break;\n        }\n\n        packet = {\n          type: 'audio',\n          data: everything.subarray(byteIndex, byteIndex + frameSize),\n          pts: timeStamp,\n          dts: timeStamp\n        };\n        this.trigger('data', packet);\n        byteIndex += frameSize;\n        continue;\n      }\n      byteIndex++;\n    }\n    bytesLeft = everything.length - byteIndex;\n\n    if (bytesLeft > 0) {\n      everything = everything.subarray(byteIndex);\n    } else {\n      everything = new Uint8Array();\n    }\n  };\n};\n\nAacStream.prototype = new Stream();\n\nmodule.exports = AacStream;\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Reads in-band CEA-708 captions out of FMP4 segments.\n * @see https://en.wikipedia.org/wiki/CEA-708\n */\n'use strict';\n\nvar discardEmulationPreventionBytes = require('../tools/caption-packet-parser').discardEmulationPreventionBytes;\nvar CaptionStream = require('../m2ts/caption-stream').CaptionStream;\nvar probe = require('./probe');\nvar inspect = require('../tools/mp4-inspector');\n\n/**\n  * Maps an offset in the mdat to a sample based on the the size of the samples.\n  * Assumes that `parseSamples` has been called first.\n  *\n  * @param {Number} offset - The offset into the mdat\n  * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\n  * @return {?Object} The matching sample, or null if no match was found.\n  *\n  * @see ISO-BMFF-12/2015, Section 8.8.8\n **/\nvar mapToSample = function(offset, samples) {\n  var approximateOffset = offset;\n\n  for (var i = 0; i < samples.length; i++) {\n    var sample = samples[i];\n\n    if (approximateOffset < sample.size) {\n      return sample;\n    }\n\n    approximateOffset -= sample.size;\n  }\n\n  return null;\n};\n\n/**\n  * Finds SEI nal units contained in a Media Data Box.\n  * Assumes that `parseSamples` has been called first.\n  *\n  * @param {Uint8Array} avcStream - The bytes of the mdat\n  * @param {Object[]} samples - The samples parsed out by `parseSamples`\n  * @param {Number} trackId - The trackId of this video track\n  * @return {Object[]} seiNals - the parsed SEI NALUs found.\n  *   The contents of the seiNal should match what is expected by\n  *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\n  *\n  * @see ISO-BMFF-12/2015, Section 8.1.1\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n **/\nvar findSeiNals = function(avcStream, samples, trackId) {\n  var\n    avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n    result = [],\n    seiNal,\n    i,\n    length,\n    lastMatchedSample;\n\n  for (i = 0; i + 4 < avcStream.length; i += length) {\n    length = avcView.getUint32(i);\n    i += 4;\n\n    // Bail if this doesn't appear to be an H264 stream\n    if (length <= 0) {\n      continue;\n    }\n\n    switch (avcStream[i] & 0x1F) {\n    case 0x06:\n      var data = avcStream.subarray(i + 1, i + 1 + length);\n      var matchingSample = mapToSample(i, samples);\n\n      seiNal = {\n        nalUnitType: 'sei_rbsp',\n        size: length,\n        data: data,\n        escapedRBSP: discardEmulationPreventionBytes(data),\n        trackId: trackId\n      };\n\n      if (matchingSample) {\n        seiNal.pts = matchingSample.pts;\n        seiNal.dts = matchingSample.dts;\n        lastMatchedSample = matchingSample;\n      } else {\n        // If a matching sample cannot be found, use the last\n        // sample's values as they should be as close as possible\n        seiNal.pts = lastMatchedSample.pts;\n        seiNal.dts = lastMatchedSample.dts;\n      }\n\n      result.push(seiNal);\n      break;\n    default:\n      break;\n    }\n  }\n\n  return result;\n};\n\n/**\n  * Parses sample information out of Track Run Boxes and calculates\n  * the absolute presentation and decode timestamps of each sample.\n  *\n  * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\n  * @param {Number} baseMediaDecodeTime - base media decode time from tfdt\n      @see ISO-BMFF-12/2015, Section 8.8.12\n  * @param {Object} tfhd - The parsed Track Fragment Header\n  *   @see inspect.parseTfhd\n  * @return {Object[]} the parsed samples\n  *\n  * @see ISO-BMFF-12/2015, Section 8.8.8\n **/\nvar parseSamples = function(truns, baseMediaDecodeTime, tfhd) {\n  var currentDts = baseMediaDecodeTime;\n  var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\n  var defaultSampleSize = tfhd.defaultSampleSize || 0;\n  var trackId = tfhd.trackId;\n  var allSamples = [];\n\n  truns.forEach(function(trun) {\n    // Note: We currently do not parse the sample table as well\n    // as the trun. It's possible some sources will require this.\n    // moov > trak > mdia > minf > stbl\n    var trackRun = inspect.parseTrun(trun);\n    var samples = trackRun.samples;\n\n    samples.forEach(function(sample) {\n      if (sample.duration === undefined) {\n        sample.duration = defaultSampleDuration;\n      }\n      if (sample.size === undefined) {\n        sample.size = defaultSampleSize;\n      }\n      sample.trackId = trackId;\n      sample.dts = currentDts;\n      if (sample.compositionTimeOffset === undefined) {\n        sample.compositionTimeOffset = 0;\n      }\n      sample.pts = currentDts + sample.compositionTimeOffset;\n\n      currentDts += sample.duration;\n    });\n\n    allSamples = allSamples.concat(samples);\n  });\n\n  return allSamples;\n};\n\n/**\n  * Parses out caption nals from an FMP4 segment's video tracks.\n  *\n  * @param {Uint8Array} segment - The bytes of a single segment\n  * @param {Number} videoTrackId - The trackId of a video track in the segment\n  * @return {Object.<Number, Object[]>} A mapping of video trackId to\n  *   a list of seiNals found in that track\n **/\nvar parseCaptionNals = function(segment, videoTrackId) {\n  // To get the samples\n  var trafs = probe.findBox(segment, ['moof', 'traf']);\n  // To get SEI NAL units\n  var mdats = probe.findBox(segment, ['mdat']);\n  var captionNals = {};\n  var mdatTrafPairs = [];\n\n  // Pair up each traf with a mdat as moofs and mdats are in pairs\n  mdats.forEach(function(mdat, index) {\n    var matchingTraf = trafs[index];\n    mdatTrafPairs.push({\n      mdat: mdat,\n      traf: matchingTraf\n    });\n  });\n\n  mdatTrafPairs.forEach(function(pair) {\n    var mdat = pair.mdat;\n    var traf = pair.traf;\n    var tfhd = probe.findBox(traf, ['tfhd']);\n    // Exactly 1 tfhd per traf\n    var headerInfo = inspect.parseTfhd(tfhd[0]);\n    var trackId = headerInfo.trackId;\n    var tfdt = probe.findBox(traf, ['tfdt']);\n    // Either 0 or 1 tfdt per traf\n    var baseMediaDecodeTime = (tfdt.length > 0) ? inspect.parseTfdt(tfdt[0]).baseMediaDecodeTime : 0;\n    var truns = probe.findBox(traf, ['trun']);\n    var samples;\n    var seiNals;\n\n    // Only parse video data for the chosen video track\n    if (videoTrackId === trackId && truns.length > 0) {\n      samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\n\n      seiNals = findSeiNals(mdat, samples, trackId);\n\n      if (!captionNals[trackId]) {\n        captionNals[trackId] = [];\n      }\n\n      captionNals[trackId] = captionNals[trackId].concat(seiNals);\n    }\n  });\n\n  return captionNals;\n};\n\n/**\n  * Parses out inband captions from an MP4 container and returns\n  * caption objects that can be used by WebVTT and the TextTrack API.\n  * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\n  * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n  * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\n  *\n  * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n  * @param {Number} trackId - The id of the video track to parse\n  * @param {Number} timescale - The timescale for the video track from the init segment\n  *\n  * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\n  * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\n  * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\n  * @return {String} parsedCaptions[].text - The visible content of the caption\n **/\nvar parseEmbeddedCaptions = function(segment, trackId, timescale) {\n  var seiNals;\n\n  if (!trackId) {\n    return null;\n  }\n\n  seiNals = parseCaptionNals(segment, trackId);\n\n  return {\n    seiNals: seiNals[trackId],\n    timescale: timescale\n  };\n};\n\n/**\n  * Converts SEI NALUs into captions that can be used by video.js\n **/\nvar CaptionParser = function() {\n  var isInitialized = false;\n  var captionStream;\n\n  // Stores segments seen before trackId and timescale are set\n  var segmentCache;\n  // Stores video track ID of the track being parsed\n  var trackId;\n  // Stores the timescale of the track being parsed\n  var timescale;\n  // Stores captions parsed so far\n  var parsedCaptions;\n\n  /**\n    * A method to indicate whether a CaptionParser has been initalized\n    * @returns {Boolean}\n   **/\n  this.isInitialized = function() {\n    return isInitialized;\n  };\n\n  /**\n    * Initializes the underlying CaptionStream, SEI NAL parsing\n    * and management, and caption collection\n   **/\n  this.init = function() {\n    captionStream = new CaptionStream();\n    isInitialized = true;\n\n    // Collect dispatched captions\n    captionStream.on('data', function(event) {\n      // Convert to seconds in the source's timescale\n      event.startTime = event.startPts / timescale;\n      event.endTime = event.endPts / timescale;\n\n      parsedCaptions.captions.push(event);\n      parsedCaptions.captionStreams[event.stream] = true;\n    });\n  };\n\n  /**\n    * Determines if a new video track will be selected\n    * or if the timescale changed\n    * @return {Boolean}\n   **/\n  this.isNewInit = function(videoTrackIds, timescales) {\n    if ((videoTrackIds && videoTrackIds.length === 0) ||\n        (timescales && typeof timescales === 'object' &&\n          Object.keys(timescales).length === 0)) {\n      return false;\n    }\n\n    return trackId !== videoTrackIds[0] ||\n      timescale !== timescales[trackId];\n  };\n\n  /**\n    * Parses out SEI captions and interacts with underlying\n    * CaptionStream to return dispatched captions\n    *\n    * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n    * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\n    * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\n    * @see parseEmbeddedCaptions\n    * @see m2ts/caption-stream.js\n   **/\n  this.parse = function(segment, videoTrackIds, timescales) {\n    var parsedData;\n\n    if (!this.isInitialized()) {\n      return null;\n\n    // This is not likely to be a video segment\n    } else if (!videoTrackIds || !timescales) {\n      return null;\n\n    } else if (this.isNewInit(videoTrackIds, timescales)) {\n      // Use the first video track only as there is no\n      // mechanism to switch to other video tracks\n      trackId = videoTrackIds[0];\n      timescale = timescales[trackId];\n\n    // If an init segment has not been seen yet, hold onto segment\n    // data until we have one\n    } else if (!trackId || !timescale) {\n      segmentCache.push(segment);\n      return null;\n    }\n\n    // Now that a timescale and trackId is set, parse cached segments\n    while (segmentCache.length > 0) {\n      var cachedSegment = segmentCache.shift();\n\n      this.parse(cachedSegment, videoTrackIds, timescales);\n    }\n\n    parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\n\n    if (parsedData === null || !parsedData.seiNals) {\n      return null;\n    }\n\n    this.pushNals(parsedData.seiNals);\n    // Force the parsed captions to be dispatched\n    this.flushStream();\n\n    return parsedCaptions;\n  };\n\n  /**\n    * Pushes SEI NALUs onto CaptionStream\n    * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\n    * Assumes that `parseCaptionNals` has been called first\n    * @see m2ts/caption-stream.js\n    **/\n  this.pushNals = function(nals) {\n    if (!this.isInitialized() || !nals || nals.length === 0) {\n      return null;\n    }\n\n    nals.forEach(function(nal) {\n      captionStream.push(nal);\n    });\n  };\n\n  /**\n    * Flushes underlying CaptionStream to dispatch processed, displayable captions\n    * @see m2ts/caption-stream.js\n   **/\n  this.flushStream = function() {\n    if (!this.isInitialized()) {\n      return null;\n    }\n\n    captionStream.flush();\n  };\n\n  /**\n    * Reset caption buckets for new data\n   **/\n  this.clearParsedCaptions = function() {\n    parsedCaptions.captions = [];\n    parsedCaptions.captionStreams = {};\n  };\n\n  /**\n    * Resets underlying CaptionStream\n    * @see m2ts/caption-stream.js\n   **/\n  this.resetCaptionStream = function() {\n    if (!this.isInitialized()) {\n      return null;\n    }\n\n    captionStream.reset();\n  };\n\n  /**\n    * Convenience method to clear all captions flushed from the\n    * CaptionStream and still being parsed\n    * @see m2ts/caption-stream.js\n   **/\n  this.clearAllCaptions = function() {\n    this.clearParsedCaptions();\n    this.resetCaptionStream();\n  };\n\n  /**\n    * Reset caption parser\n   **/\n  this.reset = function() {\n    segmentCache = [];\n    trackId = null;\n    timescale = null;\n\n    if (!parsedCaptions) {\n      parsedCaptions = {\n        captions: [],\n        // CC1, CC2, CC3, CC4\n        captionStreams: {}\n      };\n    } else {\n      this.clearParsedCaptions();\n    }\n\n    this.resetCaptionStream();\n  };\n\n  this.reset();\n};\n\nmodule.exports = CaptionParser;\n","'use strict';\n\nmodule.exports = {\n  H264_STREAM_TYPE: 0x1B,\n  ADTS_STREAM_TYPE: 0x0F,\n  METADATA_STREAM_TYPE: 0x15\n};\n","'use strict';\n\nvar keysShim;\nif (!Object.keys) {\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar isArgs = require('./isArguments'); // eslint-disable-line global-require\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$applicationCache: true,\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$onmozfullscreenchange: true,\n\t\t$onmozfullscreenerror: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}\nmodule.exports = keysShim;\n","'use strict';\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n","'use strict';\n\nvar slice = Array.prototype.slice;\nvar isArgs = require('./isArguments');\n\nvar origKeys = Object.keys;\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');\n\nvar originalKeys = Object.keys;\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\tvar args = Object.keys(arguments);\n\t\t\treturn args && args.length === arguments.length;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t}\n\t\t\t\treturn originalKeys(object);\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n","/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Parse mpeg2 transport stream packets to extract basic timing information\n */\n'use strict';\n\nvar StreamTypes = require('../m2ts/stream-types.js');\nvar handleRollover = require('../m2ts/timestamp-rollover-stream.js').handleRollover;\nvar probe = {};\nprobe.ts = require('../m2ts/probe.js');\nprobe.aac = require('../aac/utils.js');\n\n\nvar\n  PES_TIMESCALE = 90000,\n  MP2T_PACKET_LENGTH = 188, // bytes\n  SYNC_BYTE = 0x47;\n\n/**\n * walks through segment data looking for pat and pmt packets to parse out\n * program map table information\n */\nvar parsePsi_ = function(bytes, pmt) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type;\n\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pat':\n          if (!pmt.pid) {\n            pmt.pid = probe.ts.parsePat(packet);\n          }\n          break;\n        case 'pmt':\n          if (!pmt.table) {\n            pmt.table = probe.ts.parsePmt(packet);\n          }\n          break;\n        default:\n          break;\n      }\n\n      // Found the pat and pmt, we can stop walking the segment\n      if (pmt.pid && pmt.table) {\n        return;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last audio pes packets\n */\nvar parseAudioPes_ = function(bytes, pmt, result) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type, pesType, pusi, parsed;\n\n  var endLoop = false;\n\n  // Start walking from start of segment to get first audio packet\n  while (endIndex <= bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE &&\n        (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last audio packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE &&\n        (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last video pes packets as well as timing information for the first\n * key frame.\n */\nvar parseVideoPes_ = function(bytes, pmt, result) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type, pesType, pusi, parsed, frame, i, pes;\n\n  var endLoop = false;\n\n  var currentFrame = {\n    data: [],\n    size: 0\n  };\n\n  // Start walking from start of segment to get first video packet\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video') {\n            if (pusi && !endLoop) {\n              parsed = probe.ts.parsePesTime(packet);\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n            }\n            if (!result.firstKeyFrame) {\n              if (pusi) {\n                if (currentFrame.size !== 0) {\n                  frame = new Uint8Array(currentFrame.size);\n                  i = 0;\n                  while (currentFrame.data.length) {\n                    pes = currentFrame.data.shift();\n                    frame.set(pes, i);\n                    i += pes.byteLength;\n                  }\n                  if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                    result.firstKeyFrame = probe.ts.parsePesTime(frame);\n                    result.firstKeyFrame.type = 'video';\n                  }\n                  currentFrame.size = 0;\n                }\n              }\n              currentFrame.data.push(packet);\n              currentFrame.size += packet.byteLength;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop && result.firstKeyFrame) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last video packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * Adjusts the timestamp information for the segment to account for\n * rollover and convert to seconds based on pes packet timescale (90khz clock)\n */\nvar adjustTimestamp_ = function(segmentInfo, baseTimestamp) {\n  if (segmentInfo.audio && segmentInfo.audio.length) {\n    var audioBaseTimestamp = baseTimestamp;\n    if (typeof audioBaseTimestamp === 'undefined') {\n      audioBaseTimestamp = segmentInfo.audio[0].dts;\n    }\n    segmentInfo.audio.forEach(function(info) {\n      info.dts = handleRollover(info.dts, audioBaseTimestamp);\n      info.pts = handleRollover(info.pts, audioBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n  }\n\n  if (segmentInfo.video && segmentInfo.video.length) {\n    var videoBaseTimestamp = baseTimestamp;\n    if (typeof videoBaseTimestamp === 'undefined') {\n      videoBaseTimestamp = segmentInfo.video[0].dts;\n    }\n    segmentInfo.video.forEach(function(info) {\n      info.dts = handleRollover(info.dts, videoBaseTimestamp);\n      info.pts = handleRollover(info.pts, videoBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n    if (segmentInfo.firstKeyFrame) {\n      var frame = segmentInfo.firstKeyFrame;\n      frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n      frame.pts = handleRollover(frame.pts, videoBaseTimestamp);\n      // time in seconds\n      frame.dtsTime = frame.dts / PES_TIMESCALE;\n      frame.ptsTime = frame.dts / PES_TIMESCALE;\n    }\n  }\n};\n\n/**\n * inspects the aac data stream for start and end time information\n */\nvar inspectAac_ = function(bytes) {\n  var\n    endLoop = false,\n    audioCount = 0,\n    sampleRate = null,\n    timestamp = null,\n    frameSize = 0,\n    byteIndex = 0,\n    packet;\n\n  while (bytes.length - byteIndex >= 3) {\n    var type = probe.aac.parseType(bytes, byteIndex);\n    switch (type) {\n      case 'timed-metadata':\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (bytes.length - byteIndex < 10) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (timestamp === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          timestamp = probe.aac.parseAacTimestamp(packet);\n        }\n        byteIndex += frameSize;\n        break;\n      case 'audio':\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (bytes.length - byteIndex < 7) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (sampleRate === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          sampleRate = probe.aac.parseSampleRate(packet);\n        }\n        audioCount++;\n        byteIndex += frameSize;\n        break;\n      default:\n        byteIndex++;\n        break;\n    }\n    if (endLoop) {\n      return null;\n    }\n  }\n  if (sampleRate === null || timestamp === null) {\n    return null;\n  }\n\n  var audioTimescale = PES_TIMESCALE / sampleRate;\n\n  var result = {\n    audio: [\n      {\n        type: 'audio',\n        dts: timestamp,\n        pts: timestamp\n      },\n      {\n        type: 'audio',\n        dts: timestamp + (audioCount * 1024 * audioTimescale),\n        pts: timestamp + (audioCount * 1024 * audioTimescale)\n      }\n    ]\n  };\n\n  return result;\n};\n\n/**\n * inspects the transport stream segment data for start and end time information\n * of the audio and video tracks (when present) as well as the first key frame's\n * start time.\n */\nvar inspectTs_ = function(bytes) {\n  var pmt = {\n    pid: null,\n    table: null\n  };\n\n  var result = {};\n\n  parsePsi_(bytes, pmt);\n\n  for (var pid in pmt.table) {\n    if (pmt.table.hasOwnProperty(pid)) {\n      var type = pmt.table[pid];\n      switch (type) {\n        case StreamTypes.H264_STREAM_TYPE:\n          result.video = [];\n          parseVideoPes_(bytes, pmt, result);\n          if (result.video.length === 0) {\n            delete result.video;\n          }\n          break;\n        case StreamTypes.ADTS_STREAM_TYPE:\n          result.audio = [];\n          parseAudioPes_(bytes, pmt, result);\n          if (result.audio.length === 0) {\n            delete result.audio;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Inspects segment byte data and returns an object with start and end timing information\n *\n * @param {Uint8Array} bytes The segment byte data\n * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n *  timestamps for rollover. This value must be in 90khz clock.\n * @return {Object} Object containing start and end frame timing info of segment.\n */\nvar inspect = function(bytes, baseTimestamp) {\n  var isAacData = probe.aac.isLikelyAacData(bytes);\n\n  var result;\n\n  if (isAacData) {\n    result = inspectAac_(bytes);\n  } else {\n    result = inspectTs_(bytes);\n  }\n\n  if (!result || (!result.audio && !result.video)) {\n    return null;\n  }\n\n  adjustTimestamp_(result, baseTimestamp);\n\n  return result;\n};\n\nmodule.exports = {\n  inspect: inspect,\n  parseAudioPes_: parseAudioPes_\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n\n'use strict';\n\n// Supplemental enhancement information (SEI) NAL units have a\n// payload type field to indicate how they are to be\n// interpreted. CEAS-708 caption content is always transmitted with\n// payload type 0x04.\nvar USER_DATA_REGISTERED_ITU_T_T35 = 4,\n    RBSP_TRAILING_BITS = 128;\n\n/**\n  * Parse a supplemental enhancement information (SEI) NAL unit.\n  * Stops parsing once a message of type ITU T T35 has been found.\n  *\n  * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n  * @return {object} the parsed SEI payload\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n  */\nvar parseSei = function(bytes) {\n  var\n    i = 0,\n    result = {\n      payloadType: -1,\n      payloadSize: 0\n    },\n    payloadType = 0,\n    payloadSize = 0;\n\n  // go through the sei_rbsp parsing each each individual sei_message\n  while (i < bytes.byteLength) {\n    // stop once we have hit the end of the sei_rbsp\n    if (bytes[i] === RBSP_TRAILING_BITS) {\n      break;\n    }\n\n    // Parse payload type\n    while (bytes[i] === 0xFF) {\n      payloadType += 255;\n      i++;\n    }\n    payloadType += bytes[i++];\n\n    // Parse payload size\n    while (bytes[i] === 0xFF) {\n      payloadSize += 255;\n      i++;\n    }\n    payloadSize += bytes[i++];\n\n    // this sei_message is a 608/708 caption so save it and break\n    // there can only ever be one caption message in a frame's sei\n    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n      result.payloadType = payloadType;\n      result.payloadSize = payloadSize;\n      result.payload = bytes.subarray(i, i + payloadSize);\n      break;\n    }\n\n    // skip the payload and parse the next message\n    i += payloadSize;\n    payloadType = 0;\n    payloadSize = 0;\n  }\n\n  return result;\n};\n\n// see ANSI/SCTE 128-1 (2013), section 8.1\nvar parseUserData = function(sei) {\n  // itu_t_t35_contry_code must be 181 (United States) for\n  // captions\n  if (sei.payload[0] !== 181) {\n    return null;\n  }\n\n  // itu_t_t35_provider_code should be 49 (ATSC) for captions\n  if (((sei.payload[1] << 8) | sei.payload[2]) !== 49) {\n    return null;\n  }\n\n  // the user_identifier should be \"GA94\" to indicate ATSC1 data\n  if (String.fromCharCode(sei.payload[3],\n                          sei.payload[4],\n                          sei.payload[5],\n                          sei.payload[6]) !== 'GA94') {\n    return null;\n  }\n\n  // finally, user_data_type_code should be 0x03 for caption data\n  if (sei.payload[7] !== 0x03) {\n    return null;\n  }\n\n  // return the user_data_type_structure and strip the trailing\n  // marker bits\n  return sei.payload.subarray(8, sei.payload.length - 1);\n};\n\n// see CEA-708-D, section 4.4\nvar parseCaptionPackets = function(pts, userData) {\n  var results = [], i, count, offset, data;\n\n  // if this is just filler, return immediately\n  if (!(userData[0] & 0x40)) {\n    return results;\n  }\n\n  // parse out the cc_data_1 and cc_data_2 fields\n  count = userData[0] & 0x1f;\n  for (i = 0; i < count; i++) {\n    offset = i * 3;\n    data = {\n      type: userData[offset + 2] & 0x03,\n      pts: pts\n    };\n\n    // capture cc data when cc_valid is 1\n    if (userData[offset + 2] & 0x04) {\n      data.ccData = (userData[offset + 3] << 8) | userData[offset + 4];\n      results.push(data);\n    }\n  }\n  return results;\n};\n\nvar discardEmulationPreventionBytes = function(data) {\n    var\n      length = data.byteLength,\n      emulationPreventionBytesPositions = [],\n      i = 1,\n      newLength, newData;\n\n    // Find all `Emulation Prevention Bytes`\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    }\n\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (emulationPreventionBytesPositions.length === 0) {\n      return data;\n    }\n\n    // Create a new array to hold the NAL unit data\n    newLength = length - emulationPreventionBytesPositions.length;\n    newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        // Skip this byte\n        sourceIndex++;\n        // Remove this position index\n        emulationPreventionBytesPositions.shift();\n      }\n      newData[i] = data[sourceIndex];\n    }\n\n    return newData;\n};\n\n// exports\nmodule.exports = {\n  parseSei: parseSei,\n  parseUserData: parseUserData,\n  parseCaptionPackets: parseCaptionPackets,\n  discardEmulationPreventionBytes: discardEmulationPreventionBytes,\n  USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\n};\n","var ONE_SECOND_IN_TS = 90000; // 90kHz clock\n\n/**\n * Store information about the start and end of the track and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\nvar collectDtsInfo = function(track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    }\n\n    if (track.minSegmentPts === undefined) {\n      track.minSegmentPts = data.pts;\n    } else {\n      track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n    }\n\n    if (track.maxSegmentPts === undefined) {\n      track.maxSegmentPts = data.pts;\n    } else {\n      track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n    }\n  }\n\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    }\n\n    if (track.minSegmentDts === undefined) {\n      track.minSegmentDts = data.dts;\n    } else {\n      track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n    }\n\n    if (track.maxSegmentDts === undefined) {\n      track.maxSegmentDts = data.dts;\n    } else {\n      track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n    }\n  }\n};\n\n/**\n * Clear values used to calculate the baseMediaDecodeTime between\n * tracks\n */\nvar clearDtsInfo = function(track) {\n  delete track.minSegmentDts;\n  delete track.maxSegmentDts;\n  delete track.minSegmentPts;\n  delete track.maxSegmentPts;\n};\n\n/**\n * Calculate the track's baseMediaDecodeTime based on the earliest\n * DTS the transmuxer has ever seen and the minimum DTS for the\n * current track\n * @param track {object} track metadata configuration\n * @param keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at 0.\n */\nvar calculateTrackBaseMediaDecodeTime = function(track, keepOriginalTimestamps) {\n  var\n    baseMediaDecodeTime,\n    scale,\n    minSegmentDts = track.minSegmentDts;\n\n  // Optionally adjust the time so the first segment starts at zero.\n  if (!keepOriginalTimestamps) {\n    minSegmentDts -= track.timelineStartInfo.dts;\n  }\n\n  // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n  // we want the start of the first segment to be placed\n  baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;\n\n  // Add to that the distance this segment is from the very first\n  baseMediaDecodeTime += minSegmentDts;\n\n  // baseMediaDecodeTime must not become negative\n  baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n\n  if (track.type === 'audio') {\n    // Audio has a different clock equal to the sampling_rate so we need to\n    // scale the PTS values into the clock rate of the track\n    scale = track.samplerate / ONE_SECOND_IN_TS;\n    baseMediaDecodeTime *= scale;\n    baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n  }\n\n  return baseMediaDecodeTime;\n};\n\nmodule.exports = {\n  clearDtsInfo: clearDtsInfo,\n  calculateTrackBaseMediaDecodeTime: calculateTrackBaseMediaDecodeTime,\n  collectDtsInfo: collectDtsInfo\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about Aac data.\n */\n'use strict';\n\nvar ADTS_SAMPLING_FREQUENCIES = [\n  96000,\n  88200,\n  64000,\n  48000,\n  44100,\n  32000,\n  24000,\n  22050,\n  16000,\n  12000,\n  11025,\n  8000,\n  7350\n];\n\nvar isLikelyAacData = function(data) {\n  if ((data[0] === 'I'.charCodeAt(0)) &&\n      (data[1] === 'D'.charCodeAt(0)) &&\n      (data[2] === '3'.charCodeAt(0))) {\n    return true;\n  }\n  return false;\n};\n\nvar parseSyncSafeInteger = function(data) {\n  return (data[0] << 21) |\n          (data[1] << 14) |\n          (data[2] << 7) |\n          (data[3]);\n};\n\n// return a percent-encoded representation of the specified byte range\n// @see http://en.wikipedia.org/wiki/Percent-encoding\nvar percentEncode = function(bytes, start, end) {\n  var i, result = '';\n  for (i = start; i < end; i++) {\n    result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n  }\n  return result;\n};\n\n// return the string representation of the specified byte range,\n// interpreted as ISO-8859-1.\nvar parseIso88591 = function(bytes, start, end) {\n  return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n};\n\nvar parseId3TagSize = function(header, byteIndex) {\n  var\n    returnSize = (header[byteIndex + 6] << 21) |\n                 (header[byteIndex + 7] << 14) |\n                 (header[byteIndex + 8] << 7) |\n                 (header[byteIndex + 9]),\n    flags = header[byteIndex + 5],\n    footerPresent = (flags & 16) >> 4;\n\n  if (footerPresent) {\n    return returnSize + 20;\n  }\n  return returnSize + 10;\n};\n\nvar parseAdtsSize = function(header, byteIndex) {\n  var\n    lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n    middle = header[byteIndex + 4] << 3,\n    highTwo = header[byteIndex + 3] & 0x3 << 11;\n\n  return (highTwo | middle) | lowThree;\n};\n\nvar parseType = function(header, byteIndex) {\n  if ((header[byteIndex] === 'I'.charCodeAt(0)) &&\n      (header[byteIndex + 1] === 'D'.charCodeAt(0)) &&\n      (header[byteIndex + 2] === '3'.charCodeAt(0))) {\n    return 'timed-metadata';\n  } else if ((header[byteIndex] & 0xff === 0xff) &&\n             ((header[byteIndex + 1] & 0xf0) === 0xf0)) {\n    return 'audio';\n  }\n  return null;\n};\n\nvar parseSampleRate = function(packet) {\n  var i = 0;\n\n  while (i + 5 < packet.length) {\n    if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\n      // If a valid header was not found,  jump one forward and attempt to\n      // find a valid ADTS header starting at the next byte\n      i++;\n      continue;\n    }\n    return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];\n  }\n\n  return null;\n};\n\nvar parseAacTimestamp = function(packet) {\n  var frameStart, frameSize, frame, frameHeader;\n\n  // find the start of the first frame and the end of the tag\n  frameStart = 10;\n  if (packet[5] & 0x40) {\n    // advance the frame start past the extended header\n    frameStart += 4; // header size field\n    frameStart += parseSyncSafeInteger(packet.subarray(10, 14));\n  }\n\n  // parse one or more ID3 frames\n  // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n  do {\n    // determine the number of bytes in this frame\n    frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));\n    if (frameSize < 1) {\n      return null;\n    }\n    frameHeader = String.fromCharCode(packet[frameStart],\n                                      packet[frameStart + 1],\n                                      packet[frameStart + 2],\n                                      packet[frameStart + 3]);\n\n    if (frameHeader === 'PRIV') {\n      frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\n\n      for (var i = 0; i < frame.byteLength; i++) {\n        if (frame[i] === 0) {\n          var owner = parseIso88591(frame, 0, i);\n          if (owner === 'com.apple.streaming.transportStreamTimestamp') {\n            var d = frame.subarray(i + 1);\n            var size = ((d[3] & 0x01)  << 30) |\n                       (d[4]  << 22) |\n                       (d[5] << 14) |\n                       (d[6] << 6) |\n                       (d[7] >>> 2);\n            size *= 4;\n            size += d[7] & 0x03;\n\n            return size;\n          }\n          break;\n        }\n      }\n    }\n\n    frameStart += 10; // advance past the frame header\n    frameStart += frameSize; // advance past the frame body\n  } while (frameStart < packet.byteLength);\n  return null;\n};\n\nmodule.exports = {\n  isLikelyAacData: isLikelyAacData,\n  parseId3TagSize: parseId3TagSize,\n  parseAdtsSize: parseAdtsSize,\n  parseType: parseType,\n  parseSampleRate: parseSampleRate,\n  parseAacTimestamp: parseAacTimestamp\n};\n"],"sourceRoot":""}